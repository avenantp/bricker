# Template Composer - Jinja2 Decision Tree Builder

A React Flow-based visual template composition system for building complex Jinja2 templates through an intuitive drag-and-drop interface.

## Features

### üé® Visual Decision Tree
- **React Flow Canvas** - Drag-and-drop interface for building template logic
- **Multiple Node Types**:
  - **Fragment Nodes** - Reusable template pieces with Monaco editor
  - **Condition Nodes** - Branching logic with Jinja2 conditions
  - **Merge Nodes** - Combine multiple paths
  - **Start/End Nodes** - Define template boundaries

### ‚úçÔ∏è Monaco Editor Integration
- **Inline Code Editing** - Edit template fragments directly in the flow
- **Syntax Highlighting** - SQL, Python, and Scala support
- **Collapsible Editors** - Expand/collapse to manage canvas space

### üîÄ Template Composition Logic
- **Fragment Toggling** - Enable/disable fragments with a click
- **Conditional Branching** - Add if/else logic to template flow
- **Dependency Resolution** - Automatic variable tracking
- **Template Compilation** - Convert decision tree to final Jinja2 template

### üíæ Database Storage
- **Template Fragments** - Store reusable template pieces
- **Template Compositions** - Save complete decision trees
- **Version History** - Track changes over time
- **Workspace Isolation** - Per-workspace template management

## Architecture

### Database Schema

```sql
-- Template fragments (reusable pieces)
CREATE TABLE template_fragments (
  id UUID PRIMARY KEY,
  workspace_id UUID REFERENCES workspaces(id),
  name TEXT NOT NULL,
  category TEXT, -- 'header', 'validation', 'transformation', etc.
  language TEXT, -- 'sql', 'python', 'scala'
  fragment_content TEXT NOT NULL,
  variables JSONB,
  dependencies JSONB,
  is_public BOOLEAN
);

-- Template compositions (decision trees)
CREATE TABLE template_compositions (
  id UUID PRIMARY KEY,
  workspace_id UUID REFERENCES workspaces(id),
  name TEXT NOT NULL,
  flow_data JSONB NOT NULL, -- React Flow nodes/edges
  language TEXT
);
```

### Component Structure

```
frontend/src/components/Templates/
‚îú‚îÄ‚îÄ TemplateComposer.tsx         # Main canvas component
‚îú‚îÄ‚îÄ TemplatePreview.tsx          # Preview modal with variable substitution
‚îú‚îÄ‚îÄ nodes/
‚îÇ   ‚îú‚îÄ‚îÄ FragmentNode.tsx         # Template fragment node with Monaco editor
‚îÇ   ‚îú‚îÄ‚îÄ ConditionNode.tsx        # Conditional branching node
‚îÇ   ‚îú‚îÄ‚îÄ StartEndNode.tsx         # Start/end markers
‚îÇ   ‚îú‚îÄ‚îÄ MergeNode.tsx            # Path merge node
‚îÇ   ‚îî‚îÄ‚îÄ index.ts                 # Node type registry
‚îî‚îÄ‚îÄ index.tsx                    # Export barrel
```

### Services

```
frontend/src/services/
‚îú‚îÄ‚îÄ template-compiler.ts         # Graph traversal & template compilation
‚îî‚îÄ‚îÄ template-service.ts          # Supabase CRUD operations
```

## Usage

### 1. Create Template Fragments

```typescript
import { createTemplateFragment } from '@/services/template-service';

const fragment = await createTemplateFragment({
  workspace_id: 'workspace-uuid',
  name: 'Table Validation',
  category: 'validation',
  language: 'sql',
  fragment_content: `
    -- Validate table exists
    {% if validate_existence %}
    SELECT CASE
      WHEN COUNT(*) = 0 THEN 'Table does not exist'
      ELSE 'Table exists'
    END
    FROM information_schema.tables
    WHERE table_name = '{{ table_name }}';
    {% endif %}
  `,
  variables: [
    { name: 'validate_existence', type: 'boolean', required: false, default: true },
    { name: 'table_name', type: 'string', required: true }
  ],
  dependencies: [],
  is_public: false,
  created_by: 'user-uuid'
});
```

### 2. Build Template Composition

```typescript
import TemplateComposer from '@/components/Templates/TemplateComposer';

function MyComponent() {
  const fragments = await getTemplateFragments(workspaceId);

  return (
    <TemplateComposer
      workspaceId={workspaceId}
      fragments={fragments}
      onSave={async (composition) => {
        await createTemplateComposition(composition);
      }}
    />
  );
}
```

### 3. Compile Template

The compiler traverses the decision tree and generates the final Jinja2 template:

```typescript
import { compileTemplate } from '@/services/template-compiler';

const compiled = await compileTemplate(nodes, edges);
console.log(compiled);
```

Example output:

```sql
-- Fragment: Header
-- Generated by Uroq Template Composer

-- Fragment: Table Validation
{% if validate_existence %}
SELECT CASE
  WHEN COUNT(*) = 0 THEN 'Table does not exist'
  ELSE 'Table exists'
END
FROM information_schema.tables
WHERE table_name = '{{ table_name }}';
{% endif %}

-- Fragment: Data Processing
CREATE OR REPLACE TABLE {{ catalog_name }}.{{ schema_name }}.{{ table_name }} AS
SELECT * FROM {{ source_table }};
```

## Node Types

### Fragment Node
- **Purpose**: Reusable template code block
- **Features**:
  - Monaco editor for inline editing
  - Toggle enabled/disabled
  - Variable display
  - Expand/collapse editor
- **Handles**: 1 input (top), 1 output (bottom)

### Condition Node
- **Purpose**: Branching logic based on Jinja2 conditions
- **Features**:
  - Editable condition text
  - True/false branch outputs
- **Handles**: 1 input (top), 2 outputs (bottom left/right)

### Merge Node
- **Purpose**: Combine multiple execution paths
- **Features**: Simple merge point
- **Handles**: 2 inputs (top), 1 output (bottom)

### Start/End Nodes
- **Purpose**: Mark template boundaries
- **Handles**: Start (1 output), End (1 input)

## Template Compilation Algorithm

1. **Find Start Node** - Begin traversal
2. **Build Adjacency Map** - Create edge lookup table
3. **Depth-First Traversal**:
   - **Fragment**: Append content if enabled
   - **Condition**: Add if/else blocks, traverse branches
   - **Merge**: Continue traversal
   - **End**: Stop traversal
4. **Collect Variables** - Extract all variables from fragments
5. **Combine Parts** - Join template pieces with newlines

## API Reference

### Template Service

```typescript
// Fragments
createTemplateFragment(fragment): Promise<TemplateFragment>
getTemplateFragments(workspaceId): Promise<TemplateFragment[]>
updateTemplateFragment(id, updates): Promise<TemplateFragment>
deleteTemplateFragment(id): Promise<void>

// Compositions
createTemplateComposition(composition): Promise<TemplateComposition>
getTemplateCompositions(workspaceId): Promise<TemplateComposition[]>
updateTemplateComposition(id, updates): Promise<TemplateComposition>
deleteTemplateComposition(id): Promise<void>

// Versions
createCompositionVersion(compositionId, flowData, compiled, summary, userId): Promise<Version>
getCompositionVersions(compositionId): Promise<Version[]>
```

### Template Compiler

```typescript
compileTemplate(nodes, edges): Promise<string>
validateTemplate(content): { valid: boolean; errors: string[] }
extractVariables(content): string[]
renderTemplate(content, variables): string
```

## Example: Process Staging Table Template

This is a complete example workflow for creating a "process-staging-table" template:

### 1. Create Fragments

```typescript
// Header fragment
await createTemplateFragment({
  name: 'Header',
  category: 'header',
  fragment_content: '-- Process Staging Table\n-- Generated: {{ current_date }}'
});

// Validation fragment
await createTemplateFragment({
  name: 'Validate Table',
  category: 'validation',
  fragment_content: `
    {% if validate_schema %}
    DESCRIBE TABLE {{ catalog }}.{{ schema }}.{{ table }};
    {% endif %}
  `
});

// Processing fragment
await createTemplateFragment({
  name: 'Process Data',
  category: 'transformation',
  fragment_content: `
    CREATE OR REPLACE TABLE {{ catalog }}.{{ schema }}.{{ table }}_processed AS
    SELECT * FROM {{ catalog }}.{{ schema }}.{{ table }}
    WHERE updated_at > CURRENT_DATE - INTERVAL '{{ days }}' DAYS;
  `
});
```

### 2. Build Decision Tree

1. Drag fragments onto canvas
2. Connect: Start ‚Üí Header ‚Üí Condition ‚Üí Validation (true) ‚Üí Processing ‚Üí End
3. Connect: Condition ‚Üí Processing (false, skip validation)
4. Toggle validation fragment on/off as needed

### 3. Compile & Save

Click "Compile" to generate final template, then "Save" to store in database.

## Migration Instructions

To add template composer to your database:

```bash
# Apply migration
psql -h your-supabase-host -U postgres -d postgres -f supabase/template-fragments.sql
```

## Future Enhancements

- [ ] Drag-and-drop fragment library
- [ ] Template testing with sample data
- [ ] AI-powered fragment suggestions
- [ ] Template marketplace for sharing
- [ ] Git integration for version control
- [ ] Multi-language support (beyond SQL/Python/Scala)
- [ ] Advanced variable validation
- [ ] Template diff viewer

## Contributing

When adding new node types:

1. Create node component in `components/Templates/nodes/`
2. Implement `NodeProps<CompositionNodeData>` interface
3. Register in `nodes/index.ts`
4. Update compiler in `services/template-compiler.ts`
5. Add tests

## License

MIT - See LICENSE file for details
