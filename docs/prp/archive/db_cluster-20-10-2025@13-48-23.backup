--
-- PostgreSQL database cluster dump
--

\restrict 8mjAHy9F8cCZ9SUHYLaABTHit9DeqnPECxak9nQlDVSnSpgDpPMr1xx6onl1vhy

SET default_transaction_read_only = off;

SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;

--
-- Roles
--

CREATE ROLE anon;
ALTER ROLE anon WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE authenticated;
ALTER ROLE authenticated WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE authenticator;
ALTER ROLE authenticator WITH NOSUPERUSER NOINHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE dashboard_user;
ALTER ROLE dashboard_user WITH NOSUPERUSER INHERIT CREATEROLE CREATEDB NOLOGIN REPLICATION NOBYPASSRLS;
CREATE ROLE pgbouncer;
ALTER ROLE pgbouncer WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE postgres;
ALTER ROLE postgres WITH NOSUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS;
CREATE ROLE service_role;
ALTER ROLE service_role WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION BYPASSRLS;
CREATE ROLE supabase_admin;
ALTER ROLE supabase_admin WITH SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS;
CREATE ROLE supabase_auth_admin;
ALTER ROLE supabase_auth_admin WITH NOSUPERUSER NOINHERIT CREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE supabase_etl_admin;
ALTER ROLE supabase_etl_admin WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN REPLICATION NOBYPASSRLS;
CREATE ROLE supabase_read_only_user;
ALTER ROLE supabase_read_only_user WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION BYPASSRLS;
CREATE ROLE supabase_realtime_admin;
ALTER ROLE supabase_realtime_admin WITH NOSUPERUSER NOINHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE supabase_replication_admin;
ALTER ROLE supabase_replication_admin WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN REPLICATION NOBYPASSRLS;
CREATE ROLE supabase_storage_admin;
ALTER ROLE supabase_storage_admin WITH NOSUPERUSER NOINHERIT CREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;

--
-- User Configurations
--

--
-- User Config "anon"
--

ALTER ROLE anon SET statement_timeout TO '3s';

--
-- User Config "authenticated"
--

ALTER ROLE authenticated SET statement_timeout TO '8s';

--
-- User Config "authenticator"
--

ALTER ROLE authenticator SET session_preload_libraries TO 'safeupdate';
ALTER ROLE authenticator SET statement_timeout TO '8s';
ALTER ROLE authenticator SET lock_timeout TO '8s';

--
-- User Config "postgres"
--

ALTER ROLE postgres SET search_path TO E'\\$user', 'public', 'extensions';

--
-- User Config "supabase_admin"
--

ALTER ROLE supabase_admin SET search_path TO '$user', 'public', 'auth', 'extensions';
ALTER ROLE supabase_admin SET log_statement TO 'none';

--
-- User Config "supabase_auth_admin"
--

ALTER ROLE supabase_auth_admin SET search_path TO 'auth';
ALTER ROLE supabase_auth_admin SET idle_in_transaction_session_timeout TO '60000';
ALTER ROLE supabase_auth_admin SET log_statement TO 'none';

--
-- User Config "supabase_read_only_user"
--

ALTER ROLE supabase_read_only_user SET default_transaction_read_only TO 'on';

--
-- User Config "supabase_storage_admin"
--

ALTER ROLE supabase_storage_admin SET search_path TO 'storage';
ALTER ROLE supabase_storage_admin SET log_statement TO 'none';


--
-- Role memberships
--

GRANT anon TO authenticator WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT anon TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT authenticated TO authenticator WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT authenticated TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT authenticator TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT authenticator TO supabase_storage_admin WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT pg_create_subscription TO postgres WITH INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_monitor TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_read_all_data TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_read_all_data TO supabase_etl_admin WITH INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_read_all_data TO supabase_read_only_user WITH INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_signal_backend TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT service_role TO authenticator WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT service_role TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT supabase_realtime_admin TO postgres WITH INHERIT TRUE GRANTED BY supabase_admin;






\unrestrict 8mjAHy9F8cCZ9SUHYLaABTHit9DeqnPECxak9nQlDVSnSpgDpPMr1xx6onl1vhy

--
-- Databases
--

--
-- Database "template1" dump
--

\connect template1

--
-- PostgreSQL database dump
--

\restrict CdIdGUhl1yb4csBbTEgM9tZH79qFjCeu9SXiXupy7nPQcA367HuxBnHSPhcApH9

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.6 (Debian 17.6-2.pgdg12+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- PostgreSQL database dump complete
--

\unrestrict CdIdGUhl1yb4csBbTEgM9tZH79qFjCeu9SXiXupy7nPQcA367HuxBnHSPhcApH9

--
-- Database "postgres" dump
--

\connect postgres

--
-- PostgreSQL database dump
--

\restrict 0h58bBZ4Qx3TGsKNQq4jhKouyYfLP0tHNuLR1DrPSIA2lZJ9Kfsfm4YjR8O6Hj0

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.6 (Debian 17.6-2.pgdg12+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: auth; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA auth;


ALTER SCHEMA auth OWNER TO supabase_admin;

--
-- Name: extensions; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA extensions;


ALTER SCHEMA extensions OWNER TO postgres;

--
-- Name: graphql; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql;


ALTER SCHEMA graphql OWNER TO supabase_admin;

--
-- Name: graphql_public; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql_public;


ALTER SCHEMA graphql_public OWNER TO supabase_admin;

--
-- Name: pgbouncer; Type: SCHEMA; Schema: -; Owner: pgbouncer
--

CREATE SCHEMA pgbouncer;


ALTER SCHEMA pgbouncer OWNER TO pgbouncer;

--
-- Name: realtime; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA realtime;


ALTER SCHEMA realtime OWNER TO supabase_admin;

--
-- Name: storage; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA storage;


ALTER SCHEMA storage OWNER TO supabase_admin;

--
-- Name: vault; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA vault;


ALTER SCHEMA vault OWNER TO supabase_admin;

--
-- Name: pg_graphql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_graphql WITH SCHEMA graphql;


--
-- Name: EXTENSION pg_graphql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_graphql IS 'pg_graphql: GraphQL support';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA extensions;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track planning and execution statistics of all SQL statements executed';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: supabase_vault; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS supabase_vault WITH SCHEMA vault;


--
-- Name: EXTENSION supabase_vault; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION supabase_vault IS 'Supabase Vault Extension';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: aal_level; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.aal_level AS ENUM (
    'aal1',
    'aal2',
    'aal3'
);


ALTER TYPE auth.aal_level OWNER TO supabase_auth_admin;

--
-- Name: code_challenge_method; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.code_challenge_method AS ENUM (
    's256',
    'plain'
);


ALTER TYPE auth.code_challenge_method OWNER TO supabase_auth_admin;

--
-- Name: factor_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_status AS ENUM (
    'unverified',
    'verified'
);


ALTER TYPE auth.factor_status OWNER TO supabase_auth_admin;

--
-- Name: factor_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_type AS ENUM (
    'totp',
    'webauthn',
    'phone'
);


ALTER TYPE auth.factor_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_authorization_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_authorization_status AS ENUM (
    'pending',
    'approved',
    'denied',
    'expired'
);


ALTER TYPE auth.oauth_authorization_status OWNER TO supabase_auth_admin;

--
-- Name: oauth_client_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_client_type AS ENUM (
    'public',
    'confidential'
);


ALTER TYPE auth.oauth_client_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_registration_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_registration_type AS ENUM (
    'dynamic',
    'manual'
);


ALTER TYPE auth.oauth_registration_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_response_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_response_type AS ENUM (
    'code'
);


ALTER TYPE auth.oauth_response_type OWNER TO supabase_auth_admin;

--
-- Name: one_time_token_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.one_time_token_type AS ENUM (
    'confirmation_token',
    'reauthentication_token',
    'recovery_token',
    'email_change_token_new',
    'email_change_token_current',
    'phone_change_token'
);


ALTER TYPE auth.one_time_token_type OWNER TO supabase_auth_admin;

--
-- Name: source_control_connection_status; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.source_control_connection_status AS ENUM (
    'not_connected',
    'connected',
    'disconnected',
    'error'
);


ALTER TYPE public.source_control_connection_status OWNER TO postgres;

--
-- Name: source_control_provider; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.source_control_provider AS ENUM (
    'github',
    'gitlab',
    'bitbucket',
    'azure',
    'other'
);


ALTER TYPE public.source_control_provider OWNER TO postgres;

--
-- Name: action; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.action AS ENUM (
    'INSERT',
    'UPDATE',
    'DELETE',
    'TRUNCATE',
    'ERROR'
);


ALTER TYPE realtime.action OWNER TO supabase_admin;

--
-- Name: equality_op; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.equality_op AS ENUM (
    'eq',
    'neq',
    'lt',
    'lte',
    'gt',
    'gte',
    'in'
);


ALTER TYPE realtime.equality_op OWNER TO supabase_admin;

--
-- Name: user_defined_filter; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.user_defined_filter AS (
	column_name text,
	op realtime.equality_op,
	value text
);


ALTER TYPE realtime.user_defined_filter OWNER TO supabase_admin;

--
-- Name: wal_column; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_column AS (
	name text,
	type_name text,
	type_oid oid,
	value jsonb,
	is_pkey boolean,
	is_selectable boolean
);


ALTER TYPE realtime.wal_column OWNER TO supabase_admin;

--
-- Name: wal_rls; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_rls AS (
	wal jsonb,
	is_rls_enabled boolean,
	subscription_ids uuid[],
	errors text[]
);


ALTER TYPE realtime.wal_rls OWNER TO supabase_admin;

--
-- Name: buckettype; Type: TYPE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TYPE storage.buckettype AS ENUM (
    'STANDARD',
    'ANALYTICS'
);


ALTER TYPE storage.buckettype OWNER TO supabase_storage_admin;

--
-- Name: email(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.email() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$$;


ALTER FUNCTION auth.email() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION email(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.email() IS 'Deprecated. Use auth.jwt() -> ''email'' instead.';


--
-- Name: jwt(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.jwt() RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$$;


ALTER FUNCTION auth.jwt() OWNER TO supabase_auth_admin;

--
-- Name: role(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.role() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$$;


ALTER FUNCTION auth.role() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION role(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.role() IS 'Deprecated. Use auth.jwt() -> ''role'' instead.';


--
-- Name: uid(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.uid() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$$;


ALTER FUNCTION auth.uid() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION uid(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.uid() IS 'Deprecated. Use auth.jwt() -> ''sub'' instead.';


--
-- Name: grant_pg_cron_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_cron_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_cron_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_cron_access() IS 'Grants access to pg_cron';


--
-- Name: grant_pg_graphql_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_graphql_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$_$;


ALTER FUNCTION extensions.grant_pg_graphql_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_graphql_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_graphql_access() IS 'Grants access to pg_graphql';


--
-- Name: grant_pg_net_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_net_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_net_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_net_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_net_access() IS 'Grants access to pg_net';


--
-- Name: pgrst_ddl_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_ddl_watch() OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_drop_watch() OWNER TO supabase_admin;

--
-- Name: set_graphql_placeholder(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.set_graphql_placeholder() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$_$;


ALTER FUNCTION extensions.set_graphql_placeholder() OWNER TO supabase_admin;

--
-- Name: FUNCTION set_graphql_placeholder(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.set_graphql_placeholder() IS 'Reintroduces placeholder function for graphql_public.graphql';


--
-- Name: get_auth(text); Type: FUNCTION; Schema: pgbouncer; Owner: supabase_admin
--

CREATE FUNCTION pgbouncer.get_auth(p_usename text) RETURNS TABLE(username text, password text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
begin
    raise debug 'PgBouncer auth request: %', p_usename;

    return query
    select 
        rolname::text, 
        case when rolvaliduntil < now() 
            then null 
            else rolpassword::text 
        end 
    from pg_authid 
    where rolname=$1 and rolcanlogin;
end;
$_$;


ALTER FUNCTION pgbouncer.get_auth(p_usename text) OWNER TO supabase_admin;

--
-- Name: add_company_owner(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_company_owner() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO public.company_members (company_id, user_id, role)
  VALUES (NEW.id, NEW.created_by, 'owner');
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.add_company_owner() OWNER TO postgres;

--
-- Name: add_dataset_to_diagram(uuid, uuid, jsonb, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb DEFAULT NULL::jsonb, p_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO diagram_datasets (
    diagram_id,
    dataset_id,
    location,
    created_by
  ) VALUES (
    p_diagram_id,
    p_dataset_id,
    p_location,
    p_user_id
  )
  ON CONFLICT (diagram_id, dataset_id) DO NOTHING
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$;


ALTER FUNCTION public.add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid) IS 'Adds a dataset to a diagram (updated to use created_by)';


--
-- Name: add_project_owner_to_project_users(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_project_owner_to_project_users() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Only add if owner_id is set
  IF NEW.owner_id IS NOT NULL THEN
    -- Insert owner into project_users (ignore if already exists)
    INSERT INTO project_users (project_id, user_id, role)
    VALUES (NEW.id, NEW.owner_id, 'owner')
    ON CONFLICT (project_id, user_id)
    DO UPDATE SET role = 'owner';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.add_project_owner_to_project_users() OWNER TO postgres;

--
-- Name: FUNCTION add_project_owner_to_project_users(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.add_project_owner_to_project_users() IS 'Automatically add project owner to project_users table';


--
-- Name: add_user_to_account(uuid, uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_user_to_account(p_account_id uuid, p_user_id uuid, p_role character varying, p_invited_by uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_membership_id UUID;
BEGIN
  -- Check if membership already exists
  IF EXISTS (
    SELECT 1 FROM account_users
    WHERE account_id = p_account_id AND user_id = p_user_id
  ) THEN
    -- Reactivate if deactivated
    UPDATE account_users
    SET is_active = true,
        deactivated_at = NULL,
        deactivated_by = NULL,
        deactivation_reason = NULL,
        role = p_role,
        invited_by = p_invited_by,
        invitation_accepted_at = NOW()
    WHERE account_id = p_account_id AND user_id = p_user_id
    RETURNING id INTO v_membership_id;
  ELSE
    -- Create new membership
    INSERT INTO account_users (
      account_id,
      user_id,
      role,
      invited_by,
      invitation_accepted_at,
      is_active,
      joined_at
    ) VALUES (
      p_account_id,
      p_user_id,
      p_role,
      p_invited_by,
      NOW(),
      true,
      NOW()
    )
    RETURNING id INTO v_membership_id;
  END IF;

  -- Update account user count
  UPDATE accounts
  SET current_user_count = (
    SELECT COUNT(*) FROM account_users
    WHERE account_id = p_account_id AND is_active = true
  )
  WHERE id = p_account_id;

  RETURN v_membership_id;
END;
$$;


ALTER FUNCTION public.add_user_to_account(p_account_id uuid, p_user_id uuid, p_role character varying, p_invited_by uuid) OWNER TO postgres;

--
-- Name: add_workspace_owner_to_workspace_users(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_workspace_owner_to_workspace_users() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Only add if owner_id is set
  IF NEW.owner_id IS NOT NULL THEN
    -- Insert owner into workspace_users (ignore if already exists)
    INSERT INTO workspace_users (workspace_id, user_id, role)
    VALUES (NEW.id, NEW.owner_id, 'owner')
    ON CONFLICT (workspace_id, user_id)
    DO UPDATE SET role = 'owner';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.add_workspace_owner_to_workspace_users() OWNER TO postgres;

--
-- Name: FUNCTION add_workspace_owner_to_workspace_users(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.add_workspace_owner_to_workspace_users() IS 'Automatically add workspace owner to workspace_users table';


--
-- Name: archive_old_usage_events(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.archive_old_usage_events(p_days_to_keep integer DEFAULT 365) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM usage_events
  WHERE created_at < NOW() - (p_days_to_keep || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;


ALTER FUNCTION public.archive_old_usage_events(p_days_to_keep integer) OWNER TO postgres;

--
-- Name: auto_expire_invitations(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_expire_invitations() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  -- Update pending invitations that have passed their expiry date
  UPDATE invitations
  SET status = 'expired'
  WHERE status = 'pending'
    AND expires_at < NOW();

  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;


ALTER FUNCTION public.auto_expire_invitations() OWNER TO postgres;

--
-- Name: auto_increment_composition_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_increment_composition_version() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  next_version INTEGER;
BEGIN
  -- Get next version number
  SELECT COALESCE(MAX(version_number), 0) + 1
  INTO next_version
  FROM public.template_composition_versions
  WHERE composition_id = NEW.composition_id;

  NEW.version_number := next_version;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.auto_increment_composition_version() OWNER TO postgres;

--
-- Name: auto_increment_model_version(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.auto_increment_model_version() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  next_version INTEGER;
BEGIN
  -- Get next version number
  SELECT COALESCE(MAX(version_number), 0) + 1
  INTO next_version
  FROM public.model_versions
  WHERE model_id = NEW.model_id;

  NEW.version_number := next_version;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.auto_increment_model_version() OWNER TO postgres;

--
-- Name: calculate_account_usage(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_account_usage(p_account_id uuid) RETURNS TABLE(user_count integer, project_count integer, dataset_count integer, monthly_ai_requests integer, storage_mb integer)
    LANGUAGE plpgsql STABLE
    AS $$BEGIN
  RETURN QUERY
  SELECT
    -- Count active users
    (SELECT COUNT(*)::INTEGER
     FROM account_users
     WHERE account_id = p_account_id
       AND is_active = true
    ) as user_count,

    -- Count projects
    (SELECT COUNT(*)::INTEGER
     FROM projects
     WHERE account_id = p_account_id
    ) as project_count,

    -- Count datasets
    (SELECT COUNT(*)::INTEGER
     FROM datasets
     WHERE account_id = p_account_id
    ) as dataset_count,

    -- Count AI requests in current billing period
    (SELECT COUNT(*)::INTEGER
     FROM usage_events
     WHERE account_id = p_account_id
       AND event_type = 'ai_request'
       AND created_at >= COALESCE(
         (SELECT usage_reset_date FROM accounts WHERE id = p_account_id),
         NOW() - INTERVAL '30 days'
       )
    ) as monthly_ai_requests,

    -- Calculate storage (placeholder - adjust based on actual storage tracking)
    (SELECT COALESCE(SUM(quantity), 0)::INTEGER
     FROM usage_events
     WHERE account_id = p_account_id
       AND event_type = 'storage_used'
       AND unit = 'mb'
       AND created_at >= NOW() - INTERVAL '1 day'
    ) as storage_mb;
END;$$;


ALTER FUNCTION public.calculate_account_usage(p_account_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION calculate_account_usage(p_account_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_account_usage(p_account_id uuid) IS 'Calculate current resource usage for an account across all tracked metrics';


--
-- Name: can_edit_template_composition(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.can_edit_template_composition(composition_uuid uuid, user_uuid uuid, dev_mode_enabled boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  is_system BOOLEAN;
  workspace_uuid UUID;
  user_role TEXT;
BEGIN
  -- Get composition info
  SELECT is_system_template, workspace_id INTO is_system, workspace_uuid
  FROM public.template_compositions
  WHERE id = composition_uuid;

  -- System templates require dev mode
  IF is_system AND NOT dev_mode_enabled THEN
    RETURN false;
  END IF;

  -- Null workspace means system template (editable in dev mode)
  IF workspace_uuid IS NULL THEN
    RETURN dev_mode_enabled;
  END IF;

  -- Check workspace permissions
  SELECT role INTO user_role
  FROM public.workspace_members
  WHERE workspace_id = workspace_uuid
    AND user_id = user_uuid;

  -- Admins and editors can edit workspace templates
  RETURN user_role IN ('owner', 'admin', 'editor');
END;
$$;


ALTER FUNCTION public.can_edit_template_composition(composition_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) OWNER TO postgres;

--
-- Name: can_edit_template_fragment(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.can_edit_template_fragment(fragment_uuid uuid, user_uuid uuid, dev_mode_enabled boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  is_system BOOLEAN;
  workspace_uuid UUID;
  user_role TEXT;
BEGIN
  -- Get fragment info
  SELECT is_system_template, workspace_id INTO is_system, workspace_uuid
  FROM public.template_fragments
  WHERE id = fragment_uuid;

  -- System templates require dev mode
  IF is_system AND NOT dev_mode_enabled THEN
    RETURN false;
  END IF;

  -- Null workspace means system template (editable in dev mode)
  IF workspace_uuid IS NULL THEN
    RETURN dev_mode_enabled;
  END IF;

  -- Check workspace permissions
  SELECT role INTO user_role
  FROM public.workspace_members
  WHERE workspace_id = workspace_uuid
    AND user_id = user_uuid;

  -- Admins and editors can edit workspace templates
  RETURN user_role IN ('owner', 'admin', 'editor');
END;
$$;


ALTER FUNCTION public.can_edit_template_fragment(fragment_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) OWNER TO postgres;

--
-- Name: change_account_user_role(uuid, uuid, character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.change_account_user_role(p_account_id uuid, p_user_id uuid, p_new_role character varying, p_changed_by uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_current_role VARCHAR;
  v_changer_role VARCHAR;
  rows_affected INTEGER;
BEGIN
  -- Validate new role
  IF p_new_role NOT IN ('owner', 'admin', 'member') THEN
    RAISE EXCEPTION 'Invalid role: %. Must be owner, admin, or member', p_new_role;
  END IF;

  -- Get current role
  SELECT role INTO v_current_role
  FROM account_users
  WHERE account_id = p_account_id AND user_id = p_user_id AND is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'User is not an active member of this account';
  END IF;

  -- Get changer's role
  SELECT role INTO v_changer_role
  FROM account_users
  WHERE account_id = p_account_id AND user_id = p_changed_by AND is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Role changer is not a member of this account';
  END IF;

  -- Check permissions: only admins and owners can change roles
  IF v_changer_role NOT IN ('owner', 'admin') THEN
    RAISE EXCEPTION 'Only admins and owners can change user roles';
  END IF;

  -- Cannot change owner role
  IF v_current_role = 'owner' THEN
    RAISE EXCEPTION 'Cannot change role of account owner';
  END IF;

  -- Only owner can create another owner
  IF p_new_role = 'owner' AND v_changer_role != 'owner' THEN
    RAISE EXCEPTION 'Only the owner can grant owner role to another user';
  END IF;

  -- If no change, return early
  IF v_current_role = p_new_role THEN
    RETURN true;
  END IF;

  -- Update role
  UPDATE account_users
  SET role = p_new_role,
      previous_role = v_current_role,
      role_changed_at = NOW(),
      role_changed_by = p_changed_by
  WHERE account_id = p_account_id AND user_id = p_user_id;

  GET DIAGNOSTICS rows_affected = ROW_COUNT;
  RETURN rows_affected > 0;
END;
$$;


ALTER FUNCTION public.change_account_user_role(p_account_id uuid, p_user_id uuid, p_new_role character varying, p_changed_by uuid) OWNER TO postgres;

--
-- Name: check_resource_limit(uuid, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer DEFAULT 1) RETURNS TABLE(allowed boolean, current_usage integer, limit_value integer, percentage numeric, message text)
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_account RECORD;
  v_current INTEGER;
  v_limit INTEGER;
  v_new_total INTEGER;
  v_pct NUMERIC;
BEGIN
  -- Get account limits
  SELECT * INTO v_account
  FROM accounts
  WHERE id = p_account_id;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 0, 0, 0::NUMERIC, 'Account not found'::TEXT;
    RETURN;
  END IF;

  -- Determine current usage and limit based on resource type
  CASE p_resource_type
    WHEN 'users' THEN
      v_current := v_account.current_user_count;
      v_limit := v_account.max_users;

    WHEN 'projects' THEN
      v_current := v_account.current_project_count;
      v_limit := v_account.max_projects;

    WHEN 'datasets' THEN
      v_current := v_account.current_dataset_count;
      v_limit := v_account.max_datasets;

    WHEN 'ai_requests' THEN
      v_current := v_account.current_monthly_ai_requests;
      v_limit := v_account.max_monthly_ai_requests;

    WHEN 'storage' THEN
      v_current := v_account.current_storage_mb;
      v_limit := v_account.max_storage_mb;

    ELSE
      RETURN QUERY SELECT false, 0, 0, 0::NUMERIC, 'Unknown resource type'::TEXT;
      RETURN;
  END CASE;

  -- Calculate new total and percentage
  v_new_total := v_current + p_increment;

  -- Handle unlimited resources (limit = -1)
  IF v_limit = -1 THEN
    RETURN QUERY SELECT
      true,
      v_current,
      v_limit,
      0::NUMERIC,
      'Unlimited'::TEXT;
    RETURN;
  END IF;

  v_pct := ROUND((v_new_total::NUMERIC / v_limit::NUMERIC) * 100, 2);

  -- Check if allowed
  IF v_new_total > v_limit THEN
    RETURN QUERY SELECT
      false,
      v_current,
      v_limit,
      v_pct,
      format('Limit exceeded. Current: %s, Limit: %s, Attempted: %s', v_current, v_limit, v_new_total)::TEXT;
  ELSE
    -- Return with appropriate warning message based on percentage
    RETURN QUERY SELECT
      true,
      v_current,
      v_limit,
      v_pct,
      CASE
        WHEN v_pct >= 95 THEN format('Critical: %s%% of limit used', v_pct)
        WHEN v_pct >= 90 THEN format('Warning: %s%% of limit used', v_pct)
        WHEN v_pct >= 80 THEN format('Notice: %s%% of limit used', v_pct)
        ELSE 'OK'
      END::TEXT;
  END IF;
END;
$$;


ALTER FUNCTION public.check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer) OWNER TO postgres;

--
-- Name: FUNCTION check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer) IS 'Check if incrementing a resource would exceed account limits and return usage details';


--
-- Name: cleanup_expired_api_tokens(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_expired_api_tokens(p_days_old integer DEFAULT 90) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  -- Auto-revoke tokens that have been expired for more than p_days_old days
  UPDATE api_tokens
  SET is_active = false,
      revoked_at = NOW(),
      revoke_reason = 'Automatically revoked - expired ' || p_days_old || ' days ago'
  WHERE is_active = true
    AND expires_at IS NOT NULL
    AND expires_at < NOW() - (p_days_old || ' days')::INTERVAL;

  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;


ALTER FUNCTION public.cleanup_expired_api_tokens(p_days_old integer) OWNER TO postgres;

--
-- Name: cleanup_expired_invitations(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_expired_invitations(p_days_old integer DEFAULT 30) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete invitations that have been expired for more than p_days_old days
  DELETE FROM invitations
  WHERE status = 'expired'
    AND expires_at < NOW() - (p_days_old || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;


ALTER FUNCTION public.cleanup_expired_invitations(p_days_old integer) OWNER TO postgres;

--
-- Name: cleanup_soft_deleted_records(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_soft_deleted_records(p_table_name text, p_days_old integer DEFAULT 90) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql TEXT;
  v_deleted_count INTEGER;
BEGIN
  IF p_table_name NOT IN (
    'accounts', 'columns', 'configurations', 'connections', 'datasets',
    'environments', 'invitations', 'macros', 'projects', 'templates',
    'users', 'workspaces'
  ) THEN
    RAISE EXCEPTION 'Invalid table name: %', p_table_name;
  END IF;

  v_sql := format(
    'DELETE FROM %I WHERE deleted_at IS NOT NULL AND deleted_at < NOW() - ($1 || '' days'')::INTERVAL',
    p_table_name
  );

  EXECUTE v_sql USING p_days_old;
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  RETURN v_deleted_count;
END;
$_$;


ALTER FUNCTION public.cleanup_soft_deleted_records(p_table_name text, p_days_old integer) OWNER TO postgres;

--
-- Name: complete_password_reset(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.complete_password_reset(p_token character varying) RETURNS TABLE(success boolean, user_id uuid, message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_user users;
BEGIN
  -- Validate token first
  SELECT * INTO v_user
  FROM users
  WHERE password_reset_token = p_token
    AND password_reset_expires > NOW()
    AND is_active = true;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, NULL::UUID, 'Invalid or expired reset token'::TEXT;
    RETURN;
  END IF;

  -- Clear reset token and update password change timestamp
  -- Note: Actual password update should be done by auth system (e.g., Supabase Auth)
  UPDATE users
  SET password_reset_token = NULL,
      password_reset_expires = NULL,
      password_changed_at = NOW(),
      failed_login_attempts = 0,
      account_locked_until = NULL
  WHERE id = v_user.id;

  RETURN QUERY SELECT true, v_user.id, 'Password reset successful'::TEXT;
END;
$$;


ALTER FUNCTION public.complete_password_reset(p_token character varying) OWNER TO postgres;

--
-- Name: connect_project_source_control(uuid, character varying, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text DEFAULT 'main'::text) RETURNS TABLE(success boolean, message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Update project with source control information
  UPDATE projects
  SET
    source_control_provider = p_provider::source_control_provider,
    source_control_repo_url = p_repo_url,
    source_control_connection_status = 'connected'::source_control_connection_status,
    source_control_default_branch = p_default_branch,
    source_control_last_synced_at = NOW()
  WHERE id = p_project_id;

  IF FOUND THEN
    RETURN QUERY SELECT TRUE, 'Project source control connected successfully'::TEXT;
  ELSE
    RETURN QUERY SELECT FALSE, 'Project not found'::TEXT;
  END IF;
END;
$$;


ALTER FUNCTION public.connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text) OWNER TO postgres;

--
-- Name: FUNCTION connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text) IS 'Connect a project to a source control repository';


--
-- Name: count_ai_requests_current_period(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.count_ai_requests_current_period(p_account_id uuid) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  request_count INTEGER;
  reset_date TIMESTAMP;
BEGIN
  SELECT usage_reset_date INTO reset_date
  FROM accounts
  WHERE id = p_account_id;

  IF reset_date IS NULL THEN
    reset_date := date_trunc('month', NOW());
  END IF;

  SELECT COUNT(*) INTO request_count
  FROM usage_events
  WHERE account_id = p_account_id
    AND event_type = 'ai_request'
    AND created_at >= reset_date;

  RETURN request_count;
END;
$$;


ALTER FUNCTION public.count_ai_requests_current_period(p_account_id uuid) OWNER TO postgres;

--
-- Name: create_workspace_with_owner(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_workspace_with_owner(p_name text, p_description text DEFAULT NULL::text, p_github_repo_url text DEFAULT NULL::text) RETURNS TABLE(workspace_id uuid, workspace_name text, workspace_description text, workspace_owner_id uuid, workspace_github_repo_url text, workspace_created_at timestamp with time zone, workspace_updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_workspace_id UUID;
  v_user_id UUID;
BEGIN
  -- Get the current user ID
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Ensure user exists in public.users table
  -- This handles cases where user signed up before trigger was created
  INSERT INTO public.users (id, email, full_name, avatar_url)
  SELECT
    au.id,
    au.email,
    au.raw_user_meta_data->>'full_name',
    au.raw_user_meta_data->>'avatar_url'
  FROM auth.users au
  WHERE au.id = v_user_id
  ON CONFLICT (id) DO NOTHING;

  -- Insert workspace
  INSERT INTO public.workspaces (name, description, owner_id, github_repo_url)
  VALUES (p_name, p_description, v_user_id, p_github_repo_url)
  RETURNING workspaces.id INTO v_workspace_id;

  -- Add owner as member (bypasses RLS because of SECURITY DEFINER)
  INSERT INTO public.workspace_members (workspace_id, user_id, role)
  VALUES (v_workspace_id, v_user_id, 'owner');

  -- Return the created workspace with renamed columns to avoid ambiguity
  RETURN QUERY
  SELECT
    w.id,
    w.name,
    w.description,
    w.owner_id,
    w.github_repo_url,
    w.created_at,
    w.updated_at
  FROM public.workspaces w
  WHERE w.id = v_workspace_id;
END;
$$;


ALTER FUNCTION public.create_workspace_with_owner(p_name text, p_description text, p_github_repo_url text) OWNER TO postgres;

--
-- Name: deactivate_account_user(uuid, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.deactivate_account_user(p_account_id uuid, p_user_id uuid, p_deactivated_by uuid, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_user_role VARCHAR;
  v_deactivator_role VARCHAR;
  rows_affected INTEGER;
BEGIN
  -- Get user's role
  SELECT role INTO v_user_role
  FROM account_users
  WHERE account_id = p_account_id AND user_id = p_user_id AND is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'User is not an active member of this account';
  END IF;

  -- Get deactivator's role
  SELECT role INTO v_deactivator_role
  FROM account_users
  WHERE account_id = p_account_id AND user_id = p_deactivated_by AND is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Deactivator is not a member of this account';
  END IF;

  -- Check permissions: only admins and owners can deactivate
  IF v_deactivator_role NOT IN ('owner', 'admin') THEN
    RAISE EXCEPTION 'Only admins and owners can deactivate users';
  END IF;

  -- Cannot deactivate owner
  IF v_user_role = 'owner' THEN
    RAISE EXCEPTION 'Cannot deactivate account owner';
  END IF;

  -- Cannot deactivate self
  IF p_user_id = p_deactivated_by THEN
    RAISE EXCEPTION 'Cannot deactivate yourself';
  END IF;

  -- Deactivate user
  UPDATE account_users
  SET is_active = false,
      deactivated_at = NOW(),
      deactivated_by = p_deactivated_by,
      deactivation_reason = p_reason
  WHERE account_id = p_account_id AND user_id = p_user_id;

  GET DIAGNOSTICS rows_affected = ROW_COUNT;

  -- Update account user count
  UPDATE accounts
  SET current_user_count = (
    SELECT COUNT(*) FROM account_users
    WHERE account_id = p_account_id AND is_active = true
  )
  WHERE id = p_account_id;

  RETURN rows_affected > 0;
END;
$$;


ALTER FUNCTION public.deactivate_account_user(p_account_id uuid, p_user_id uuid, p_deactivated_by uuid, p_reason text) OWNER TO postgres;

--
-- Name: decrement_usage_counter(uuid, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.decrement_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer DEFAULT 1) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_column VARCHAR;
BEGIN
  -- Determine which column to update
  CASE p_resource_type
    WHEN 'users' THEN v_column := 'current_user_count';
    WHEN 'projects' THEN v_column := 'current_project_count';
    WHEN 'datasets' THEN v_column := 'current_dataset_count';
    WHEN 'ai_requests' THEN v_column := 'current_monthly_ai_requests';
    WHEN 'storage' THEN v_column := 'current_storage_mb';
    ELSE RETURN false;
  END CASE;

  -- Update the counter (don't go below 0)
  EXECUTE format('UPDATE accounts SET %I = GREATEST(%I - $1, 0), updated_at = NOW() WHERE id = $2', v_column, v_column)
  USING p_amount, p_account_id;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.decrement_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) OWNER TO postgres;

--
-- Name: disconnect_project_source_control(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.disconnect_project_source_control(p_project_id uuid) RETURNS TABLE(success boolean, message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Update project to disconnect source control and clear credentials
  UPDATE projects
  SET
    source_control_provider = NULL,
    source_control_repo_url = NULL,
    source_control_connection_status = 'not_connected'::source_control_connection_status,
    source_control_default_branch = NULL,
    source_control_last_synced_at = NULL,
    source_control_access_token_encrypted = NULL,
    source_control_refresh_token_encrypted = NULL,
    source_control_token_expires_at = NULL,
    source_control_username = NULL
  WHERE id = p_project_id;

  IF FOUND THEN
    RETURN QUERY SELECT TRUE, 'Project source control disconnected successfully'::TEXT;
  ELSE
    RETURN QUERY SELECT FALSE, 'Project not found'::TEXT;
  END IF;
END;
$$;


ALTER FUNCTION public.disconnect_project_source_control(p_project_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION disconnect_project_source_control(p_project_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.disconnect_project_source_control(p_project_id uuid) IS 'Disconnect a project from source control and clear all credentials';


--
-- Name: generate_api_token(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_api_token() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Generate secure 32-byte token
  -- Format: uro_XXXXXXXX_YYYYYYYY...
  RETURN 'uro_' || encode(gen_random_bytes(32), 'hex');
END;
$$;


ALTER FUNCTION public.generate_api_token() OWNER TO postgres;

--
-- Name: FUNCTION generate_api_token(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.generate_api_token() IS 'Generate a secure API token with uro_ prefix';


--
-- Name: generate_api_token_prefix(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_api_token_prefix() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Generate format: uro_XXXXXXXX
  RETURN 'uro_' || substring(encode(gen_random_bytes(6), 'hex'), 1, 8);
END;
$$;


ALTER FUNCTION public.generate_api_token_prefix() OWNER TO postgres;

--
-- Name: generate_email_verification_token(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_email_verification_token() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Generate a secure random token (32 bytes = 64 hex characters)
  RETURN encode(gen_random_bytes(32), 'hex');
END;
$$;


ALTER FUNCTION public.generate_email_verification_token() OWNER TO postgres;

--
-- Name: generate_invitation_token(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_invitation_token() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Generate a secure random 32-byte token and encode as hex
  RETURN encode(gen_random_bytes(32), 'hex');
END;
$$;


ALTER FUNCTION public.generate_invitation_token() OWNER TO postgres;

--
-- Name: generate_password_reset_token(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_password_reset_token() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Generate a secure random token (32 bytes = 64 hex characters)
  RETURN encode(gen_random_bytes(32), 'hex');
END;
$$;


ALTER FUNCTION public.generate_password_reset_token() OWNER TO postgres;

--
-- Name: get_account_members(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_account_members(p_account_id uuid) RETURNS TABLE(user_id uuid, email character varying, full_name character varying, role character varying, joined_at timestamp without time zone, invited_by_id uuid, invited_by_name character varying, is_active boolean, last_seen_at timestamp without time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    au.user_id,
    u.email,
    u.full_name,
    au.role,
    au.joined_at,
    au.invited_by,
    inviter.full_name as invited_by_name,
    au.is_active,
    u.last_seen_at
  FROM account_users au
  JOIN users u ON au.user_id = u.id
  LEFT JOIN users inviter ON au.invited_by = inviter.id
  WHERE au.account_id = p_account_id
    AND au.is_active = true
  ORDER BY
    CASE au.role
      WHEN 'owner' THEN 1
      WHEN 'admin' THEN 2
      WHEN 'member' THEN 3
    END,
    au.joined_at ASC;
END;
$$;


ALTER FUNCTION public.get_account_members(p_account_id uuid) OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: subscriptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.subscriptions (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    plan_id uuid NOT NULL,
    stripe_subscription_id character varying,
    stripe_customer_id character varying,
    stripe_price_id character varying,
    status character varying NOT NULL,
    start_date timestamp without time zone DEFAULT now() NOT NULL,
    end_date timestamp without time zone,
    current_period_start timestamp without time zone,
    current_period_end timestamp without time zone,
    trial_start timestamp without time zone,
    trial_end timestamp without time zone,
    canceled_at timestamp without time zone,
    ended_at timestamp without time zone,
    billing_cycle character varying,
    cancel_at_period_end boolean DEFAULT false,
    auto_renew boolean DEFAULT true,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    CONSTRAINT subscriptions_billing_cycle_check CHECK (((billing_cycle)::text = ANY ((ARRAY['monthly'::character varying, 'yearly'::character varying])::text[]))),
    CONSTRAINT subscriptions_status_check CHECK (((status)::text = ANY ((ARRAY['trialing'::character varying, 'active'::character varying, 'past_due'::character varying, 'canceled'::character varying, 'unpaid'::character varying, 'incomplete'::character varying, 'incomplete_expired'::character varying, 'paused'::character varying])::text[])))
);


ALTER TABLE public.subscriptions OWNER TO postgres;

--
-- Name: TABLE subscriptions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.subscriptions IS 'Tracks account subscriptions with Stripe integration';


--
-- Name: get_active_subscription(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_active_subscription(p_account_id uuid) RETURNS public.subscriptions
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  active_sub subscriptions;
BEGIN
  SELECT * INTO active_sub
  FROM subscriptions
  WHERE account_id = p_account_id
    AND status IN ('active', 'trialing', 'past_due')
  ORDER BY created_at DESC
  LIMIT 1;
  RETURN active_sub;
END;
$$;


ALTER FUNCTION public.get_active_subscription(p_account_id uuid) OWNER TO postgres;

--
-- Name: get_dataset_fqn(uuid, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_dataset_fqn(p_connection_id uuid, p_schema character varying, p_name character varying) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  v_catalog VARCHAR;
BEGIN
  -- Get catalog from connection
  SELECT catalog INTO v_catalog
  FROM connections
  WHERE id = p_connection_id;

  -- Build FQN: catalog.schema.name
  IF v_catalog IS NOT NULL AND p_schema IS NOT NULL THEN
    RETURN v_catalog || '.' || p_schema || '.' || p_name;
  ELSIF p_schema IS NOT NULL THEN
    RETURN p_schema || '.' || p_name;
  ELSE
    RETURN p_name;
  END IF;
END;
$$;


ALTER FUNCTION public.get_dataset_fqn(p_connection_id uuid, p_schema character varying, p_name character varying) OWNER TO postgres;

--
-- Name: get_diagram_datasets(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_diagram_datasets(p_diagram_id uuid) RETURNS TABLE(dataset_id uuid, dataset_name character varying, fully_qualified_name character varying, location jsonb, is_expanded boolean, created_at timestamp without time zone)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.name,
    d.fully_qualified_name,
    dd.location,
    dd.is_expanded,
    dd.created_at
  FROM diagram_datasets dd
  JOIN datasets d ON d.id = dd.dataset_id
  WHERE dd.diagram_id = p_diagram_id
  ORDER BY dd.created_at;
END;
$$;


ALTER FUNCTION public.get_diagram_datasets(p_diagram_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_diagram_datasets(p_diagram_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_diagram_datasets(p_diagram_id uuid) IS 'Returns all datasets in a diagram (updated to use created_at)';


--
-- Name: get_pending_invitations(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_pending_invitations(p_account_id uuid) RETURNS TABLE(id uuid, email character varying, role character varying, invited_by_name character varying, invited_by_email character varying, token character varying, expires_at timestamp without time zone, created_at timestamp without time zone, message text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  -- First, auto-expire any expired invitations
  PERFORM auto_expire_invitations();

  -- Return pending invitations
  RETURN QUERY
  SELECT
    i.id,
    i.email,
    i.role,
    i.invited_by_name,
    i.invited_by_email,
    i.token,
    i.expires_at,
    i.created_at,
    i.message
  FROM invitations i
  WHERE i.account_id = p_account_id
    AND i.status = 'pending'
    AND i.expires_at > NOW()
  ORDER BY i.created_at DESC;
END;
$$;


ALTER FUNCTION public.get_pending_invitations(p_account_id uuid) OWNER TO postgres;

--
-- Name: get_project_source_control_stats(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_project_source_control_stats(p_account_id uuid) RETURNS TABLE(total_projects integer, projects_with_source_control integer, projects_connected integer, projects_error integer, github_count integer, gitlab_count integer, bitbucket_count integer, azure_count integer, other_count integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::INTEGER AS total_projects,
    COUNT(CASE WHEN source_control_provider IS NOT NULL THEN 1 END)::INTEGER AS projects_with_source_control,
    COUNT(CASE WHEN source_control_connection_status = 'connected' THEN 1 END)::INTEGER AS projects_connected,
    COUNT(CASE WHEN source_control_connection_status = 'error' THEN 1 END)::INTEGER AS projects_error,
    COUNT(CASE WHEN source_control_provider = 'github' THEN 1 END)::INTEGER AS github_count,
    COUNT(CASE WHEN source_control_provider = 'gitlab' THEN 1 END)::INTEGER AS gitlab_count,
    COUNT(CASE WHEN source_control_provider = 'bitbucket' THEN 1 END)::INTEGER AS bitbucket_count,
    COUNT(CASE WHEN source_control_provider = 'azure' THEN 1 END)::INTEGER AS azure_count,
    COUNT(CASE WHEN source_control_provider = 'other' THEN 1 END)::INTEGER AS other_count
  FROM projects
  WHERE account_id = p_account_id;
END;
$$;


ALTER FUNCTION public.get_project_source_control_stats(p_account_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_project_source_control_stats(p_account_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_project_source_control_stats(p_account_id uuid) IS 'Get statistics about source control usage across projects';


--
-- Name: get_project_source_control_status(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_project_source_control_status(p_project_id uuid) RETURNS TABLE(provider character varying, repo_url text, connection_status character varying, default_branch text, last_synced_at timestamp with time zone, has_credentials boolean, workspace_count integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.source_control_provider::VARCHAR,
    p.source_control_repo_url,
    p.source_control_connection_status::VARCHAR,
    p.source_control_default_branch,
    p.source_control_last_synced_at,
    (p.source_control_access_token_encrypted IS NOT NULL) AS has_credentials,
    (SELECT COUNT(*)::INTEGER FROM workspaces WHERE project_id = p_project_id) AS workspace_count
  FROM projects p
  WHERE p.id = p_project_id;
END;
$$;


ALTER FUNCTION public.get_project_source_control_status(p_project_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_project_source_control_status(p_project_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_project_source_control_status(p_project_id uuid) IS 'Get comprehensive source control status for a project (credentials now in projects table)';


--
-- Name: get_project_user_role(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_project_user_role(p_project_id uuid, p_user_id uuid) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_role VARCHAR;
BEGIN
  -- Check if user is the project owner
  SELECT 'owner' INTO v_role
  FROM projects
  WHERE id = p_project_id
    AND owner_id = p_user_id;

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check if user is account admin
  SELECT 'admin' INTO v_role
  FROM projects p
  INNER JOIN account_users au ON au.account_id = p.account_id
  WHERE p.id = p_project_id
    AND au.user_id = p_user_id
    AND au.role = 'admin';

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check project_users table for specific role
  SELECT role INTO v_role
  FROM project_users
  WHERE project_id = p_project_id
    AND user_id = p_user_id;

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check if user has account-level access (default to viewer)
  SELECT 'viewer' INTO v_role
  FROM projects p
  INNER JOIN account_users au ON au.account_id = p.account_id
  WHERE p.id = p_project_id
    AND au.user_id = p_user_id;

  RETURN v_role;
END;
$$;


ALTER FUNCTION public.get_project_user_role(p_project_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_project_user_role(p_project_id uuid, p_user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_project_user_role(p_project_id uuid, p_user_id uuid) IS 'Get the role of a user in a specific project';


--
-- Name: get_usage_summary(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_usage_summary(p_account_id uuid, p_start_date timestamp without time zone DEFAULT NULL::timestamp without time zone, p_end_date timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(event_type character varying, event_count bigint, total_quantity bigint)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  IF p_start_date IS NULL THEN
    p_start_date := NOW() - INTERVAL '30 days';
  END IF;
  IF p_end_date IS NULL THEN
    p_end_date := NOW();
  END IF;

  RETURN QUERY
  SELECT
    ue.event_type,
    COUNT(*) as event_count,
    SUM(ue.quantity)::BIGINT as total_quantity
  FROM usage_events ue
  WHERE ue.account_id = p_account_id
    AND ue.created_at >= p_start_date
    AND ue.created_at <= p_end_date
  GROUP BY ue.event_type
  ORDER BY event_count DESC;
END;
$$;


ALTER FUNCTION public.get_usage_summary(p_account_id uuid, p_start_date timestamp without time zone, p_end_date timestamp without time zone) OWNER TO postgres;

--
-- Name: get_user_api_tokens(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_api_tokens(p_user_id uuid) RETURNS TABLE(id uuid, name character varying, description text, prefix character varying, scopes jsonb, last_used_at timestamp without time zone, usage_count integer, expires_at timestamp without time zone, created_at timestamp without time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.id,
    t.name,
    t.description,
    t.prefix,
    t.scopes,
    t.last_used_at,
    t.usage_count,
    t.expires_at,
    t.created_at
  FROM api_tokens t
  WHERE t.user_id = p_user_id
    AND t.is_active = true
  ORDER BY t.created_at DESC;
END;
$$;


ALTER FUNCTION public.get_user_api_tokens(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_user_projects(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_projects(p_user_id uuid) RETURNS TABLE(project_id uuid, project_name character varying, project_type character varying, account_id uuid, user_role character varying, created_at timestamp without time zone, updated_at timestamp without time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$BEGIN
  RETURN QUERY
  SELECT DISTINCT
    p.id AS project_id,
    p.name AS project_name,
    p.project_type,
    p.account_id,
    get_project_user_role(p.id, p_user_id) AS user_role,
    p.created_at,
    p.updated_at
  FROM projects p
  WHERE p.account_id IN (
      SELECT account_id FROM account_users WHERE user_id = p_user_id
    )
  ORDER BY p.updated_at DESC;
END;$$;


ALTER FUNCTION public.get_user_projects(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_user_workspace_role(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_workspace_role(workspace_uuid uuid, user_uuid uuid) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  user_role TEXT;
BEGIN
  SELECT role INTO user_role
  FROM public.workspace_members
  WHERE workspace_id = workspace_uuid
    AND user_id = user_uuid;

  RETURN COALESCE(user_role, 'none');
END;
$$;


ALTER FUNCTION public.get_user_workspace_role(workspace_uuid uuid, user_uuid uuid) OWNER TO postgres;

--
-- Name: get_user_workspaces(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_workspaces(p_user_id uuid, p_project_id uuid DEFAULT NULL::uuid) RETURNS TABLE(workspace_id uuid, workspace_name character varying, project_id uuid, project_name character varying, account_id uuid, user_role character varying, source_control_status character varying, created_at timestamp without time zone, updated_at timestamp without time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$BEGIN
  RETURN QUERY
  SELECT DISTINCT
    w.id AS workspace_id,
    w.name AS workspace_name,
    w.project_id,
    proj.name AS project_name,
    w.account_id,
    get_workspace_user_role(w.id, p_user_id) AS user_role,
    w.source_control_connection_status AS source_control_status,
    w.created_at,
    w.updated_at
  FROM workspaces w
  INNER JOIN projects proj ON proj.id = w.project_id
  WHERE w.account_id IN (
      SELECT account_id FROM account_users WHERE user_id = p_user_id
    )
    AND (p_project_id IS NULL OR w.project_id = p_project_id)
  ORDER BY w.updated_at DESC;
END;$$;


ALTER FUNCTION public.get_user_workspaces(p_user_id uuid, p_project_id uuid) OWNER TO postgres;

--
-- Name: get_workspace_available_branches(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_workspace_available_branches(p_workspace_id uuid) RETURNS TABLE(project_id uuid, provider character varying, repo_url text, current_branch text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    w.project_id,
    p.source_control_provider::VARCHAR AS provider,
    p.source_control_repo_url AS repo_url,
    w.source_control_branch AS current_branch
  FROM workspaces w
  INNER JOIN projects p ON p.id = w.project_id
  WHERE w.id = p_workspace_id;
END;
$$;


ALTER FUNCTION public.get_workspace_available_branches(p_workspace_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_workspace_available_branches(p_workspace_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_workspace_available_branches(p_workspace_id uuid) IS 'Get project source control info needed to fetch available branches';


--
-- Name: get_workspace_user_role(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_workspace_user_role(p_workspace_id uuid, p_user_id uuid) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_role VARCHAR;
BEGIN
  -- Check if user is the workspace owner
  SELECT 'owner' INTO v_role
  FROM workspaces
  WHERE id = p_workspace_id
    AND owner_id = p_user_id;

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check if user is account admin
  SELECT 'admin' INTO v_role
  FROM workspaces w
  INNER JOIN account_users au ON au.account_id = w.account_id
  WHERE w.id = p_workspace_id
    AND au.user_id = p_user_id
    AND au.role = 'admin';

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check if user is project owner/admin
  SELECT pu.role INTO v_role
  FROM workspaces w
  INNER JOIN project_users pu ON pu.project_id = w.project_id
  WHERE w.id = p_workspace_id
    AND pu.user_id = p_user_id
    AND pu.role IN ('owner', 'admin');

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check workspace_users table for specific role
  SELECT role INTO v_role
  FROM workspace_users
  WHERE workspace_id = p_workspace_id
    AND user_id = p_user_id;

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check if user has project-level access (default to their project role)
  SELECT pu.role INTO v_role
  FROM workspaces w
  INNER JOIN project_users pu ON pu.project_id = w.project_id
  WHERE w.id = p_workspace_id
    AND pu.user_id = p_user_id;

  IF v_role IS NOT NULL THEN
    RETURN v_role;
  END IF;

  -- Check if user has account-level access (default to viewer)
  SELECT 'viewer' INTO v_role
  FROM workspaces w
  INNER JOIN account_users au ON au.account_id = w.account_id
  WHERE w.id = p_workspace_id
    AND au.user_id = p_user_id;

  RETURN v_role;
END;
$$;


ALTER FUNCTION public.get_workspace_user_role(p_workspace_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_workspace_user_role(p_workspace_id uuid, p_user_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_workspace_user_role(p_workspace_id uuid, p_user_id uuid) IS 'Get the role of a user in a specific workspace';


--
-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO public.users (id, email, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'avatar_url'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.handle_new_user() OWNER TO postgres;

--
-- Name: has_project_access(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.has_project_access(p_project_id uuid, p_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM projects p
    WHERE p.id = p_project_id
      AND (
        -- User is project owner
        p.owner_id = p_user_id
        OR
        -- User is account member
        p.account_id IN (
          SELECT account_id
          FROM account_users
          WHERE user_id = p_user_id
        )
        OR
        -- User is project member
        p.id IN (
          SELECT project_id
          FROM project_users
          WHERE user_id = p_user_id
        )
      )
  );
END;$$;


ALTER FUNCTION public.has_project_access(p_project_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: has_project_credentials(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.has_project_credentials(p_project_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS(
    SELECT 1 FROM projects
    WHERE id = p_project_id
      AND source_control_access_token_encrypted IS NOT NULL
  );
END;
$$;


ALTER FUNCTION public.has_project_credentials(p_project_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION has_project_credentials(p_project_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.has_project_credentials(p_project_id uuid) IS 'Check if a project has stored source control credentials (credentials now in projects table)';


--
-- Name: has_workspace_access(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.has_workspace_access(p_workspace_id uuid, p_user_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM workspaces w
    WHERE w.id = p_workspace_id
      AND (
        -- User is workspace owner
        w.owner_id = p_user_id
        OR
        -- User is account member
        w.account_id IN (
          SELECT account_id
          FROM account_users
          WHERE user_id = p_user_id
        )
        OR
        -- User is project member
        w.project_id IN (
          SELECT project_id
          FROM project_users
          WHERE user_id = p_user_id
        )
        OR
        -- User is workspace member
        w.id IN (
          SELECT workspace_id
          FROM workspace_users
          WHERE user_id = p_user_id
        )
      )
  );
END;$$;


ALTER FUNCTION public.has_workspace_access(p_workspace_id uuid, p_user_id uuid) OWNER TO postgres;

--
-- Name: hash_api_token(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.hash_api_token(p_token character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  -- Use pgcrypto extension for SHA-256 hashing
  RETURN encode(digest(p_token, 'sha256'), 'hex');
END;
$$;


ALTER FUNCTION public.hash_api_token(p_token character varying) OWNER TO postgres;

--
-- Name: increment_usage_counter(uuid, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.increment_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer DEFAULT 1) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_column VARCHAR;
BEGIN
  -- Determine which column to update
  CASE p_resource_type
    WHEN 'users' THEN v_column := 'current_user_count';
    WHEN 'projects' THEN v_column := 'current_project_count';
    WHEN 'datasets' THEN v_column := 'current_dataset_count';
    WHEN 'ai_requests' THEN v_column := 'current_monthly_ai_requests';
    WHEN 'storage' THEN v_column := 'current_storage_mb';
    ELSE RETURN false;
  END CASE;

  -- Update the counter using dynamic SQL
  EXECUTE format('UPDATE accounts SET %I = %I + $1, updated_at = NOW() WHERE id = $2', v_column, v_column)
  USING p_amount, p_account_id;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.increment_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) OWNER TO postgres;

--
-- Name: is_subscription_active(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_subscription_active(p_subscription_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  sub_status VARCHAR;
BEGIN
  SELECT status INTO sub_status
  FROM subscriptions
  WHERE id = p_subscription_id;
  RETURN sub_status IN ('active', 'trialing', 'past_due');
END;
$$;


ALTER FUNCTION public.is_subscription_active(p_subscription_id uuid) OWNER TO postgres;

--
-- Name: is_trial_active(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_trial_active(p_subscription_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  sub_record subscriptions;
BEGIN
  SELECT * INTO sub_record
  FROM subscriptions
  WHERE id = p_subscription_id;
  RETURN sub_record.status = 'trialing'
    AND sub_record.trial_end IS NOT NULL
    AND sub_record.trial_end > NOW();
END;
$$;


ALTER FUNCTION public.is_trial_active(p_subscription_id uuid) OWNER TO postgres;

--
-- Name: is_workspace_member(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_workspace_member(workspace_uuid uuid, user_uuid uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.workspace_members
    WHERE workspace_id = workspace_uuid
      AND user_id = user_uuid
  );
END;
$$;


ALTER FUNCTION public.is_workspace_member(workspace_uuid uuid, user_uuid uuid) OWNER TO postgres;

--
-- Name: log_audit_event(uuid, uuid, text, text, uuid, jsonb, jsonb, inet, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.log_audit_event(p_user_id uuid, p_workspace_id uuid, p_action text, p_entity_type text, p_entity_id uuid, p_old_values jsonb DEFAULT NULL::jsonb, p_new_values jsonb DEFAULT NULL::jsonb, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  audit_id UUID;
BEGIN
  INSERT INTO public.audit_log (
    user_id,
    workspace_id,
    action,
    entity_type,
    entity_id,
    old_values,
    new_values,
    ip_address,
    user_agent
  ) VALUES (
    p_user_id,
    p_workspace_id,
    p_action,
    p_entity_type,
    p_entity_id,
    p_old_values,
    p_new_values,
    p_ip_address,
    p_user_agent
  )
  RETURNING id INTO audit_id;

  RETURN audit_id;
END;
$$;


ALTER FUNCTION public.log_audit_event(p_user_id uuid, p_workspace_id uuid, p_action text, p_entity_type text, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text) OWNER TO postgres;

--
-- Name: permanent_delete(text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.permanent_delete(p_table_name text, p_record_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql TEXT;
  v_rows_affected INTEGER;
BEGIN
  IF p_table_name NOT IN (
    'accounts', 'columns', 'configurations', 'connections', 'datasets',
    'environments', 'invitations', 'macros', 'projects', 'templates',
    'users', 'workspaces'
  ) THEN
    RAISE EXCEPTION 'Invalid table name: %', p_table_name;
  END IF;

  v_sql := format(
    'DELETE FROM %I WHERE id = $1 AND deleted_at IS NOT NULL',
    p_table_name
  );

  EXECUTE v_sql USING p_record_id;
  GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
  RETURN v_rows_affected > 0;
END;
$_$;


ALTER FUNCTION public.permanent_delete(p_table_name text, p_record_id uuid) OWNER TO postgres;

--
-- Name: remove_dataset_from_diagram(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_deleted BOOLEAN;
BEGIN
  DELETE FROM diagram_datasets
  WHERE diagram_id = p_diagram_id
    AND dataset_id = p_dataset_id;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted > 0;
END;
$$;


ALTER FUNCTION public.remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid) IS 'Removes a dataset from a diagram';


--
-- Name: request_email_verification(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.request_email_verification(p_user_id uuid) RETURNS TABLE(verification_token character varying, verification_link text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_token VARCHAR;
  v_link TEXT;
BEGIN
  -- Generate new verification token
  v_token := generate_email_verification_token();

  -- Update user record
  UPDATE users
  SET email_verification_token = v_token,
      email_verification_sent_at = NOW()
  WHERE id = p_user_id;

  -- Generate verification link (base URL should be configured in app)
  v_link := '/verify-email?token=' || v_token;

  RETURN QUERY SELECT v_token, v_link;
END;
$$;


ALTER FUNCTION public.request_email_verification(p_user_id uuid) OWNER TO postgres;

--
-- Name: request_password_reset(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.request_password_reset(p_email character varying) RETURNS TABLE(success boolean, reset_token character varying, reset_link text, message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_user users;
  v_token VARCHAR;
  v_link TEXT;
BEGIN
  -- Find user by email
  SELECT * INTO v_user
  FROM users
  WHERE email = p_email
    AND is_active = true;

  IF NOT FOUND THEN
    -- Don't reveal if email exists or not (security)
    RETURN QUERY SELECT true, NULL::VARCHAR, NULL::TEXT, 'If the email exists, a reset link has been sent'::TEXT;
    RETURN;
  END IF;

  -- Check if account is locked
  IF v_user.account_locked_until IS NOT NULL AND v_user.account_locked_until > NOW() THEN
    RETURN QUERY SELECT false, NULL::VARCHAR, NULL::TEXT, 'Account is temporarily locked due to multiple failed login attempts'::TEXT;
    RETURN;
  END IF;

  -- Generate reset token (expires in 1 hour)
  v_token := generate_password_reset_token();

  -- Update user record
  UPDATE users
  SET password_reset_token = v_token,
      password_reset_expires = NOW() + INTERVAL '1 hour'
  WHERE id = v_user.id;

  -- Generate reset link
  v_link := '/reset-password?token=' || v_token;

  RETURN QUERY SELECT true, v_token, v_link, 'Password reset link generated'::TEXT;
END;
$$;


ALTER FUNCTION public.request_password_reset(p_email character varying) OWNER TO postgres;

--
-- Name: reset_failed_login_attempts(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reset_failed_login_attempts(p_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE users
  SET failed_login_attempts = 0,
      last_failed_login_at = NULL,
      account_locked_until = NULL,
      last_login_at = NOW(),
      last_seen_at = NOW()
  WHERE id = p_user_id;
END;
$$;


ALTER FUNCTION public.reset_failed_login_attempts(p_user_id uuid) OWNER TO postgres;

--
-- Name: reset_monthly_usage(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reset_monthly_usage(p_account_id uuid DEFAULT NULL::uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_reset_count INTEGER := 0;
BEGIN
  IF p_account_id IS NULL THEN
    -- Reset all accounts that are due for reset
    UPDATE accounts
    SET
      current_monthly_ai_requests = 0,
      usage_reset_date = NOW(),
      updated_at = NOW()
    WHERE usage_reset_date IS NULL
       OR usage_reset_date < NOW() - INTERVAL '30 days';

    GET DIAGNOSTICS v_reset_count = ROW_COUNT;
  ELSE
    -- Reset specific account
    UPDATE accounts
    SET
      current_monthly_ai_requests = 0,
      usage_reset_date = NOW(),
      updated_at = NOW()
    WHERE id = p_account_id;

    GET DIAGNOSTICS v_reset_count = ROW_COUNT;
  END IF;

  RETURN v_reset_count;
END;
$$;


ALTER FUNCTION public.reset_monthly_usage(p_account_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION reset_monthly_usage(p_account_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reset_monthly_usage(p_account_id uuid) IS 'Reset monthly AI request counter for accounts. Call with NULL to reset all due accounts, or with account_id for specific account';


--
-- Name: restore_deleted(text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.restore_deleted(p_table_name text, p_record_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql TEXT;
  v_rows_affected INTEGER;
BEGIN
  IF p_table_name NOT IN (
    'accounts', 'columns', 'configurations', 'connections', 'datasets',
    'environments', 'invitations', 'macros', 'projects', 'templates',
    'users', 'workspaces'
  ) THEN
    RAISE EXCEPTION 'Invalid table name: %', p_table_name;
  END IF;

  v_sql := format(
    'UPDATE %I SET deleted_at = NULL, deleted_by = NULL WHERE id = $1 AND deleted_at IS NOT NULL',
    p_table_name
  );

  EXECUTE v_sql USING p_record_id;
  GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
  RETURN v_rows_affected > 0;
END;
$_$;


ALTER FUNCTION public.restore_deleted(p_table_name text, p_record_id uuid) OWNER TO postgres;

--
-- Name: revoke_api_token(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revoke_api_token(p_token_id uuid, p_revoked_by uuid, p_reason text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  rows_affected INTEGER;
BEGIN
  UPDATE api_tokens
  SET is_active = false,
      revoked_at = NOW(),
      revoked_by = p_revoked_by,
      revoke_reason = p_reason
  WHERE id = p_token_id
    AND is_active = true;

  GET DIAGNOSTICS rows_affected = ROW_COUNT;
  RETURN rows_affected > 0;
END;
$$;


ALTER FUNCTION public.revoke_api_token(p_token_id uuid, p_revoked_by uuid, p_reason text) OWNER TO postgres;

--
-- Name: set_dataset_owner(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_dataset_owner() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Set owner_id to current user if not already set
  IF NEW.owner_id IS NULL THEN
    NEW.owner_id := auth.uid();
  END IF;

  -- Set created_by to current user if not already set
  IF NEW.created_by IS NULL THEN
    NEW.created_by := auth.uid();
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.set_dataset_owner() OWNER TO postgres;

--
-- Name: soft_delete(text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.soft_delete(p_table_name text, p_record_id uuid, p_deleted_by uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_sql TEXT;
  v_rows_affected INTEGER;
BEGIN
  IF p_table_name NOT IN (
    'accounts', 'columns', 'configurations', 'connections', 'datasets',
    'environments', 'invitations', 'macros', 'projects', 'templates',
    'users', 'workspaces'
  ) THEN
    RAISE EXCEPTION 'Invalid table name: %', p_table_name;
  END IF;

  v_sql := format(
    'UPDATE %I SET deleted_at = NOW(), deleted_by = $1 WHERE id = $2 AND deleted_at IS NULL',
    p_table_name
  );

  EXECUTE v_sql USING p_deleted_by, p_record_id;
  GET DIAGNOSTICS v_rows_affected = ROW_COUNT;
  RETURN v_rows_affected > 0;
END;
$_$;


ALTER FUNCTION public.soft_delete(p_table_name text, p_record_id uuid, p_deleted_by uuid) OWNER TO postgres;

--
-- Name: soft_delete_account(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.soft_delete_account(p_account_id uuid, p_deleted_by uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result JSONB;
  v_projects_count INTEGER;
  v_workspaces_count INTEGER;
  v_datasets_count INTEGER;
BEGIN
  UPDATE accounts
  SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE id = p_account_id AND deleted_at IS NULL;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'message', 'Account not found or already deleted');
  END IF;

  UPDATE projects SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE account_id = p_account_id AND deleted_at IS NULL;
  GET DIAGNOSTICS v_projects_count = ROW_COUNT;

  UPDATE workspaces SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE account_id = p_account_id AND deleted_at IS NULL;
  GET DIAGNOSTICS v_workspaces_count = ROW_COUNT;

  UPDATE datasets SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE account_id = p_account_id AND deleted_at IS NULL;
  GET DIAGNOSTICS v_datasets_count = ROW_COUNT;

  v_result := jsonb_build_object(
    'success', true,
    'account_id', p_account_id,
    'projects_deleted', v_projects_count,
    'workspaces_deleted', v_workspaces_count,
    'datasets_deleted', v_datasets_count
  );

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.soft_delete_account(p_account_id uuid, p_deleted_by uuid) OWNER TO postgres;

--
-- Name: soft_delete_dataset(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.soft_delete_dataset(p_dataset_id uuid, p_deleted_by uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result JSONB;
  v_columns_count INTEGER;
BEGIN
  UPDATE datasets
  SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE id = p_dataset_id AND deleted_at IS NULL;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'message', 'Dataset not found or already deleted');
  END IF;

  UPDATE columns SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE dataset_id = p_dataset_id AND deleted_at IS NULL;
  GET DIAGNOSTICS v_columns_count = ROW_COUNT;

  v_result := jsonb_build_object(
    'success', true,
    'dataset_id', p_dataset_id,
    'columns_deleted', v_columns_count
  );

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.soft_delete_dataset(p_dataset_id uuid, p_deleted_by uuid) OWNER TO postgres;

--
-- Name: soft_delete_project(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.soft_delete_project(p_project_id uuid, p_deleted_by uuid) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_result JSONB;
  v_workspaces_count INTEGER;
BEGIN
  UPDATE projects
  SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE id = p_project_id AND deleted_at IS NULL;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'message', 'Project not found or already deleted');
  END IF;

  UPDATE workspaces SET deleted_at = NOW(), deleted_by = p_deleted_by
  WHERE project_id = p_project_id AND deleted_at IS NULL;
  GET DIAGNOSTICS v_workspaces_count = ROW_COUNT;

  v_result := jsonb_build_object(
    'success', true,
    'project_id', p_project_id,
    'workspaces_deleted', v_workspaces_count
  );

  RETURN v_result;
END;
$$;


ALTER FUNCTION public.soft_delete_project(p_project_id uuid, p_deleted_by uuid) OWNER TO postgres;

--
-- Name: sync_usage_counters(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.sync_usage_counters(p_account_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_usage RECORD;
BEGIN
  -- Calculate actual usage
  SELECT * INTO v_usage FROM calculate_account_usage(p_account_id);

  -- Update all counters
  UPDATE accounts
  SET
    current_user_count = v_usage.user_count,
    current_project_count = v_usage.project_count,
    current_dataset_count = v_usage.dataset_count,
    current_monthly_ai_requests = v_usage.monthly_ai_requests,
    current_storage_mb = v_usage.storage_mb,
    updated_at = NOW()
  WHERE id = p_account_id;

  RETURN true;
END;
$$;


ALTER FUNCTION public.sync_usage_counters(p_account_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION sync_usage_counters(p_account_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.sync_usage_counters(p_account_id uuid) IS 'Recalculate and synchronize all usage counters for an account (use for data integrity checks)';


--
-- Name: test_usage_calculations(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_usage_calculations(p_account_id uuid) RETURNS TABLE(test_name character varying, expected_value integer, actual_value integer, status character varying)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_usage RECORD;
  v_account RECORD;
BEGIN
  -- Get calculated usage
  SELECT * INTO v_usage FROM calculate_account_usage(p_account_id);

  -- Get stored usage
  SELECT * INTO v_account FROM accounts WHERE id = p_account_id;

  -- Test user count
  RETURN QUERY SELECT
    'User Count'::VARCHAR,
    v_usage.user_count,
    v_account.current_user_count,
    CASE WHEN v_usage.user_count = v_account.current_user_count THEN 'PASS' ELSE 'FAIL' END::VARCHAR;

  -- Test project count
  RETURN QUERY SELECT
    'Project Count'::VARCHAR,
    v_usage.project_count,
    v_account.current_project_count,
    CASE WHEN v_usage.project_count = v_account.current_project_count THEN 'PASS' ELSE 'FAIL' END::VARCHAR;

  -- Test dataset count
  RETURN QUERY SELECT
    'Dataset Count'::VARCHAR,
    v_usage.dataset_count,
    v_account.current_dataset_count,
    CASE WHEN v_usage.dataset_count = v_account.current_dataset_count THEN 'PASS' ELSE 'FAIL' END::VARCHAR;

  -- Test AI request count
  RETURN QUERY SELECT
    'AI Request Count'::VARCHAR,
    v_usage.monthly_ai_requests,
    v_account.current_monthly_ai_requests,
    CASE WHEN v_usage.monthly_ai_requests = v_account.current_monthly_ai_requests THEN 'PASS' ELSE 'FAIL' END::VARCHAR;

  -- Test storage
  RETURN QUERY SELECT
    'Storage (MB)'::VARCHAR,
    v_usage.storage_mb,
    v_account.current_storage_mb,
    CASE WHEN v_usage.storage_mb = v_account.current_storage_mb THEN 'PASS' ELSE 'FAIL' END::VARCHAR;
END;
$$;


ALTER FUNCTION public.test_usage_calculations(p_account_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION test_usage_calculations(p_account_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.test_usage_calculations(p_account_id uuid) IS 'Test function to verify usage counters match calculated values';


--
-- Name: token_has_scope(jsonb, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.token_has_scope(p_token_scopes jsonb, p_required_scope character varying) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  -- Check if token has 'admin:all' scope (grants all permissions)
  IF p_token_scopes ? 'admin:all' THEN
    RETURN true;
  END IF;

  -- Check if token has the specific required scope
  RETURN p_token_scopes ? p_required_scope;
END;
$$;


ALTER FUNCTION public.token_has_scope(p_token_scopes jsonb, p_required_scope character varying) OWNER TO postgres;

--
-- Name: track_failed_login(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.track_failed_login(p_email character varying) RETURNS TABLE(attempts_remaining integer, locked_until timestamp without time zone, message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_user users;
  v_max_attempts INTEGER := 5;
  v_lockout_duration INTERVAL := INTERVAL '30 minutes';
BEGIN
  -- Find user
  SELECT * INTO v_user
  FROM users
  WHERE email = p_email;

  IF NOT FOUND THEN
    -- Don't reveal if user exists
    RETURN QUERY SELECT 0, NULL::TIMESTAMP, 'Invalid credentials'::TEXT;
    RETURN;
  END IF;

  -- Increment failed attempts
  UPDATE users
  SET failed_login_attempts = failed_login_attempts + 1,
      last_failed_login_at = NOW(),
      account_locked_until = CASE
        WHEN failed_login_attempts + 1 >= v_max_attempts THEN NOW() + v_lockout_duration
        ELSE account_locked_until
      END
  WHERE id = v_user.id
  RETURNING failed_login_attempts, account_locked_until INTO v_user.failed_login_attempts, v_user.account_locked_until;

  -- Check if account is now locked
  IF v_user.failed_login_attempts >= v_max_attempts THEN
    RETURN QUERY SELECT
      0,
      v_user.account_locked_until,
      'Account locked due to too many failed login attempts. Please try again in 30 minutes or reset your password.'::TEXT;
  ELSE
    RETURN QUERY SELECT
      v_max_attempts - v_user.failed_login_attempts,
      NULL::TIMESTAMP,
      'Invalid credentials. ' || (v_max_attempts - v_user.failed_login_attempts)::TEXT || ' attempts remaining.'::TEXT;
  END IF;
END;
$$;


ALTER FUNCTION public.track_failed_login(p_email character varying) OWNER TO postgres;

--
-- Name: track_usage_event(uuid, uuid, character varying, character varying, integer, character varying, character varying, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.track_usage_event(p_account_id uuid, p_user_id uuid, p_event_type character varying, p_event_category character varying DEFAULT NULL::character varying, p_quantity integer DEFAULT 1, p_unit character varying DEFAULT NULL::character varying, p_resource_type character varying DEFAULT NULL::character varying, p_resource_id uuid DEFAULT NULL::uuid, p_metadata jsonb DEFAULT '{}'::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  event_id UUID;
BEGIN
  INSERT INTO usage_events (
    account_id, user_id, event_type, event_category,
    quantity, unit, resource_type, resource_id, metadata
  ) VALUES (
    p_account_id, p_user_id, p_event_type, p_event_category,
    p_quantity, p_unit, p_resource_type, p_resource_id, p_metadata
  )
  RETURNING id INTO event_id;

  RETURN event_id;
END;
$$;


ALTER FUNCTION public.track_usage_event(p_account_id uuid, p_user_id uuid, p_event_type character varying, p_event_category character varying, p_quantity integer, p_unit character varying, p_resource_type character varying, p_resource_id uuid, p_metadata jsonb) OWNER TO postgres;

--
-- Name: transfer_account_ownership(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_account_ownership(p_account_id uuid, p_current_owner_id uuid, p_new_owner_id uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_current_owner_role VARCHAR;
  v_new_owner_role VARCHAR;
  rows_affected INTEGER;
BEGIN
  -- Verify current owner
  SELECT role INTO v_current_owner_role
  FROM account_users
  WHERE account_id = p_account_id
    AND user_id = p_current_owner_id
    AND is_active = true;

  IF v_current_owner_role != 'owner' THEN
    RAISE EXCEPTION 'User is not the current owner';
  END IF;

  -- Verify new owner is a member
  SELECT role INTO v_new_owner_role
  FROM account_users
  WHERE account_id = p_account_id
    AND user_id = p_new_owner_id
    AND is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'New owner is not a member of this account';
  END IF;

  -- Change current owner to admin
  UPDATE account_users
  SET role = 'admin',
      previous_role = 'owner',
      role_changed_at = NOW(),
      role_changed_by = p_current_owner_id
  WHERE account_id = p_account_id AND user_id = p_current_owner_id;

  -- Change new user to owner
  UPDATE account_users
  SET role = 'owner',
      previous_role = v_new_owner_role,
      role_changed_at = NOW(),
      role_changed_by = p_current_owner_id
  WHERE account_id = p_account_id AND user_id = p_new_owner_id;

  GET DIAGNOSTICS rows_affected = ROW_COUNT;
  RETURN rows_affected > 0;
END;
$$;


ALTER FUNCTION public.transfer_account_ownership(p_account_id uuid, p_current_owner_id uuid, p_new_owner_id uuid) OWNER TO postgres;

--
-- Name: update_account_counters_on_usage_event(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_account_counters_on_usage_event() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.event_type = 'ai_request' THEN
    UPDATE accounts SET current_monthly_ai_requests = current_monthly_ai_requests + NEW.quantity WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'user_added' THEN
    UPDATE accounts SET current_user_count = current_user_count + 1 WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'user_removed' THEN
    UPDATE accounts SET current_user_count = GREATEST(current_user_count - 1, 0) WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'project_created' THEN
    UPDATE accounts SET current_project_count = current_project_count + 1 WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'project_deleted' THEN
    UPDATE accounts SET current_project_count = GREATEST(current_project_count - 1, 0) WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'dataset_created' THEN
    UPDATE accounts SET current_dataset_count = current_dataset_count + 1 WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'dataset_deleted' THEN
    UPDATE accounts SET current_dataset_count = GREATEST(current_dataset_count - 1, 0) WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'storage_used' THEN
    UPDATE accounts SET current_storage_mb = current_storage_mb + NEW.quantity WHERE id = NEW.account_id;
  ELSIF NEW.event_type = 'storage_freed' THEN
    UPDATE accounts SET current_storage_mb = GREATEST(current_storage_mb - NEW.quantity, 0) WHERE id = NEW.account_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_account_counters_on_usage_event() OWNER TO postgres;

--
-- Name: update_account_dataset_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_account_dataset_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- New dataset created
    PERFORM increment_usage_counter(NEW.account_id, 'datasets', 1);
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    -- Check if soft deleted
    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN
      -- Dataset soft deleted
      PERFORM decrement_usage_counter(NEW.account_id, 'datasets', 1);
    ELSIF OLD.deleted_at IS NOT NULL AND NEW.deleted_at IS NULL THEN
      -- Dataset restored
      PERFORM increment_usage_counter(NEW.account_id, 'datasets', 1);
    END IF;
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    -- Dataset hard deleted
    IF OLD.deleted_at IS NULL THEN
      PERFORM decrement_usage_counter(OLD.account_id, 'datasets', 1);
    END IF;
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$;


ALTER FUNCTION public.update_account_dataset_count() OWNER TO postgres;

--
-- Name: update_account_project_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_account_project_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- New project created
    PERFORM increment_usage_counter(NEW.account_id, 'projects', 1);
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    -- Check if soft deleted
    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN
      -- Project soft deleted
      PERFORM decrement_usage_counter(NEW.account_id, 'projects', 1);
    ELSIF OLD.deleted_at IS NOT NULL AND NEW.deleted_at IS NULL THEN
      -- Project restored
      PERFORM increment_usage_counter(NEW.account_id, 'projects', 1);
    END IF;
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    -- Project hard deleted
    IF OLD.deleted_at IS NULL THEN
      PERFORM decrement_usage_counter(OLD.account_id, 'projects', 1);
    END IF;
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$;


ALTER FUNCTION public.update_account_project_count() OWNER TO postgres;

--
-- Name: update_account_user_count(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_account_user_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- New user added
    PERFORM increment_usage_counter(NEW.account_id, 'users', 1);
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    -- Check if is_active changed
    IF OLD.is_active = true AND NEW.is_active = false THEN
      -- User deactivated
      PERFORM decrement_usage_counter(NEW.account_id, 'users', 1);
    ELSIF OLD.is_active = false AND NEW.is_active = true THEN
      -- User reactivated
      PERFORM increment_usage_counter(NEW.account_id, 'users', 1);
    END IF;
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    -- User removed
    IF OLD.is_active = true THEN
      PERFORM decrement_usage_counter(OLD.account_id, 'users', 1);
    END IF;
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$;


ALTER FUNCTION public.update_account_user_count() OWNER TO postgres;

--
-- Name: update_dataset_fqn(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_dataset_fqn() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.fully_qualified_name := get_dataset_fqn(NEW.connection_id, NEW.schema, NEW.name);
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_dataset_fqn() OWNER TO postgres;

--
-- Name: update_datasets_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_datasets_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  NEW.updated_by = auth.uid();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_datasets_updated_at() OWNER TO postgres;

--
-- Name: update_diagram_states_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_diagram_states_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  NEW.version = OLD.version + 1;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_diagram_states_updated_at() OWNER TO postgres;

--
-- Name: update_diagrams_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_diagrams_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  NEW.version = OLD.version + 1;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_diagrams_updated_at() OWNER TO postgres;

--
-- Name: update_last_seen(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_last_seen(p_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE users
  SET last_seen_at = NOW()
  WHERE id = p_user_id;
END;
$$;


ALTER FUNCTION public.update_last_seen(p_user_id uuid) OWNER TO postgres;

--
-- Name: update_notification_settings(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_notification_settings(p_user_id uuid, p_settings jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_new_settings JSONB;
BEGIN
  -- Merge new settings with existing settings
  UPDATE users
  SET notification_settings = notification_settings || p_settings
  WHERE id = p_user_id
  RETURNING notification_settings INTO v_new_settings;

  RETURN v_new_settings;
END;
$$;


ALTER FUNCTION public.update_notification_settings(p_user_id uuid, p_settings jsonb) OWNER TO postgres;

--
-- Name: update_project_source_control_status(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_project_source_control_status(p_project_id uuid, p_status character varying) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  UPDATE projects
  SET
    source_control_connection_status = p_status::source_control_connection_status,
    source_control_last_synced_at = CASE
      WHEN p_status = 'connected' THEN NOW()
      ELSE source_control_last_synced_at
    END
  WHERE id = p_project_id;

  RETURN FOUND;
END;
$$;


ALTER FUNCTION public.update_project_source_control_status(p_project_id uuid, p_status character varying) OWNER TO postgres;

--
-- Name: FUNCTION update_project_source_control_status(p_project_id uuid, p_status character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.update_project_source_control_status(p_project_id uuid, p_status character varying) IS 'Update the connection status of project source control';


--
-- Name: update_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_updated_at() OWNER TO postgres;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_updated_at_column() OWNER TO postgres;

--
-- Name: FUNCTION update_updated_at_column(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.update_updated_at_column() IS 'Universal trigger function to automatically update updated_at timestamp';


--
-- Name: update_workspace_branch(uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_workspace_branch(p_workspace_id uuid, p_branch text) RETURNS TABLE(success boolean, message text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_project_connected BOOLEAN;
BEGIN
  -- Check if parent project has source control connected
  SELECT EXISTS(
    SELECT 1 FROM workspaces w
    INNER JOIN projects p ON p.id = w.project_id
    WHERE w.id = p_workspace_id
      AND p.source_control_provider IS NOT NULL
      AND p.source_control_repo_url IS NOT NULL
  ) INTO v_project_connected;

  IF NOT v_project_connected THEN
    RETURN QUERY SELECT FALSE, 'Project source control not configured'::TEXT;
    RETURN;
  END IF;

  -- Update workspace branch
  UPDATE workspaces
  SET
    source_control_branch = p_branch,
    source_control_commit_sha = NULL, -- Reset commit SHA when switching branches
    source_control_connection_status = 'connected'::source_control_connection_status
  WHERE id = p_workspace_id;

  IF FOUND THEN
    RETURN QUERY SELECT TRUE, 'Workspace branch updated successfully'::TEXT;
  ELSE
    RETURN QUERY SELECT FALSE, 'Workspace not found'::TEXT;
  END IF;
END;
$$;


ALTER FUNCTION public.update_workspace_branch(p_workspace_id uuid, p_branch text) OWNER TO postgres;

--
-- Name: FUNCTION update_workspace_branch(p_workspace_id uuid, p_branch text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.update_workspace_branch(p_workspace_id uuid, p_branch text) IS 'Update the branch a workspace is connected to';


--
-- Name: validate_api_token(character varying, character varying, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_api_token(p_token character varying, p_ip_address character varying DEFAULT NULL::character varying, p_user_agent text DEFAULT NULL::text) RETURNS TABLE(token_id uuid, account_id uuid, user_id uuid, scopes jsonb, is_valid boolean, error_message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_token_hash VARCHAR;
  v_token_record api_tokens;
BEGIN
  -- Hash the incoming token
  v_token_hash := hash_api_token(p_token);

  -- Look up token by hash
  SELECT * INTO v_token_record
  FROM api_tokens
  WHERE token_hash = v_token_hash;

  -- Check if token exists
  IF NOT FOUND THEN
    RETURN QUERY SELECT NULL::UUID, NULL::UUID, NULL::UUID, NULL::JSONB, false, 'Invalid token'::TEXT;
    RETURN;
  END IF;

  -- Check if token is active
  IF NOT v_token_record.is_active THEN
    RETURN QUERY SELECT
      v_token_record.id,
      v_token_record.account_id,
      v_token_record.user_id,
      v_token_record.scopes,
      false,
      'Token has been revoked'::TEXT;
    RETURN;
  END IF;

  -- Check if token is expired
  IF v_token_record.expires_at IS NOT NULL AND v_token_record.expires_at < NOW() THEN
    -- Auto-revoke expired token
    UPDATE api_tokens
    SET is_active = false,
        revoked_at = NOW(),
        revoke_reason = 'Token expired'
    WHERE id = v_token_record.id;

    RETURN QUERY SELECT
      v_token_record.id,
      v_token_record.account_id,
      v_token_record.user_id,
      v_token_record.scopes,
      false,
      'Token has expired'::TEXT;
    RETURN;
  END IF;

  -- Token is valid - update usage stats
  UPDATE api_tokens
  SET last_used_at = NOW(),
      usage_count = usage_count + 1,
      last_used_ip = COALESCE(p_ip_address, last_used_ip),
      last_used_user_agent = COALESCE(p_user_agent, last_used_user_agent)
  WHERE id = v_token_record.id;

  -- Return valid token info
  RETURN QUERY SELECT
    v_token_record.id,
    v_token_record.account_id,
    v_token_record.user_id,
    v_token_record.scopes,
    true,
    NULL::TEXT;
END;
$$;


ALTER FUNCTION public.validate_api_token(p_token character varying, p_ip_address character varying, p_user_agent text) OWNER TO postgres;

--
-- Name: validate_password_reset_token(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_password_reset_token(p_token character varying) RETURNS TABLE(valid boolean, user_id uuid, user_email character varying, message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_user users;
BEGIN
  -- Find user by reset token
  SELECT * INTO v_user
  FROM users
  WHERE password_reset_token = p_token
    AND is_active = true;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, NULL::UUID, NULL::VARCHAR, 'Invalid reset token'::TEXT;
    RETURN;
  END IF;

  -- Check if token has expired
  IF v_user.password_reset_expires < NOW() THEN
    -- Clear expired token
    UPDATE users
    SET password_reset_token = NULL,
        password_reset_expires = NULL
    WHERE id = v_user.id;

    RETURN QUERY SELECT false, NULL::UUID, NULL::VARCHAR, 'Reset token has expired'::TEXT;
    RETURN;
  END IF;

  RETURN QUERY SELECT true, v_user.id, v_user.email, 'Token is valid'::TEXT;
END;
$$;


ALTER FUNCTION public.validate_password_reset_token(p_token character varying) OWNER TO postgres;

--
-- Name: validate_project_source_control_setup(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validate_project_source_control_setup(p_project_id uuid) RETURNS TABLE(is_valid boolean, has_provider boolean, has_repo_url boolean, has_credentials boolean, has_default_branch boolean, missing_items text[])
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_provider VARCHAR;
  v_repo_url TEXT;
  v_default_branch TEXT;
  v_has_credentials BOOLEAN;
  v_missing TEXT[];
BEGIN
  -- Get project source control configuration
  SELECT
    p.source_control_provider::VARCHAR,
    p.source_control_repo_url,
    p.source_control_default_branch,
    has_project_credentials(p.id)
  INTO
    v_provider,
    v_repo_url,
    v_default_branch,
    v_has_credentials
  FROM projects p
  WHERE p.id = p_project_id;

  -- Build list of missing items
  v_missing := ARRAY[]::TEXT[];

  IF v_provider IS NULL THEN
    v_missing := array_append(v_missing, 'provider');
  END IF;

  IF v_repo_url IS NULL THEN
    v_missing := array_append(v_missing, 'repository_url');
  END IF;

  IF v_default_branch IS NULL THEN
    v_missing := array_append(v_missing, 'default_branch');
  END IF;

  IF NOT v_has_credentials THEN
    v_missing := array_append(v_missing, 'credentials');
  END IF;

  RETURN QUERY SELECT
    (array_length(v_missing, 1) IS NULL OR array_length(v_missing, 1) = 0) AS is_valid,
    v_provider IS NOT NULL AS has_provider,
    v_repo_url IS NOT NULL AS has_repo_url,
    v_has_credentials AS has_credentials,
    v_default_branch IS NOT NULL AS has_default_branch,
    v_missing AS missing_items;
END;
$$;


ALTER FUNCTION public.validate_project_source_control_setup(p_project_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION validate_project_source_control_setup(p_project_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.validate_project_source_control_setup(p_project_id uuid) IS 'Validate that a project has complete source control configuration';


--
-- Name: verify_email(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.verify_email(p_token character varying) RETURNS TABLE(success boolean, user_id uuid, message text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_user users;
BEGIN
  -- Find user by verification token
  SELECT * INTO v_user
  FROM users
  WHERE email_verification_token = p_token;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, NULL::UUID, 'Invalid verification token'::TEXT;
    RETURN;
  END IF;

  -- Check if already verified
  IF v_user.is_email_verified THEN
    RETURN QUERY SELECT false, v_user.id, 'Email already verified'::TEXT;
    RETURN;
  END IF;

  -- Verify email
  UPDATE users
  SET is_email_verified = true,
      email_verification_token = NULL,
      email_verification_sent_at = NULL
  WHERE id = v_user.id;

  RETURN QUERY SELECT true, v_user.id, 'Email verified successfully'::TEXT;
END;
$$;


ALTER FUNCTION public.verify_email(p_token character varying) OWNER TO postgres;

--
-- Name: apply_rls(jsonb, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)) RETURNS SETOF realtime.wal_rls
    LANGUAGE plpgsql
    AS $$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_;

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add "record" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add "old_record" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '"' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$$;


ALTER FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: broadcast_changes(text, text, text, text, text, record, record, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$$;


ALTER FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) OWNER TO supabase_admin;

--
-- Name: build_prepared_statement_sql(text, regclass, realtime.wal_column[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) RETURNS text
    LANGUAGE sql
    AS $$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{"id"}'::text[], '{"bigint"}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $$;


ALTER FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) OWNER TO supabase_admin;

--
-- Name: cast(text, regtype); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime."cast"(val text, type_ regtype) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $$;


ALTER FUNCTION realtime."cast"(val text, type_ regtype) OWNER TO supabase_admin;

--
-- Name: check_equality_op(realtime.equality_op, regtype, text, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $$;


ALTER FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) OWNER TO supabase_admin;

--
-- Name: is_visible_through_filters(realtime.wal_column[], realtime.user_defined_filter[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $_$;


ALTER FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) OWNER TO supabase_admin;

--
-- Name: list_changes(name, name, integer, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) RETURNS SETOF realtime.wal_rls
    LANGUAGE sql
    SET log_min_messages TO 'fatal'
    AS $$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $$;


ALTER FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: quote_wal2json(regclass); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.quote_wal2json(entity regclass) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $$;


ALTER FUNCTION realtime.quote_wal2json(entity regclass) OWNER TO supabase_admin;

--
-- Name: send(jsonb, text, text, boolean); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  BEGIN
    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (payload, event, topic, private, extension)
    VALUES (payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;
  END;
END;
$$;


ALTER FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) OWNER TO supabase_admin;

--
-- Name: subscription_check_filters(); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.subscription_check_filters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $$;


ALTER FUNCTION realtime.subscription_check_filters() OWNER TO supabase_admin;

--
-- Name: to_regrole(text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.to_regrole(role_name text) RETURNS regrole
    LANGUAGE sql IMMUTABLE
    AS $$ select role_name::regrole $$;


ALTER FUNCTION realtime.to_regrole(role_name text) OWNER TO supabase_admin;

--
-- Name: topic(); Type: FUNCTION; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE FUNCTION realtime.topic() RETURNS text
    LANGUAGE sql STABLE
    AS $$
select nullif(current_setting('realtime.topic', true), '')::text;
$$;


ALTER FUNCTION realtime.topic() OWNER TO supabase_realtime_admin;

--
-- Name: add_prefixes(text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.add_prefixes(_bucket_id text, _name text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    prefixes text[];
BEGIN
    prefixes := "storage"."get_prefixes"("_name");

    IF array_length(prefixes, 1) > 0 THEN
        INSERT INTO storage.prefixes (name, bucket_id)
        SELECT UNNEST(prefixes) as name, "_bucket_id" ON CONFLICT DO NOTHING;
    END IF;
END;
$$;


ALTER FUNCTION storage.add_prefixes(_bucket_id text, _name text) OWNER TO supabase_storage_admin;

--
-- Name: can_insert_object(text, text, uuid, jsonb); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$$;


ALTER FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) OWNER TO supabase_storage_admin;

--
-- Name: delete_leaf_prefixes(text[], text[]); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_rows_deleted integer;
BEGIN
    LOOP
        WITH candidates AS (
            SELECT DISTINCT
                t.bucket_id,
                unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        ),
        uniq AS (
             SELECT
                 bucket_id,
                 name,
                 storage.get_level(name) AS level
             FROM candidates
             WHERE name <> ''
             GROUP BY bucket_id, name
        ),
        leaf AS (
             SELECT
                 p.bucket_id,
                 p.name,
                 p.level
             FROM storage.prefixes AS p
                  JOIN uniq AS u
                       ON u.bucket_id = p.bucket_id
                           AND u.name = p.name
                           AND u.level = p.level
             WHERE NOT EXISTS (
                 SELECT 1
                 FROM storage.objects AS o
                 WHERE o.bucket_id = p.bucket_id
                   AND o.level = p.level + 1
                   AND o.name COLLATE "C" LIKE p.name || '/%'
             )
             AND NOT EXISTS (
                 SELECT 1
                 FROM storage.prefixes AS c
                 WHERE c.bucket_id = p.bucket_id
                   AND c.level = p.level + 1
                   AND c.name COLLATE "C" LIKE p.name || '/%'
             )
        )
        DELETE
        FROM storage.prefixes AS p
            USING leaf AS l
        WHERE p.bucket_id = l.bucket_id
          AND p.name = l.name
          AND p.level = l.level;

        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$$;


ALTER FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[]) OWNER TO supabase_storage_admin;

--
-- Name: delete_prefix(text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_prefix(_bucket_id text, _name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Check if we can delete the prefix
    IF EXISTS(
        SELECT FROM "storage"."prefixes"
        WHERE "prefixes"."bucket_id" = "_bucket_id"
          AND level = "storage"."get_level"("_name") + 1
          AND "prefixes"."name" COLLATE "C" LIKE "_name" || '/%'
        LIMIT 1
    )
    OR EXISTS(
        SELECT FROM "storage"."objects"
        WHERE "objects"."bucket_id" = "_bucket_id"
          AND "storage"."get_level"("objects"."name") = "storage"."get_level"("_name") + 1
          AND "objects"."name" COLLATE "C" LIKE "_name" || '/%'
        LIMIT 1
    ) THEN
    -- There are sub-objects, skip deletion
    RETURN false;
    ELSE
        DELETE FROM "storage"."prefixes"
        WHERE "prefixes"."bucket_id" = "_bucket_id"
          AND level = "storage"."get_level"("_name")
          AND "prefixes"."name" = "_name";
        RETURN true;
    END IF;
END;
$$;


ALTER FUNCTION storage.delete_prefix(_bucket_id text, _name text) OWNER TO supabase_storage_admin;

--
-- Name: delete_prefix_hierarchy_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_prefix_hierarchy_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    prefix text;
BEGIN
    prefix := "storage"."get_prefix"(OLD."name");

    IF coalesce(prefix, '') != '' THEN
        PERFORM "storage"."delete_prefix"(OLD."bucket_id", prefix);
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION storage.delete_prefix_hierarchy_trigger() OWNER TO supabase_storage_admin;

--
-- Name: enforce_bucket_name_length(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.enforce_bucket_name_length() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if length(new.name) > 100 then
        raise exception 'bucket name "%" is too long (% characters). Max is 100.', new.name, length(new.name);
    end if;
    return new;
end;
$$;


ALTER FUNCTION storage.enforce_bucket_name_length() OWNER TO supabase_storage_admin;

--
-- Name: extension(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.extension(name text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$$;


ALTER FUNCTION storage.extension(name text) OWNER TO supabase_storage_admin;

--
-- Name: filename(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.filename(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$$;


ALTER FUNCTION storage.filename(name text) OWNER TO supabase_storage_admin;

--
-- Name: foldername(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.foldername(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
BEGIN
    -- Split on "/" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$$;


ALTER FUNCTION storage.foldername(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_level(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_level(name text) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT array_length(string_to_array("name", '/'), 1);
$$;


ALTER FUNCTION storage.get_level(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefix(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefix(name text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT
    CASE WHEN strpos("name", '/') > 0 THEN
             regexp_replace("name", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$_$;


ALTER FUNCTION storage.get_prefix(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefixes(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefixes(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array("name", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$$;


ALTER FUNCTION storage.get_prefixes(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_size_by_bucket(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_size_by_bucket() RETURNS TABLE(size bigint, bucket_id text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$$;


ALTER FUNCTION storage.get_size_by_bucket() OWNER TO supabase_storage_admin;

--
-- Name: list_multipart_uploads_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text) RETURNS TABLE(key text, id text, created_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$_$;


ALTER FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text) OWNER TO supabase_storage_admin;

--
-- Name: list_objects_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text) RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$_$;


ALTER FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text) OWNER TO supabase_storage_admin;

--
-- Name: lock_top_prefixes(text[], text[]); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bucket text;
    v_top text;
BEGIN
    FOR v_bucket, v_top IN
        SELECT DISTINCT t.bucket_id,
            split_part(t.name, '/', 1) AS top
        FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        WHERE t.name <> ''
        ORDER BY 1, 2
        LOOP
            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));
        END LOOP;
END;
$$;


ALTER FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[]) OWNER TO supabase_storage_admin;

--
-- Name: objects_delete_cleanup(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_delete_cleanup() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.objects_delete_cleanup() OWNER TO supabase_storage_admin;

--
-- Name: objects_insert_prefix_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_insert_prefix_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    NEW.level := "storage"."get_level"(NEW."name");

    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_insert_prefix_trigger() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_cleanup(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_cleanup() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    -- NEW - OLD (destinations to create prefixes for)
    v_add_bucket_ids text[];
    v_add_names      text[];

    -- OLD - NEW (sources to prune)
    v_src_bucket_ids text[];
    v_src_names      text[];
BEGIN
    IF TG_OP <> 'UPDATE' THEN
        RETURN NULL;
    END IF;

    -- 1) Compute NEW−OLD (added paths) and OLD−NEW (moved-away paths)
    WITH added AS (
        SELECT n.bucket_id, n.name
        FROM new_rows n
        WHERE n.name <> '' AND position('/' in n.name) > 0
        EXCEPT
        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''
    ),
    moved AS (
         SELECT o.bucket_id, o.name
         FROM old_rows o
         WHERE o.name <> ''
         EXCEPT
         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''
    )
    SELECT
        -- arrays for ADDED (dest) in stable order
        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        -- arrays for MOVED (src) in stable order
        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),
        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )
    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;

    -- Nothing to do?
    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN
        RETURN NULL;
    END IF;

    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks
    DECLARE
        v_all_bucket_ids text[];
        v_all_names text[];
    BEGIN
        -- Combine source and destination arrays for consistent lock ordering
        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');
        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');

        -- Single lock call ensures consistent global ordering across all transactions
        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN
            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);
        END IF;
    END;

    -- 3) Create destination prefixes (NEW−OLD) BEFORE pruning sources
    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN
        WITH candidates AS (
            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)
            WHERE name <> ''
        )
        INSERT INTO storage.prefixes (bucket_id, name)
        SELECT c.bucket_id, c.name
        FROM candidates c
        ON CONFLICT DO NOTHING;
    END IF;

    -- 4) Prune source prefixes bottom-up for OLD−NEW
    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN
        -- re-entrancy guard so DELETE on prefixes won't recurse
        IF current_setting('storage.gc.prefixes', true) <> '1' THEN
            PERFORM set_config('storage.gc.prefixes', '1', true);
        END IF;

        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);
    END IF;

    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.objects_update_cleanup() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_level_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_level_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW."name" <> OLD."name" OR NEW."bucket_id" <> OLD."bucket_id") THEN
        -- Set the new level
        NEW."level" := "storage"."get_level"(NEW."name");
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_update_level_trigger() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_prefix_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_prefix_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_prefixes TEXT[];
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW."name" <> OLD."name" OR NEW."bucket_id" <> OLD."bucket_id") THEN
        -- Retrieve old prefixes
        old_prefixes := "storage"."get_prefixes"(OLD."name");

        -- Remove old prefixes that are only used by this object
        WITH all_prefixes as (
            SELECT unnest(old_prefixes) as prefix
        ),
        can_delete_prefixes as (
             SELECT prefix
             FROM all_prefixes
             WHERE NOT EXISTS (
                 SELECT 1 FROM "storage"."objects"
                 WHERE "bucket_id" = OLD."bucket_id"
                   AND "name" <> OLD."name"
                   AND "name" LIKE (prefix || '%')
             )
         )
        DELETE FROM "storage"."prefixes" WHERE name IN (SELECT prefix FROM can_delete_prefixes);

        -- Add new prefixes
        PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    END IF;
    -- Set the new level
    NEW."level" := "storage"."get_level"(NEW."name");

    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_update_prefix_trigger() OWNER TO supabase_storage_admin;

--
-- Name: operation(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.operation() RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$$;


ALTER FUNCTION storage.operation() OWNER TO supabase_storage_admin;

--
-- Name: prefixes_delete_cleanup(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.prefixes_delete_cleanup() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.prefixes_delete_cleanup() OWNER TO supabase_storage_admin;

--
-- Name: prefixes_insert_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.prefixes_insert_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.prefixes_insert_trigger() OWNER TO supabase_storage_admin;

--
-- Name: search(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql
    AS $$
declare
    can_bypass_rls BOOLEAN;
begin
    SELECT rolbypassrls
    INTO can_bypass_rls
    FROM pg_roles
    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);

    IF can_bypass_rls THEN
        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    ELSE
        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    END IF;
end;
$$;


ALTER FUNCTION storage.search(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_legacy_v1(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v1_optimised(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select (string_to_array(name, ''/''))[level] as name
           from storage.prefixes
             where lower(prefixes.name) like lower($2 || $3) || ''%''
               and bucket_id = $4
               and level = $1
           order by name ' || v_sort_order || '
     )
     (select name,
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[level] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where lower(objects.name) like lower($2 || $3) || ''%''
       and bucket_id = $4
       and level = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v2(text, text, integer, integer, text, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text) RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    sort_col text;
    sort_ord text;
    cursor_op text;
    cursor_expr text;
    sort_expr text;
BEGIN
    -- Validate sort_order
    sort_ord := lower(sort_order);
    IF sort_ord NOT IN ('asc', 'desc') THEN
        sort_ord := 'asc';
    END IF;

    -- Determine cursor comparison operator
    IF sort_ord = 'asc' THEN
        cursor_op := '>';
    ELSE
        cursor_op := '<';
    END IF;
    
    sort_col := lower(sort_column);
    -- Validate sort column  
    IF sort_col IN ('updated_at', 'created_at') THEN
        cursor_expr := format(
            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE "C") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',
            sort_col, cursor_op
        );
        sort_expr := format(
            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE "C" %s',
            sort_col, sort_ord, sort_ord
        );
    ELSE
        cursor_expr := format('($5 = '''' OR name COLLATE "C" %s $5)', cursor_op);
        sort_expr := format('name COLLATE "C" %s', sort_ord);
    END IF;

    RETURN QUERY EXECUTE format(
        $sql$
        SELECT * FROM (
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    NULL::uuid AS id,
                    updated_at,
                    created_at,
                    NULL::timestamptz AS last_accessed_at,
                    NULL::jsonb AS metadata
                FROM storage.prefixes
                WHERE name COLLATE "C" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
            UNION ALL
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    id,
                    updated_at,
                    created_at,
                    last_accessed_at,
                    metadata
                FROM storage.objects
                WHERE name COLLATE "C" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
        ) obj
        ORDER BY %s
        LIMIT $3
        $sql$,
        cursor_expr,    -- prefixes WHERE
        sort_expr,      -- prefixes ORDER BY
        cursor_expr,    -- objects WHERE
        sort_expr,      -- objects ORDER BY
        sort_expr       -- final ORDER BY
    )
    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;
END;
$_$;


ALTER FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text) OWNER TO supabase_storage_admin;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$$;


ALTER FUNCTION storage.update_updated_at_column() OWNER TO supabase_storage_admin;

--
-- Name: audit_log_entries; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.audit_log_entries (
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE auth.audit_log_entries OWNER TO supabase_auth_admin;

--
-- Name: TABLE audit_log_entries; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.audit_log_entries IS 'Auth: Audit trail for user actions.';


--
-- Name: flow_state; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.flow_state (
    id uuid NOT NULL,
    user_id uuid,
    auth_code text NOT NULL,
    code_challenge_method auth.code_challenge_method NOT NULL,
    code_challenge text NOT NULL,
    provider_type text NOT NULL,
    provider_access_token text,
    provider_refresh_token text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text NOT NULL,
    auth_code_issued_at timestamp with time zone
);


ALTER TABLE auth.flow_state OWNER TO supabase_auth_admin;

--
-- Name: TABLE flow_state; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.flow_state IS 'stores metadata for pkce logins';


--
-- Name: identities; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.identities (
    provider_id text NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE auth.identities OWNER TO supabase_auth_admin;

--
-- Name: TABLE identities; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.identities IS 'Auth: Stores identities associated to a user.';


--
-- Name: COLUMN identities.email; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.identities.email IS 'Auth: Email is a generated column that references the optional email property in the identity_data';


--
-- Name: instances; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.instances (
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);


ALTER TABLE auth.instances OWNER TO supabase_auth_admin;

--
-- Name: TABLE instances; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.instances IS 'Auth: Manages users across multiple sites.';


--
-- Name: mfa_amr_claims; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_amr_claims (
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text NOT NULL,
    id uuid NOT NULL
);


ALTER TABLE auth.mfa_amr_claims OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_amr_claims; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_amr_claims IS 'auth: stores authenticator method reference claims for multi factor authentication';


--
-- Name: mfa_challenges; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_challenges (
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text,
    web_authn_session_data jsonb
);


ALTER TABLE auth.mfa_challenges OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_challenges; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_challenges IS 'auth: stores metadata about challenge requests made';


--
-- Name: mfa_factors; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_factors (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text,
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text,
    phone text,
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid
);


ALTER TABLE auth.mfa_factors OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_factors; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_factors IS 'auth: stores metadata about factors';


--
-- Name: oauth_authorizations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_authorizations (
    id uuid NOT NULL,
    authorization_id text NOT NULL,
    client_id uuid NOT NULL,
    user_id uuid,
    redirect_uri text NOT NULL,
    scope text NOT NULL,
    state text,
    resource text,
    code_challenge text,
    code_challenge_method auth.code_challenge_method,
    response_type auth.oauth_response_type DEFAULT 'code'::auth.oauth_response_type NOT NULL,
    status auth.oauth_authorization_status DEFAULT 'pending'::auth.oauth_authorization_status NOT NULL,
    authorization_code text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone DEFAULT (now() + '00:03:00'::interval) NOT NULL,
    approved_at timestamp with time zone,
    CONSTRAINT oauth_authorizations_authorization_code_length CHECK ((char_length(authorization_code) <= 255)),
    CONSTRAINT oauth_authorizations_code_challenge_length CHECK ((char_length(code_challenge) <= 128)),
    CONSTRAINT oauth_authorizations_expires_at_future CHECK ((expires_at > created_at)),
    CONSTRAINT oauth_authorizations_redirect_uri_length CHECK ((char_length(redirect_uri) <= 2048)),
    CONSTRAINT oauth_authorizations_resource_length CHECK ((char_length(resource) <= 2048)),
    CONSTRAINT oauth_authorizations_scope_length CHECK ((char_length(scope) <= 4096)),
    CONSTRAINT oauth_authorizations_state_length CHECK ((char_length(state) <= 4096))
);


ALTER TABLE auth.oauth_authorizations OWNER TO supabase_auth_admin;

--
-- Name: oauth_clients; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_clients (
    id uuid NOT NULL,
    client_secret_hash text,
    registration_type auth.oauth_registration_type NOT NULL,
    redirect_uris text NOT NULL,
    grant_types text NOT NULL,
    client_name text,
    client_uri text,
    logo_uri text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    client_type auth.oauth_client_type DEFAULT 'confidential'::auth.oauth_client_type NOT NULL,
    CONSTRAINT oauth_clients_client_name_length CHECK ((char_length(client_name) <= 1024)),
    CONSTRAINT oauth_clients_client_uri_length CHECK ((char_length(client_uri) <= 2048)),
    CONSTRAINT oauth_clients_logo_uri_length CHECK ((char_length(logo_uri) <= 2048))
);


ALTER TABLE auth.oauth_clients OWNER TO supabase_auth_admin;

--
-- Name: oauth_consents; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_consents (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid NOT NULL,
    scopes text NOT NULL,
    granted_at timestamp with time zone DEFAULT now() NOT NULL,
    revoked_at timestamp with time zone,
    CONSTRAINT oauth_consents_revoked_after_granted CHECK (((revoked_at IS NULL) OR (revoked_at >= granted_at))),
    CONSTRAINT oauth_consents_scopes_length CHECK ((char_length(scopes) <= 2048)),
    CONSTRAINT oauth_consents_scopes_not_empty CHECK ((char_length(TRIM(BOTH FROM scopes)) > 0))
);


ALTER TABLE auth.oauth_consents OWNER TO supabase_auth_admin;

--
-- Name: one_time_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.one_time_tokens (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text NOT NULL,
    relates_to text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT one_time_tokens_token_hash_check CHECK ((char_length(token_hash) > 0))
);


ALTER TABLE auth.one_time_tokens OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL,
    token character varying(255),
    user_id character varying(255),
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255),
    session_id uuid
);


ALTER TABLE auth.refresh_tokens OWNER TO supabase_auth_admin;

--
-- Name: TABLE refresh_tokens; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.refresh_tokens IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE; Schema: auth; Owner: supabase_auth_admin
--

CREATE SEQUENCE auth.refresh_tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE auth.refresh_tokens_id_seq OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: auth; Owner: supabase_auth_admin
--

ALTER SEQUENCE auth.refresh_tokens_id_seq OWNED BY auth.refresh_tokens.id;


--
-- Name: saml_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_providers (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text NOT NULL,
    metadata_xml text NOT NULL,
    metadata_url text,
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text,
    CONSTRAINT "entity_id not empty" CHECK ((char_length(entity_id) > 0)),
    CONSTRAINT "metadata_url not empty" CHECK (((metadata_url = NULL::text) OR (char_length(metadata_url) > 0))),
    CONSTRAINT "metadata_xml not empty" CHECK ((char_length(metadata_xml) > 0))
);


ALTER TABLE auth.saml_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_providers IS 'Auth: Manages SAML Identity Provider connections.';


--
-- Name: saml_relay_states; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_relay_states (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text NOT NULL,
    for_email text,
    redirect_to text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT "request_id not empty" CHECK ((char_length(request_id) > 0))
);


ALTER TABLE auth.saml_relay_states OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_relay_states; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_relay_states IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';


--
-- Name: schema_migrations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.schema_migrations (
    version character varying(255) NOT NULL
);


ALTER TABLE auth.schema_migrations OWNER TO supabase_auth_admin;

--
-- Name: TABLE schema_migrations; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.schema_migrations IS 'Auth: Manages updates to the auth system.';


--
-- Name: sessions; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sessions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text,
    ip inet,
    tag text,
    oauth_client_id uuid
);


ALTER TABLE auth.sessions OWNER TO supabase_auth_admin;

--
-- Name: TABLE sessions; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sessions IS 'Auth: Stores session data associated to a user.';


--
-- Name: COLUMN sessions.not_after; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sessions.not_after IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';


--
-- Name: sso_domains; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_domains (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "domain not empty" CHECK ((char_length(domain) > 0))
);


ALTER TABLE auth.sso_domains OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_domains; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_domains IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';


--
-- Name: sso_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_providers (
    id uuid NOT NULL,
    resource_id text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    disabled boolean,
    CONSTRAINT "resource_id not empty" CHECK (((resource_id = NULL::text) OR (char_length(resource_id) > 0)))
);


ALTER TABLE auth.sso_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_providers IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';


--
-- Name: COLUMN sso_providers.resource_id; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sso_providers.resource_id IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';


--
-- Name: users; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.users (
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255),
    role character varying(255),
    email character varying(255),
    encrypted_password character varying(255),
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255),
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255),
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255),
    email_change character varying(255),
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text DEFAULT ''::character varying,
    phone_change_token character varying(255) DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean DEFAULT false NOT NULL,
    deleted_at timestamp with time zone,
    is_anonymous boolean DEFAULT false NOT NULL,
    CONSTRAINT users_email_change_confirm_status_check CHECK (((email_change_confirm_status >= 0) AND (email_change_confirm_status <= 2)))
);


ALTER TABLE auth.users OWNER TO supabase_auth_admin;

--
-- Name: TABLE users; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.users IS 'Auth: Stores user login data within a secure schema.';


--
-- Name: COLUMN users.is_sso_user; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.users.is_sso_user IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';


--
-- Name: account_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.account_users (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    user_id uuid NOT NULL,
    role character varying NOT NULL,
    joined_at timestamp without time zone DEFAULT now(),
    invited_by uuid,
    invitation_accepted_at timestamp without time zone,
    is_active boolean DEFAULT true,
    deactivated_at timestamp without time zone,
    deactivated_by uuid,
    deactivation_reason text,
    role_changed_at timestamp without time zone,
    role_changed_by uuid,
    previous_role character varying,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid,
    CONSTRAINT account_users_role_check CHECK (((role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying, 'member'::character varying])::text[])))
);


ALTER TABLE public.account_users OWNER TO postgres;

--
-- Name: TABLE account_users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.account_users IS 'Account membership with roles';


--
-- Name: COLUMN account_users.invited_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.invited_by IS 'User who sent the invitation that led to this membership';


--
-- Name: COLUMN account_users.invitation_accepted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.invitation_accepted_at IS 'When the invitation was accepted and membership created';


--
-- Name: COLUMN account_users.is_active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.is_active IS 'Whether this membership is currently active (false = deactivated)';


--
-- Name: COLUMN account_users.deactivated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.deactivated_at IS 'When this membership was deactivated';


--
-- Name: COLUMN account_users.deactivated_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.deactivated_by IS 'User who deactivated this membership';


--
-- Name: COLUMN account_users.deactivation_reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.deactivation_reason IS 'Reason for deactivating this membership';


--
-- Name: COLUMN account_users.role_changed_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.role_changed_at IS 'When the role was last changed';


--
-- Name: COLUMN account_users.role_changed_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.role_changed_by IS 'User who changed the role';


--
-- Name: COLUMN account_users.previous_role; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.account_users.previous_role IS 'Previous role before the last role change';


--
-- Name: accounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.accounts (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    name character varying NOT NULL,
    slug character varying,
    account_type character varying NOT NULL,
    current_plan_id uuid,
    subscription_tier character varying DEFAULT 'free'::character varying,
    subscription_status character varying DEFAULT 'active'::character varying,
    subscription_start_date timestamp without time zone,
    subscription_end_date timestamp without time zone,
    trial_end_date timestamp without time zone,
    usage_reset_date timestamp without time zone,
    billing_email character varying,
    billing_address jsonb,
    stripe_customer_id character varying,
    max_users integer DEFAULT 1,
    max_projects integer DEFAULT 5,
    max_datasets integer DEFAULT 100,
    max_monthly_ai_requests integer DEFAULT 100,
    max_storage_mb integer DEFAULT 1000,
    current_user_count integer DEFAULT 0,
    current_project_count integer DEFAULT 0,
    current_dataset_count integer DEFAULT 0,
    current_monthly_ai_requests integer DEFAULT 0,
    current_storage_mb integer DEFAULT 0,
    is_verified boolean DEFAULT false,
    allow_trial boolean DEFAULT true,
    has_used_trial boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT accounts_account_type_check CHECK (((account_type)::text = ANY ((ARRAY['individual'::character varying, 'organization'::character varying])::text[]))),
    CONSTRAINT accounts_subscription_status_check CHECK (((subscription_status)::text = ANY ((ARRAY['active'::character varying, 'suspended'::character varying, 'cancelled'::character varying, 'trialing'::character varying, 'past_due'::character varying])::text[]))),
    CONSTRAINT accounts_subscription_tier_check CHECK (((subscription_tier)::text = ANY ((ARRAY['free'::character varying, 'pro'::character varying, 'enterprise'::character varying, 'custom'::character varying])::text[]))),
    CONSTRAINT chk_current_dataset_count CHECK ((current_dataset_count >= 0)),
    CONSTRAINT chk_current_monthly_ai_requests CHECK ((current_monthly_ai_requests >= 0)),
    CONSTRAINT chk_current_project_count CHECK ((current_project_count >= 0)),
    CONSTRAINT chk_current_storage_mb CHECK ((current_storage_mb >= 0)),
    CONSTRAINT chk_current_user_count CHECK ((current_user_count >= 0))
);


ALTER TABLE public.accounts OWNER TO postgres;

--
-- Name: TABLE accounts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.accounts IS 'Multi-tenant root - all resources belong to an account';


--
-- Name: COLUMN accounts.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.accounts.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN accounts.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.accounts.deleted_by IS 'User who soft deleted this account';


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    email character varying NOT NULL,
    full_name character varying,
    avatar_url character varying,
    is_active boolean DEFAULT true,
    last_login_at timestamp without time zone,
    preferences jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    notification_settings jsonb DEFAULT '{"team_updates": true, "usage_alerts": true, "billing_alerts": true, "product_updates": false, "security_alerts": true, "marketing_emails": false, "invitation_alerts": true, "email_notifications": true}'::jsonb,
    last_seen_at timestamp without time zone,
    is_email_verified boolean DEFAULT false,
    email_verification_token character varying,
    email_verification_sent_at timestamp without time zone,
    password_reset_token character varying,
    password_reset_expires timestamp without time zone,
    password_changed_at timestamp without time zone,
    failed_login_attempts integer DEFAULT 0,
    last_failed_login_at timestamp without time zone,
    account_locked_until timestamp without time zone,
    timezone character varying DEFAULT 'UTC'::character varying,
    locale character varying DEFAULT 'en-US'::character varying,
    onboarding_completed boolean DEFAULT false,
    onboarding_step character varying,
    onboarding_completed_at timestamp without time zone,
    created_by uuid,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.users IS 'User profiles extending Supabase auth.users';


--
-- Name: COLUMN users.preferences; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.preferences IS 'User-specific preferences and settings (theme, language, display options, etc.)';


--
-- Name: COLUMN users.notification_settings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.notification_settings IS 'User notification preferences for email, in-app, and push notifications';


--
-- Name: COLUMN users.last_seen_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_seen_at IS 'Timestamp of last user activity (updated on API requests)';


--
-- Name: COLUMN users.is_email_verified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.is_email_verified IS 'Whether user has verified their email address';


--
-- Name: COLUMN users.email_verification_token; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email_verification_token IS 'Token for email verification (one-time use)';


--
-- Name: COLUMN users.email_verification_sent_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email_verification_sent_at IS 'When verification email was last sent';


--
-- Name: COLUMN users.password_reset_token; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password_reset_token IS 'Token for password reset (one-time use, expires in 1 hour)';


--
-- Name: COLUMN users.password_reset_expires; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password_reset_expires IS 'Expiry timestamp for password reset token';


--
-- Name: COLUMN users.password_changed_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password_changed_at IS 'Timestamp of last password change';


--
-- Name: COLUMN users.failed_login_attempts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.failed_login_attempts IS 'Number of consecutive failed login attempts';


--
-- Name: COLUMN users.last_failed_login_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_failed_login_at IS 'Timestamp of last failed login attempt';


--
-- Name: COLUMN users.account_locked_until; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.account_locked_until IS 'Timestamp until which account is locked (NULL = not locked)';


--
-- Name: COLUMN users.timezone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.timezone IS 'User timezone for date/time display (IANA timezone string)';


--
-- Name: COLUMN users.locale; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.locale IS 'User locale for internationalization (e.g., en-US, fr-FR)';


--
-- Name: COLUMN users.onboarding_completed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.onboarding_completed IS 'Whether user has completed onboarding flow';


--
-- Name: COLUMN users.onboarding_step; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.onboarding_step IS 'Current step in onboarding flow';


--
-- Name: COLUMN users.onboarding_completed_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.onboarding_completed_at IS 'When user completed onboarding';


--
-- Name: COLUMN users.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN users.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.deleted_by IS 'User who soft deleted this user';


--
-- Name: account_user_role_changes; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.account_user_role_changes AS
 SELECT au.id,
    au.account_id,
    au.user_id,
    au.previous_role,
    au.role AS "current_role",
    au.role_changed_at,
    au.role_changed_by,
    a.name AS account_name,
    u.email AS user_email,
    u.full_name AS user_name,
    changer.full_name AS changed_by_name
   FROM (((public.account_users au
     JOIN public.accounts a ON ((au.account_id = a.id)))
     JOIN public.users u ON ((au.user_id = u.id)))
     LEFT JOIN public.users changer ON ((au.role_changed_by = changer.id)))
  WHERE ((au.role_changed_at IS NOT NULL) AND (au.is_active = true))
  ORDER BY au.role_changed_at DESC;


ALTER VIEW public.account_user_role_changes OWNER TO postgres;

--
-- Name: accounts_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.accounts_active AS
 SELECT id,
    name,
    slug,
    account_type,
    current_plan_id,
    subscription_tier,
    subscription_status,
    subscription_start_date,
    subscription_end_date,
    trial_end_date,
    usage_reset_date,
    billing_email,
    billing_address,
    stripe_customer_id,
    max_users,
    max_projects,
    max_datasets,
    max_monthly_ai_requests,
    max_storage_mb,
    current_user_count,
    current_project_count,
    current_dataset_count,
    current_monthly_ai_requests,
    current_storage_mb,
    is_verified,
    allow_trial,
    has_used_trial,
    created_at,
    updated_at,
    created_by,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.accounts
  WHERE (deleted_at IS NULL);


ALTER VIEW public.accounts_active OWNER TO postgres;

--
-- Name: api_tokens; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.api_tokens (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    user_id uuid NOT NULL,
    name character varying NOT NULL,
    description text,
    token_hash character varying NOT NULL,
    prefix character varying NOT NULL,
    scopes jsonb DEFAULT '[]'::jsonb,
    last_used_at timestamp without time zone,
    usage_count integer DEFAULT 0,
    last_used_ip character varying,
    last_used_user_agent text,
    expires_at timestamp without time zone,
    is_active boolean DEFAULT true,
    revoked_at timestamp without time zone,
    revoked_by uuid,
    revoke_reason text,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid
);


ALTER TABLE public.api_tokens OWNER TO postgres;

--
-- Name: TABLE api_tokens; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.api_tokens IS 'API tokens for programmatic access with secure hashing and scope-based permissions';


--
-- Name: COLUMN api_tokens.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.name IS 'User-friendly name for the token (e.g., "Production API", "CI/CD Pipeline")';


--
-- Name: COLUMN api_tokens.token_hash; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.token_hash IS 'SHA-256 hash of the actual token - never store plaintext tokens';


--
-- Name: COLUMN api_tokens.prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.prefix IS 'First 8 characters of token for display purposes (e.g., "uroq_1234")';


--
-- Name: COLUMN api_tokens.scopes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.scopes IS 'Array of permission scopes (e.g., ["read:datasets", "write:projects", "admin:all"])';


--
-- Name: COLUMN api_tokens.last_used_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.last_used_at IS 'Timestamp of last successful authentication with this token';


--
-- Name: COLUMN api_tokens.usage_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.usage_count IS 'Number of times this token has been used for authentication';


--
-- Name: COLUMN api_tokens.last_used_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.last_used_ip IS 'IP address from which token was last used';


--
-- Name: COLUMN api_tokens.last_used_user_agent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.last_used_user_agent IS 'User agent from which token was last used';


--
-- Name: COLUMN api_tokens.expires_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.expires_at IS 'Optional expiry timestamp - NULL means no expiry';


--
-- Name: COLUMN api_tokens.is_active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.is_active IS 'Whether token is active (false = revoked)';


--
-- Name: COLUMN api_tokens.revoked_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.revoked_at IS 'Timestamp when token was revoked';


--
-- Name: COLUMN api_tokens.revoked_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.revoked_by IS 'User who revoked the token';


--
-- Name: COLUMN api_tokens.revoke_reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.api_tokens.revoke_reason IS 'Reason for token revocation';


--
-- Name: audit_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.audit_logs (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    dataset_id uuid,
    workspace_id uuid,
    change_type character varying NOT NULL,
    entity_type character varying NOT NULL,
    entity_id uuid,
    field_name character varying,
    old_value jsonb,
    new_value jsonb,
    changed_by uuid,
    changed_at timestamp without time zone DEFAULT now(),
    committed_in_sha character varying,
    CONSTRAINT audit_logs_change_type_check CHECK (((change_type)::text = ANY ((ARRAY['created'::character varying, 'updated'::character varying, 'deleted'::character varying])::text[]))),
    CONSTRAINT audit_logs_entity_type_check CHECK (((entity_type)::text = ANY ((ARRAY['dataset'::character varying, 'column'::character varying, 'lineage'::character varying])::text[])))
);


ALTER TABLE public.audit_logs OWNER TO postgres;

--
-- Name: columns; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.columns (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    dataset_id uuid,
    fqn character varying NOT NULL,
    name character varying NOT NULL,
    data_type character varying NOT NULL,
    description text,
    business_name character varying,
    is_primary_key boolean DEFAULT false,
    is_foreign_key boolean DEFAULT false,
    is_nullable boolean DEFAULT true,
    default_value text,
    reference_column_id uuid,
    reference_type character varying,
    reference_description text,
    transformation_logic text,
    ai_confidence_score integer,
    "position" integer,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    ai_suggestions jsonb,
    last_ai_enhancement timestamp without time zone,
    custom_metadata jsonb,
    created_by uuid,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT columns_ai_confidence_score_check CHECK (((ai_confidence_score >= 0) AND (ai_confidence_score <= 100))),
    CONSTRAINT columns_reference_type_check CHECK (((reference_type)::text = ANY ((ARRAY['FK'::character varying, 'BusinessKey'::character varying, 'NaturalKey'::character varying])::text[])))
);


ALTER TABLE public.columns OWNER TO postgres;

--
-- Name: TABLE columns; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.columns IS 'Columns (formerly node_items) - dataset fields';


--
-- Name: COLUMN columns.ai_suggestions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.columns.ai_suggestions IS 'Stores AI-generated suggestions for business name, description, etc.';


--
-- Name: COLUMN columns.last_ai_enhancement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.columns.last_ai_enhancement IS 'Timestamp of the last AI enhancement operation on this column';


--
-- Name: COLUMN columns.custom_metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.columns.custom_metadata IS 'Custom user-defined metadata in key-value format';


--
-- Name: COLUMN columns.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.columns.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN columns.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.columns.deleted_by IS 'User who soft deleted this column';


--
-- Name: columns_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.columns_active AS
 SELECT id,
    dataset_id,
    fqn,
    name,
    data_type,
    description,
    business_name,
    is_primary_key,
    is_foreign_key,
    is_nullable,
    default_value,
    reference_column_id,
    reference_type,
    reference_description,
    transformation_logic,
    ai_confidence_score,
    "position",
    created_at,
    updated_at,
    ai_suggestions,
    last_ai_enhancement,
    custom_metadata,
    created_by,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.columns
  WHERE (deleted_at IS NULL);


ALTER VIEW public.columns_active OWNER TO postgres;

--
-- Name: configurations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.configurations (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    workspace_id uuid,
    name character varying NOT NULL,
    type character varying NOT NULL,
    config_json jsonb NOT NULL,
    is_active boolean DEFAULT true,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT configurations_type_check CHECK (((type)::text = ANY ((ARRAY['cluster'::character varying, 'job'::character varying, 'notebook'::character varying, 'connection'::character varying])::text[])))
);


ALTER TABLE public.configurations OWNER TO postgres;

--
-- Name: COLUMN configurations.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.configurations.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN configurations.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.configurations.deleted_by IS 'User who soft deleted this configuration';


--
-- Name: configurations_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.configurations_active AS
 SELECT id,
    workspace_id,
    name,
    type,
    config_json,
    is_active,
    created_by,
    created_at,
    updated_at,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.configurations
  WHERE (deleted_at IS NULL);


ALTER VIEW public.configurations_active OWNER TO postgres;

--
-- Name: connection_metadata_cache; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.connection_metadata_cache (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    connection_id uuid NOT NULL,
    metadata_type character varying NOT NULL,
    metadata jsonb NOT NULL,
    cached_at timestamp without time zone DEFAULT now(),
    expires_at timestamp without time zone,
    is_stale boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    CONSTRAINT connection_metadata_cache_metadata_type_check CHECK (((metadata_type)::text = ANY ((ARRAY['schema'::character varying, 'table'::character varying, 'column'::character varying, 'index'::character varying, 'constraint'::character varying])::text[])))
);


ALTER TABLE public.connection_metadata_cache OWNER TO postgres;

--
-- Name: TABLE connection_metadata_cache; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.connection_metadata_cache IS 'Cached metadata from connection sources (schemas, tables, columns)';


--
-- Name: COLUMN connection_metadata_cache.metadata_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connection_metadata_cache.metadata_type IS 'Type of cached metadata: schema, table, column, index, constraint';


--
-- Name: COLUMN connection_metadata_cache.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connection_metadata_cache.metadata IS 'Cached metadata content as JSON';


--
-- Name: COLUMN connection_metadata_cache.is_stale; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connection_metadata_cache.is_stale IS 'Flag indicating cache needs refresh';


--
-- Name: connections; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.connections (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    name character varying NOT NULL,
    description text,
    connection_type character varying NOT NULL,
    configuration jsonb NOT NULL,
    is_active boolean DEFAULT true,
    last_tested_at timestamp without time zone,
    test_status character varying,
    test_error_message text,
    import_settings jsonb DEFAULT '{}'::jsonb,
    last_import_at timestamp without time zone,
    owner_id uuid,
    visibility character varying DEFAULT 'private'::character varying NOT NULL,
    is_locked boolean DEFAULT false,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    catalog character varying,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT connections_connection_type_check CHECK (((connection_type)::text = ANY ((ARRAY['MSSQL'::character varying, 'Databricks'::character varying, 'Snowflake'::character varying, 'Salesforce'::character varying, 'Workday'::character varying, 'ServiceNow'::character varying, 'FileSystem'::character varying, 'REST'::character varying])::text[]))),
    CONSTRAINT connections_test_status_check CHECK (((test_status)::text = ANY ((ARRAY['success'::character varying, 'failed'::character varying, 'pending'::character varying, 'untested'::character varying])::text[]))),
    CONSTRAINT connections_visibility_check CHECK (((visibility)::text = ANY ((ARRAY['public'::character varying, 'private'::character varying, 'locked'::character varying])::text[])))
);


ALTER TABLE public.connections OWNER TO postgres;

--
-- Name: TABLE connections; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.connections IS 'Data source connections with encryption and multi-tenant isolation';


--
-- Name: COLUMN connections.account_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.account_id IS 'Multi-tenant isolation - all connections belong to an account';


--
-- Name: COLUMN connections.connection_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.connection_type IS 'Vendor type: MSSQL, Databricks, Snowflake, Salesforce, Workday, ServiceNow, FileSystem, REST';


--
-- Name: COLUMN connections.configuration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.configuration IS 'Encrypted connection configuration (credentials, endpoints, etc)';


--
-- Name: COLUMN connections.test_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.test_status IS 'Last test result: success, failed, pending, untested';


--
-- Name: COLUMN connections.import_settings; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.import_settings IS 'Settings for metadata import operations';


--
-- Name: COLUMN connections.catalog; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.catalog IS 'Catalog name (e.g., Unity Catalog in Databricks)';


--
-- Name: COLUMN connections.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN connections.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.connections.deleted_by IS 'User who soft deleted this connection';


--
-- Name: connections_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.connections_active AS
 SELECT id,
    account_id,
    name,
    description,
    connection_type,
    configuration,
    is_active,
    last_tested_at,
    test_status,
    test_error_message,
    import_settings,
    last_import_at,
    owner_id,
    visibility,
    is_locked,
    created_by,
    created_at,
    updated_at,
    catalog,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.connections
  WHERE (deleted_at IS NULL);


ALTER VIEW public.connections_active OWNER TO postgres;

--
-- Name: datasets; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.datasets (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid,
    name character varying NOT NULL,
    medallion_layer character varying,
    description text,
    metadata jsonb,
    ai_confidence_score integer,
    owner_id uuid,
    visibility character varying DEFAULT 'private'::character varying NOT NULL,
    is_locked boolean DEFAULT false,
    source_control_file_path character varying,
    source_control_commit_sha character varying,
    has_uncommitted_changes boolean DEFAULT false,
    last_synced_at timestamp without time zone,
    sync_status character varying DEFAULT 'synced'::character varying,
    sync_error_message text,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    dataset_type character varying(50),
    connection_id uuid,
    schema character varying,
    fully_qualified_name character varying,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT datasets_ai_confidence_score_check CHECK (((ai_confidence_score >= 0) AND (ai_confidence_score <= 100))),
    CONSTRAINT datasets_dataset_type_check CHECK (((dataset_type)::text = ANY ((ARRAY['Table'::character varying, 'View'::character varying, 'Dimension'::character varying, 'Fact'::character varying, 'Hub'::character varying, 'Link'::character varying, 'Satellite'::character varying, 'LinkSatellite'::character varying, 'Point In Time'::character varying, 'Bridge'::character varying, 'Reference'::character varying, 'Hierarchy Link'::character varying, 'Same as Link'::character varying, 'Reference Satellite'::character varying, 'File'::character varying])::text[]))),
    CONSTRAINT datasets_medallion_layer_check CHECK (((medallion_layer)::text = ANY ((ARRAY['Source'::character varying, 'Raw'::character varying, 'Bronze'::character varying, 'Silver'::character varying, 'Gold'::character varying])::text[]))),
    CONSTRAINT datasets_sync_status_check CHECK (((sync_status)::text = ANY ((ARRAY['synced'::character varying, 'pending'::character varying, 'conflict'::character varying, 'error'::character varying])::text[]))),
    CONSTRAINT datasets_visibility_check CHECK (((visibility)::text = ANY ((ARRAY['public'::character varying, 'private'::character varying, 'locked'::character varying])::text[])))
);


ALTER TABLE public.datasets OWNER TO postgres;

--
-- Name: TABLE datasets; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.datasets IS 'Datasets no longer directly reference diagrams; use diagram_datasets for diagram membership';


--
-- Name: COLUMN datasets.account_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.account_id IS 'Account/Company ID for multi-tenant isolation';


--
-- Name: COLUMN datasets.medallion_layer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.medallion_layer IS 'Data medallion architecture layer: Source, Raw, Bronze, Silver, Gold';


--
-- Name: COLUMN datasets.owner_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.owner_id IS 'User ID of the dataset owner';


--
-- Name: COLUMN datasets.visibility; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.visibility IS 'Access control: public (all account members), private (owner + admins), locked (read-only except owner + admins)';


--
-- Name: COLUMN datasets.is_locked; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.is_locked IS 'Whether the dataset is locked for editing';


--
-- Name: COLUMN datasets.dataset_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.dataset_type IS 'Type of dataset: Table, View, Dimension, Fact, Hub, Link, Satellite, LinkSatellite, Point In Time, Bridge, Reference, Hierarchy Link, Same as Link, Reference Satellite, File';


--
-- Name: COLUMN datasets.connection_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.connection_id IS 'Reference to the connection this dataset belongs to';


--
-- Name: COLUMN datasets.schema; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.schema IS 'Schema name within the catalog';


--
-- Name: COLUMN datasets.fully_qualified_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.fully_qualified_name IS 'Fully qualified name: connection.catalog.schema.name (auto-generated)';


--
-- Name: COLUMN datasets.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN datasets.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.datasets.deleted_by IS 'User who soft deleted this dataset';


--
-- Name: datasets_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.datasets_active AS
 SELECT id,
    account_id,
    name,
    medallion_layer,
    description,
    metadata,
    ai_confidence_score,
    owner_id,
    visibility,
    is_locked,
    source_control_file_path,
    source_control_commit_sha,
    has_uncommitted_changes,
    last_synced_at,
    sync_status,
    sync_error_message,
    created_by,
    created_at,
    updated_at,
    dataset_type,
    connection_id,
    schema,
    fully_qualified_name,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.datasets
  WHERE (deleted_at IS NULL);


ALTER VIEW public.datasets_active OWNER TO postgres;

--
-- Name: deactivated_account_memberships; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.deactivated_account_memberships AS
 SELECT au.id,
    au.account_id,
    au.user_id,
    au.role,
    au.joined_at,
    au.deactivated_at,
    au.deactivated_by,
    au.deactivation_reason,
    a.name AS account_name,
    u.email AS user_email,
    u.full_name AS user_name,
    deactivator.full_name AS deactivated_by_name,
    (au.deactivated_at - au.joined_at) AS membership_duration
   FROM (((public.account_users au
     JOIN public.accounts a ON ((au.account_id = a.id)))
     JOIN public.users u ON ((au.user_id = u.id)))
     LEFT JOIN public.users deactivator ON ((au.deactivated_by = deactivator.id)))
  WHERE (au.is_active = false)
  ORDER BY au.deactivated_at DESC;


ALTER VIEW public.deactivated_account_memberships OWNER TO postgres;

--
-- Name: diagram_datasets; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.diagram_datasets (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    diagram_id uuid NOT NULL,
    dataset_id uuid NOT NULL,
    location jsonb,
    is_expanded boolean DEFAULT false,
    is_highlighted boolean DEFAULT false,
    z_index integer DEFAULT 0,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    notes text,
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid
);


ALTER TABLE public.diagram_datasets OWNER TO postgres;

--
-- Name: TABLE diagram_datasets; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.diagram_datasets IS 'Many-to-many mapping between diagrams and datasets (replaces workspace_diagram_id on datasets)';


--
-- Name: COLUMN diagram_datasets.location; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.location IS 'Dataset location on diagram canvas';


--
-- Name: COLUMN diagram_datasets.is_expanded; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.is_expanded IS 'Whether columns are shown';


--
-- Name: COLUMN diagram_datasets.z_index; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.z_index IS 'Stacking order (higher = on top)';


--
-- Name: COLUMN diagram_datasets.created_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.created_by IS 'User who added the dataset to the diagram';


--
-- Name: COLUMN diagram_datasets.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.created_at IS 'Timestamp when the dataset was added to the diagram';


--
-- Name: COLUMN diagram_datasets.notes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.notes IS 'User notes about this dataset in this diagram';


--
-- Name: COLUMN diagram_datasets.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.updated_at IS 'Timestamp when the mapping was last updated';


--
-- Name: COLUMN diagram_datasets.updated_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagram_datasets.updated_by IS 'User who last updated the mapping';


--
-- Name: diagrams; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.diagrams (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    workspace_id uuid NOT NULL,
    name character varying NOT NULL,
    description text,
    diagram_type character varying DEFAULT 'dataset'::character varying NOT NULL,
    view_mode character varying DEFAULT 'relationships'::character varying NOT NULL,
    viewport jsonb DEFAULT '{"x": 0, "y": 0, "zoom": 1}'::jsonb NOT NULL,
    node_positions jsonb DEFAULT '{}'::jsonb NOT NULL,
    node_expansions jsonb DEFAULT '{}'::jsonb NOT NULL,
    edge_routes jsonb DEFAULT '{}'::jsonb,
    filters jsonb DEFAULT '{}'::jsonb,
    layout_type character varying DEFAULT 'hierarchical'::character varying,
    layout_direction character varying DEFAULT 'LR'::character varying,
    auto_layout boolean DEFAULT false,
    owner_id uuid,
    visibility character varying DEFAULT 'private'::character varying NOT NULL,
    is_template boolean DEFAULT false,
    tags character varying[],
    metadata jsonb DEFAULT '{}'::jsonb,
    version integer DEFAULT 1,
    last_modified_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    CONSTRAINT diagrams_diagram_type_check CHECK (((diagram_type)::text = ANY ((ARRAY['dataset'::character varying, 'business_model'::character varying, 'lineage'::character varying, 'erd'::character varying])::text[]))),
    CONSTRAINT diagrams_layout_direction_check CHECK (((layout_direction)::text = ANY ((ARRAY['LR'::character varying, 'TB'::character varying, 'RL'::character varying, 'BT'::character varying])::text[]))),
    CONSTRAINT diagrams_layout_type_check CHECK (((layout_type)::text = ANY ((ARRAY['hierarchical'::character varying, 'force'::character varying, 'circular'::character varying, 'dagre'::character varying, 'manual'::character varying])::text[]))),
    CONSTRAINT diagrams_view_mode_check CHECK (((view_mode)::text = ANY ((ARRAY['relationships'::character varying, 'lineage'::character varying])::text[]))),
    CONSTRAINT diagrams_visibility_check CHECK (((visibility)::text = ANY ((ARRAY['public'::character varying, 'private'::character varying, 'shared'::character varying])::text[])))
);


ALTER TABLE public.diagrams OWNER TO postgres;

--
-- Name: TABLE diagrams; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.diagrams IS 'Diagrams belong to workspaces via workspace_id; datasets belong to diagrams via diagram_datasets mapping table';


--
-- Name: COLUMN diagrams.diagram_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.diagram_type IS 'Type: dataset | business_model | lineage | erd';


--
-- Name: COLUMN diagrams.view_mode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.view_mode IS 'View mode: relationships | lineage';


--
-- Name: COLUMN diagrams.viewport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.viewport IS 'Canvas viewport: {x, y, zoom}';


--
-- Name: COLUMN diagrams.node_positions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.node_positions IS 'Node positions: {node_id: {x, y}}';


--
-- Name: COLUMN diagrams.node_expansions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.node_expansions IS 'Expansion state: {node_id: boolean}';


--
-- Name: COLUMN diagrams.edge_routes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.edge_routes IS 'Custom routes: {edge_id: {path, controlPoints, ...}}';


--
-- Name: COLUMN diagrams.filters; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.filters IS 'Active filters: {medallionLayers, searchQuery, ...}';


--
-- Name: COLUMN diagrams.layout_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.layout_type IS 'Layout algorithm: hierarchical | force | circular | dagre | manual';


--
-- Name: COLUMN diagrams.is_template; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.diagrams.is_template IS 'Can be used as template for new diagrams';


--
-- Name: diagram_summary; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.diagram_summary AS
 SELECT d.id,
    d.account_id,
    d.workspace_id,
    d.name,
    d.description,
    d.diagram_type,
    d.visibility,
    d.owner_id,
    d.is_template,
    d.created_at,
    d.updated_at,
    count(DISTINCT dd.dataset_id) AS dataset_count,
    array_agg(DISTINCT d.tags) FILTER (WHERE (d.tags IS NOT NULL)) AS all_tags
   FROM (public.diagrams d
     LEFT JOIN public.diagram_datasets dd ON ((dd.diagram_id = d.id)))
  GROUP BY d.id, d.account_id, d.workspace_id, d.name, d.description, d.diagram_type, d.visibility, d.owner_id, d.is_template, d.created_at, d.updated_at;


ALTER VIEW public.diagram_summary OWNER TO postgres;

--
-- Name: VIEW diagram_summary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON VIEW public.diagram_summary IS 'Summary view of diagrams with dataset counts';


--
-- Name: environments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.environments (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid,
    project_id uuid,
    workspace_id uuid,
    name character varying NOT NULL,
    description text,
    target_platform character varying,
    target_catalog character varying,
    target_schema character varying,
    platform_url character varying,
    platform_config jsonb,
    auto_deploy boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT environments_target_platform_check CHECK (((target_platform)::text = ANY ((ARRAY['databricks'::character varying, 'snowflake'::character varying, 'bigquery'::character varying, 'redshift'::character varying, 'synapse'::character varying, 'other'::character varying])::text[])))
);


ALTER TABLE public.environments OWNER TO postgres;

--
-- Name: COLUMN environments.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.environments.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN environments.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.environments.deleted_by IS 'User who soft deleted this environment';


--
-- Name: environments_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.environments_active AS
 SELECT id,
    account_id,
    project_id,
    workspace_id,
    name,
    description,
    target_platform,
    target_catalog,
    target_schema,
    platform_url,
    platform_config,
    auto_deploy,
    created_at,
    updated_at,
    created_by,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.environments
  WHERE (deleted_at IS NULL);


ALTER VIEW public.environments_active OWNER TO postgres;

--
-- Name: invitations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invitations (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid,
    email character varying NOT NULL,
    role character varying NOT NULL,
    invited_by uuid,
    expires_at timestamp without time zone NOT NULL,
    accepted_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT now(),
    token character varying DEFAULT encode(extensions.gen_random_bytes(32), 'hex'::text) NOT NULL,
    invited_by_name character varying,
    invited_by_email character varying,
    status character varying DEFAULT 'pending'::character varying,
    accepted_by uuid,
    message text,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_by uuid,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT invitations_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'accepted'::character varying, 'expired'::character varying, 'revoked'::character varying])::text[])))
);


ALTER TABLE public.invitations OWNER TO postgres;

--
-- Name: TABLE invitations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.invitations IS 'Team invitation management with secure tokens and expiry tracking';


--
-- Name: COLUMN invitations.token; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.token IS 'Secure random token for invitation acceptance (64-character hex string)';


--
-- Name: COLUMN invitations.invited_by_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.invited_by_name IS 'Cached name of inviter for display purposes';


--
-- Name: COLUMN invitations.invited_by_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.invited_by_email IS 'Cached email of inviter for display purposes';


--
-- Name: COLUMN invitations.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.status IS 'Invitation status: pending (awaiting acceptance), accepted (user joined), expired (past expiry date), revoked (cancelled by admin)';


--
-- Name: COLUMN invitations.message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.message IS 'Optional personal message from inviter to invitee';


--
-- Name: COLUMN invitations.metadata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.metadata IS 'Extensible JSONB field for additional invitation context';


--
-- Name: COLUMN invitations.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN invitations.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invitations.deleted_by IS 'User who soft deleted this invitation';


--
-- Name: expired_invitations; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.expired_invitations AS
 SELECT i.id,
    i.account_id,
    i.email,
    i.role,
    i.invited_by,
    i.expires_at,
    i.accepted_at,
    i.created_at,
    i.token,
    i.invited_by_name,
    i.invited_by_email,
    i.status,
    i.accepted_by,
    i.message,
    i.metadata,
    a.name AS account_name,
    (now() - (i.expires_at)::timestamp with time zone) AS expired_for
   FROM (public.invitations i
     JOIN public.accounts a ON ((i.account_id = a.id)))
  WHERE ((((i.status)::text = 'pending'::text) AND (i.expires_at < now())) OR ((i.status)::text = 'expired'::text))
  ORDER BY i.expires_at DESC;


ALTER VIEW public.expired_invitations OWNER TO postgres;

--
-- Name: inactive_users; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.inactive_users AS
 SELECT id,
    email,
    full_name,
    last_login_at,
    last_seen_at,
    GREATEST(last_login_at, last_seen_at) AS last_activity,
    (now() - (GREATEST(last_login_at, last_seen_at))::timestamp with time zone) AS inactive_duration
   FROM public.users u
  WHERE ((is_active = true) AND ((last_login_at IS NOT NULL) OR (last_seen_at IS NOT NULL)) AND (GREATEST(last_login_at, last_seen_at) < (now() - '90 days'::interval)))
  ORDER BY GREATEST(last_login_at, last_seen_at) DESC;


ALTER VIEW public.inactive_users OWNER TO postgres;

--
-- Name: invitations_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.invitations_active AS
 SELECT id,
    account_id,
    email,
    role,
    invited_by,
    expires_at,
    accepted_at,
    created_at,
    token,
    invited_by_name,
    invited_by_email,
    status,
    accepted_by,
    message,
    metadata,
    created_by,
    updated_at,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.invitations
  WHERE (deleted_at IS NULL);


ALTER VIEW public.invitations_active OWNER TO postgres;

--
-- Name: lineage; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lineage (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    workspace_id uuid,
    downstream_dataset_id uuid,
    downstream_column_id uuid,
    upstream_dataset_id uuid,
    upstream_column_id uuid,
    mapping_type character varying NOT NULL,
    transformation_expression text,
    lineage_type character varying DEFAULT 'direct'::character varying,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    CONSTRAINT lineage_lineage_type_check CHECK (((lineage_type)::text = ANY ((ARRAY['direct'::character varying, 'indirect'::character varying])::text[]))),
    CONSTRAINT lineage_mapping_type_check CHECK (((mapping_type)::text = ANY ((ARRAY['Direct'::character varying, 'Transform'::character varying, 'Derived'::character varying, 'Calculated'::character varying])::text[])))
);


ALTER TABLE public.lineage OWNER TO postgres;

--
-- Name: TABLE lineage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.lineage IS 'Data lineage tracking column-level dependencies';


--
-- Name: locked_user_accounts; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.locked_user_accounts AS
 SELECT id,
    email,
    full_name,
    failed_login_attempts,
    last_failed_login_at,
    account_locked_until,
    ((account_locked_until)::timestamp with time zone - now()) AS time_until_unlock
   FROM public.users u
  WHERE ((account_locked_until IS NOT NULL) AND (account_locked_until > now()))
  ORDER BY account_locked_until;


ALTER VIEW public.locked_user_accounts OWNER TO postgres;

--
-- Name: macros; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.macros (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    name character varying NOT NULL,
    description text,
    code_fragment text NOT NULL,
    language character varying NOT NULL,
    parameters jsonb,
    usage_example text,
    is_public boolean DEFAULT true,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT macros_language_check CHECK (((language)::text = ANY ((ARRAY['SQL'::character varying, 'Python'::character varying, 'Scala'::character varying])::text[])))
);


ALTER TABLE public.macros OWNER TO postgres;

--
-- Name: COLUMN macros.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.macros.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN macros.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.macros.deleted_by IS 'User who soft deleted this macro';


--
-- Name: macros_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.macros_active AS
 SELECT id,
    name,
    description,
    code_fragment,
    language,
    parameters,
    usage_example,
    is_public,
    created_by,
    created_at,
    updated_at,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.macros
  WHERE (deleted_at IS NULL);


ALTER VIEW public.macros_active OWNER TO postgres;

--
-- Name: payments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payments (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    subscription_id uuid,
    stripe_payment_intent_id character varying,
    stripe_charge_id character varying,
    stripe_invoice_id character varying,
    amount numeric(10,2) NOT NULL,
    currency character varying DEFAULT 'usd'::character varying NOT NULL,
    status character varying NOT NULL,
    payment_method character varying,
    last4 character varying,
    brand character varying,
    failure_code character varying,
    failure_message text,
    refund_amount numeric(10,2),
    refund_reason text,
    refunded_at timestamp without time zone,
    processed_at timestamp without time zone DEFAULT now() NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    CONSTRAINT payments_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'succeeded'::character varying, 'failed'::character varying, 'refunded'::character varying, 'partially_refunded'::character varying, 'disputed'::character varying])::text[])))
);


ALTER TABLE public.payments OWNER TO postgres;

--
-- Name: TABLE payments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.payments IS 'Tracks all payment transactions from Stripe';


--
-- Name: project_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.project_users (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    project_id uuid NOT NULL,
    user_id uuid NOT NULL,
    role character varying NOT NULL,
    joined_at timestamp without time zone DEFAULT now(),
    CONSTRAINT project_users_role_check CHECK (((role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying, 'editor'::character varying, 'viewer'::character varying])::text[])))
);


ALTER TABLE public.project_users OWNER TO postgres;

--
-- Name: projects; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.projects (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid,
    name character varying NOT NULL,
    description text,
    project_type character varying,
    configuration jsonb,
    owner_id uuid,
    visibility character varying DEFAULT 'private'::character varying NOT NULL,
    is_locked boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    source_control_provider public.source_control_provider,
    source_control_repo_url text,
    source_control_connection_status public.source_control_connection_status DEFAULT 'not_connected'::public.source_control_connection_status,
    source_control_last_synced_at timestamp with time zone,
    source_control_default_branch text DEFAULT 'main'::text,
    source_control_access_token_encrypted text,
    source_control_refresh_token_encrypted text,
    source_control_token_expires_at timestamp with time zone,
    source_control_username text,
    created_by uuid,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT projects_project_type_check CHECK (((project_type)::text = ANY ((ARRAY['Standard'::character varying, 'DataVault'::character varying, 'Dimensional'::character varying])::text[]))),
    CONSTRAINT projects_visibility_check CHECK (((visibility)::text = ANY ((ARRAY['public'::character varying, 'private'::character varying, 'locked'::character varying])::text[])))
);


ALTER TABLE public.projects OWNER TO postgres;

--
-- Name: TABLE projects; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.projects IS 'Projects for organizing datasets and models';


--
-- Name: COLUMN projects.project_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.project_type IS 'DEPRECATED: Project type field. Projects now support multiple types based on mappings and lineage. Kept for backward compatibility.';


--
-- Name: COLUMN projects.source_control_provider; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_provider IS 'Source control provider for the project repository';


--
-- Name: COLUMN projects.source_control_repo_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_repo_url IS 'URL of the repository connected to this project';


--
-- Name: COLUMN projects.source_control_connection_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_connection_status IS 'Current connection status to the repository';


--
-- Name: COLUMN projects.source_control_last_synced_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_last_synced_at IS 'Last time project was synced with repository';


--
-- Name: COLUMN projects.source_control_default_branch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_default_branch IS 'Default branch for the repository';


--
-- Name: COLUMN projects.source_control_access_token_encrypted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_access_token_encrypted IS 'Encrypted access token for source control provider';


--
-- Name: COLUMN projects.source_control_refresh_token_encrypted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_refresh_token_encrypted IS 'Encrypted refresh token (if supported by provider)';


--
-- Name: COLUMN projects.source_control_token_expires_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_token_expires_at IS 'Expiration timestamp for the access token';


--
-- Name: COLUMN projects.source_control_username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.source_control_username IS 'Username for source control authentication';


--
-- Name: COLUMN projects.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN projects.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.projects.deleted_by IS 'User who soft deleted this project';


--
-- Name: projects_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.projects_active AS
 SELECT id,
    account_id,
    name,
    description,
    project_type,
    configuration,
    owner_id,
    visibility,
    is_locked,
    created_at,
    updated_at,
    source_control_provider,
    source_control_repo_url,
    source_control_connection_status,
    source_control_last_synced_at,
    source_control_default_branch,
    source_control_access_token_encrypted,
    source_control_refresh_token_encrypted,
    source_control_token_expires_at,
    source_control_username,
    created_by,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.projects
  WHERE (deleted_at IS NULL);


ALTER VIEW public.projects_active OWNER TO postgres;

--
-- Name: source_control_commits; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.source_control_commits (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid,
    project_id uuid,
    workspace_id uuid,
    commit_sha character varying NOT NULL,
    commit_message text,
    author character varying,
    committed_at timestamp without time zone,
    source_control_provider character varying DEFAULT 'github'::character varying,
    files_changed jsonb,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    CONSTRAINT source_control_commits_source_control_provider_check CHECK (((source_control_provider)::text = ANY ((ARRAY['github'::character varying, 'gitlab'::character varying, 'bitbucket'::character varying, 'azure'::character varying, 'other'::character varying])::text[])))
);


ALTER TABLE public.source_control_commits OWNER TO postgres;

--
-- Name: subscription_plans; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.subscription_plans (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    name character varying NOT NULL,
    slug character varying NOT NULL,
    tier character varying NOT NULL,
    display_name character varying NOT NULL,
    description text,
    price_monthly numeric(10,2),
    price_yearly numeric(10,2),
    currency character varying DEFAULT 'usd'::character varying,
    stripe_price_id_monthly character varying,
    stripe_price_id_yearly character varying,
    max_users integer,
    max_projects integer,
    max_datasets integer,
    max_monthly_ai_requests integer,
    max_storage_mb integer,
    max_workspaces_per_project integer,
    max_connections integer,
    features jsonb DEFAULT '[]'::jsonb,
    has_git_sync boolean DEFAULT true,
    has_ai_assistance boolean DEFAULT false,
    has_data_vault_accelerator boolean DEFAULT false,
    has_priority_support boolean DEFAULT false,
    has_sso boolean DEFAULT false,
    has_audit_logs boolean DEFAULT false,
    has_api_access boolean DEFAULT false,
    has_white_labeling boolean DEFAULT false,
    trial_days integer DEFAULT 0,
    is_active boolean DEFAULT true,
    is_public boolean DEFAULT true,
    is_recommended boolean DEFAULT false,
    sort_order integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    CONSTRAINT subscription_plans_tier_check CHECK (((tier)::text = ANY ((ARRAY['free'::character varying, 'pro'::character varying, 'enterprise'::character varying, 'custom'::character varying])::text[])))
);


ALTER TABLE public.subscription_plans OWNER TO postgres;

--
-- Name: TABLE subscription_plans; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.subscription_plans IS 'Subscription plan definitions with pricing, limits, and features';


--
-- Name: template_fragments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.template_fragments (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    template_id uuid,
    name character varying NOT NULL,
    injection_point_name character varying NOT NULL,
    jinja_content text NOT NULL,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid
);


ALTER TABLE public.template_fragments OWNER TO postgres;

--
-- Name: templates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.templates (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    name character varying NOT NULL,
    template_type character varying NOT NULL,
    description text,
    jinja_content text NOT NULL,
    is_system boolean DEFAULT false,
    parent_template_id uuid,
    injection_points jsonb,
    variables jsonb,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT templates_template_type_check CHECK (((template_type)::text = ANY ((ARRAY['Full'::character varying, 'Fragment'::character varying])::text[])))
);


ALTER TABLE public.templates OWNER TO postgres;

--
-- Name: COLUMN templates.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.templates.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN templates.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.templates.deleted_by IS 'User who soft deleted this template';


--
-- Name: templates_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.templates_active AS
 SELECT id,
    name,
    template_type,
    description,
    jinja_content,
    is_system,
    parent_template_id,
    injection_points,
    variables,
    created_by,
    created_at,
    updated_at,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.templates
  WHERE (deleted_at IS NULL);


ALTER VIEW public.templates_active OWNER TO postgres;

--
-- Name: unverified_users; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.unverified_users AS
 SELECT id,
    email,
    full_name,
    created_at,
    email_verification_sent_at,
    (now() - (created_at)::timestamp with time zone) AS account_age,
    COALESCE(( SELECT count(*) AS count
           FROM public.account_users
          WHERE (account_users.user_id = u.id)), (0)::bigint) AS account_memberships
   FROM public.users u
  WHERE ((is_email_verified = false) AND (is_active = true))
  ORDER BY created_at DESC;


ALTER VIEW public.unverified_users OWNER TO postgres;

--
-- Name: usage_events; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.usage_events (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid NOT NULL,
    user_id uuid,
    event_type character varying NOT NULL,
    event_category character varying,
    quantity integer DEFAULT 1,
    unit character varying,
    resource_type character varying,
    resource_id uuid,
    metadata jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    CONSTRAINT usage_events_event_category_check CHECK (((event_category)::text = ANY ((ARRAY['ai'::character varying, 'resource'::character varying, 'api'::character varying, 'storage'::character varying, 'team'::character varying])::text[]))),
    CONSTRAINT usage_events_event_type_check CHECK (((event_type)::text = ANY ((ARRAY['ai_request'::character varying, 'dataset_created'::character varying, 'dataset_deleted'::character varying, 'project_created'::character varying, 'project_deleted'::character varying, 'user_invited'::character varying, 'user_added'::character varying, 'user_removed'::character varying, 'storage_used'::character varying, 'storage_freed'::character varying, 'api_call'::character varying, 'workspace_created'::character varying, 'workspace_deleted'::character varying, 'connection_created'::character varying, 'connection_deleted'::character varying])::text[])))
);


ALTER TABLE public.usage_events OWNER TO postgres;

--
-- Name: TABLE usage_events; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.usage_events IS 'Tracks all resource usage events for metering and analytics';


--
-- Name: users_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.users_active AS
 SELECT id,
    email,
    full_name,
    avatar_url,
    is_active,
    last_login_at,
    preferences,
    created_at,
    updated_at,
    notification_settings,
    last_seen_at,
    is_email_verified,
    email_verification_token,
    email_verification_sent_at,
    password_reset_token,
    password_reset_expires,
    password_changed_at,
    failed_login_attempts,
    last_failed_login_at,
    account_locked_until,
    timezone,
    locale,
    onboarding_completed,
    onboarding_step,
    onboarding_completed_at,
    created_by,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.users
  WHERE (deleted_at IS NULL);


ALTER VIEW public.users_active OWNER TO postgres;

--
-- Name: workspace_datasets; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.workspace_datasets (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    workspace_id uuid NOT NULL,
    dataset_id uuid NOT NULL,
    canvas_position jsonb,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid
);


ALTER TABLE public.workspace_datasets OWNER TO postgres;

--
-- Name: COLUMN workspace_datasets.created_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspace_datasets.created_at IS 'Timestamp when the dataset was added to the workspace';


--
-- Name: COLUMN workspace_datasets.created_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspace_datasets.created_by IS 'User who added the dataset to the workspace';


--
-- Name: COLUMN workspace_datasets.updated_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspace_datasets.updated_at IS 'Timestamp when the mapping was last updated';


--
-- Name: COLUMN workspace_datasets.updated_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspace_datasets.updated_by IS 'User who last updated the mapping';


--
-- Name: workspace_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.workspace_users (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    workspace_id uuid NOT NULL,
    user_id uuid NOT NULL,
    role character varying NOT NULL,
    joined_at timestamp without time zone DEFAULT now(),
    CONSTRAINT workspace_users_role_check CHECK (((role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying, 'editor'::character varying, 'viewer'::character varying])::text[])))
);


ALTER TABLE public.workspace_users OWNER TO postgres;

--
-- Name: workspaces; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.workspaces (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    account_id uuid,
    project_id uuid,
    name character varying NOT NULL,
    description text,
    source_control_branch character varying,
    source_control_commit_sha character varying,
    source_control_connection_status character varying,
    last_synced_at timestamp without time zone,
    is_synced boolean DEFAULT false,
    owner_id uuid,
    visibility character varying DEFAULT 'private'::character varying NOT NULL,
    is_locked boolean DEFAULT false,
    settings jsonb DEFAULT '{}'::jsonb,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    deleted_at timestamp without time zone,
    deleted_by uuid,
    CONSTRAINT workspaces_visibility_check CHECK (((visibility)::text = ANY ((ARRAY['public'::character varying, 'private'::character varying, 'locked'::character varying])::text[])))
);


ALTER TABLE public.workspaces OWNER TO postgres;

--
-- Name: TABLE workspaces; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.workspaces IS 'Workspaces map to source control branches';


--
-- Name: COLUMN workspaces.source_control_branch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspaces.source_control_branch IS 'Branch within the project repository that this workspace is connected to';


--
-- Name: COLUMN workspaces.source_control_commit_sha; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspaces.source_control_commit_sha IS 'Current commit SHA for this workspace branch';


--
-- Name: COLUMN workspaces.source_control_connection_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspaces.source_control_connection_status IS 'Workspace-specific connection status (can differ from project)';


--
-- Name: COLUMN workspaces.deleted_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspaces.deleted_at IS 'Soft delete timestamp - NULL means active';


--
-- Name: COLUMN workspaces.deleted_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workspaces.deleted_by IS 'User who soft deleted this workspace';


--
-- Name: workspaces_active; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.workspaces_active AS
 SELECT id,
    account_id,
    project_id,
    name,
    description,
    source_control_branch,
    source_control_commit_sha,
    source_control_connection_status,
    last_synced_at,
    is_synced,
    owner_id,
    visibility,
    is_locked,
    settings,
    created_at,
    updated_at,
    created_by,
    updated_by,
    deleted_at,
    deleted_by
   FROM public.workspaces
  WHERE (deleted_at IS NULL);


ALTER VIEW public.workspaces_active OWNER TO postgres;

--
-- Name: messages; Type: TABLE; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE TABLE realtime.messages (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
)
PARTITION BY RANGE (inserted_at);


ALTER TABLE realtime.messages OWNER TO supabase_realtime_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.schema_migrations (
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone
);


ALTER TABLE realtime.schema_migrations OWNER TO supabase_admin;

--
-- Name: subscription; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.subscription (
    id bigint NOT NULL,
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] DEFAULT '{}'::realtime.user_defined_filter[] NOT NULL,
    claims jsonb NOT NULL,
    claims_role regrole GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED NOT NULL,
    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


ALTER TABLE realtime.subscription OWNER TO supabase_admin;

--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE realtime.subscription ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME realtime.subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: buckets; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets (
    id text NOT NULL,
    name text NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[],
    owner_id text,
    type storage.buckettype DEFAULT 'STANDARD'::storage.buckettype NOT NULL
);


ALTER TABLE storage.buckets OWNER TO supabase_storage_admin;

--
-- Name: COLUMN buckets.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.buckets.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: buckets_analytics; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets_analytics (
    id text NOT NULL,
    type storage.buckettype DEFAULT 'ANALYTICS'::storage.buckettype NOT NULL,
    format text DEFAULT 'ICEBERG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.buckets_analytics OWNER TO supabase_storage_admin;

--
-- Name: migrations; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.migrations (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    hash character varying(40) NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE storage.migrations OWNER TO supabase_storage_admin;

--
-- Name: objects; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.objects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bucket_id text,
    name text,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text,
    owner_id text,
    user_metadata jsonb,
    level integer
);


ALTER TABLE storage.objects OWNER TO supabase_storage_admin;

--
-- Name: COLUMN objects.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.objects.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: prefixes; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.prefixes (
    bucket_id text NOT NULL,
    name text NOT NULL COLLATE pg_catalog."C",
    level integer GENERATED ALWAYS AS (storage.get_level(name)) STORED NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE storage.prefixes OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads (
    id text NOT NULL,
    in_progress_size bigint DEFAULT 0 NOT NULL,
    upload_signature text NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    version text NOT NULL,
    owner_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_metadata jsonb
);


ALTER TABLE storage.s3_multipart_uploads OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads_parts; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads_parts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    upload_id text NOT NULL,
    size bigint DEFAULT 0 NOT NULL,
    part_number integer NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    etag text NOT NULL,
    owner_id text,
    version text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.s3_multipart_uploads_parts OWNER TO supabase_storage_admin;

--
-- Name: refresh_tokens id; Type: DEFAULT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens ALTER COLUMN id SET DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass);


--
-- Data for Name: audit_log_entries; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin;
00000000-0000-0000-0000-000000000000	b165693f-69a0-4bba-abff-3d3421935175	{"action":"user_confirmation_requested","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-07 02:18:34.67195+00	
00000000-0000-0000-0000-000000000000	a7f09c43-01f8-4455-a5d2-f2a783606abd	{"action":"user_signedup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"team","traits":{"provider":"email"}}	2025-10-07 02:19:00.544295+00	
00000000-0000-0000-0000-000000000000	307bbf9d-e65e-4d23-bdf2-5fd6ef00e618	{"action":"login","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-07 04:46:43.919193+00	
00000000-0000-0000-0000-000000000000	9f6cc449-fe06-4b34-bcec-7524a6d1498a	{"action":"logout","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account"}	2025-10-07 05:28:16.310811+00	
00000000-0000-0000-0000-000000000000	0ff39e16-1ad7-46ef-8e18-76a8fd90f6fb	{"action":"login","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-07 08:48:59.140883+00	
00000000-0000-0000-0000-000000000000	bd25fe6a-285a-41cd-bab9-8717f4bf233c	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-07 18:45:28.290668+00	
00000000-0000-0000-0000-000000000000	11a6f836-67ed-4991-8669-42284b724ccc	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-07 18:45:28.291805+00	
00000000-0000-0000-0000-000000000000	7c51c8e9-afd7-4fd9-a4fa-a07741109ea4	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-07 21:03:07.570344+00	
00000000-0000-0000-0000-000000000000	79560264-330a-4173-8c50-3146a212989c	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-07 21:03:07.571731+00	
00000000-0000-0000-0000-000000000000	8504b827-5939-455b-9b23-c466ae021295	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-08 00:01:02.726567+00	
00000000-0000-0000-0000-000000000000	4e9eee47-c7ad-44ed-b1fe-8664ec72e991	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-08 00:01:02.727692+00	
00000000-0000-0000-0000-000000000000	da637fb6-3391-477b-8af7-4e15d7b197a3	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-08 03:44:01.982199+00	
00000000-0000-0000-0000-000000000000	7a9e9079-ed64-40d3-8de1-60914638ec70	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-08 03:44:01.983571+00	
00000000-0000-0000-0000-000000000000	7c2acb00-09a7-417e-98b5-101ee95ece37	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-08 22:43:56.766499+00	
00000000-0000-0000-0000-000000000000	69e9f7ef-a69e-485f-8037-556463fb1e26	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-08 22:43:56.768437+00	
00000000-0000-0000-0000-000000000000	32ea0c0b-1f11-4157-a828-c60eae48934f	{"action":"login","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-09 00:08:36.263541+00	
00000000-0000-0000-0000-000000000000	088f88a6-6395-4c4b-8bbc-f01ba785d39b	{"action":"logout","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account"}	2025-10-09 00:09:34.36992+00	
00000000-0000-0000-0000-000000000000	63232cf7-5dc2-4b2b-b88a-7ddb80e5e56a	{"action":"login","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-09 00:10:05.22491+00	
00000000-0000-0000-0000-000000000000	1f98248b-9d69-49d0-b027-be3ecff1d0a6	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 01:41:17.23072+00	
00000000-0000-0000-0000-000000000000	a03046f1-72b4-4cd3-ae5f-ad708957223d	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 01:41:17.232148+00	
00000000-0000-0000-0000-000000000000	55bb06af-fcba-40ba-a25a-301cf61c843b	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 05:06:09.139103+00	
00000000-0000-0000-0000-000000000000	848b67c3-9ea6-4dda-9eef-dce87f4a7059	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 05:06:09.14013+00	
00000000-0000-0000-0000-000000000000	8d649fd9-6579-4555-b34c-49f0670d299b	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 06:04:14.279551+00	
00000000-0000-0000-0000-000000000000	5f306f9f-293b-4767-a9cc-6405788dfbbd	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 06:04:14.280639+00	
00000000-0000-0000-0000-000000000000	22dab06f-10d1-4145-9a8c-21f959541a35	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 07:02:44.295427+00	
00000000-0000-0000-0000-000000000000	96a32c78-354e-4bf5-8fa9-17378ffdaf4e	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 07:02:44.296879+00	
00000000-0000-0000-0000-000000000000	96d28e07-1098-469b-a63b-7c148849963b	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 08:29:31.584208+00	
00000000-0000-0000-0000-000000000000	292244a5-53e5-48a1-b5f2-a76cab1ae89c	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 08:29:31.585276+00	
00000000-0000-0000-0000-000000000000	21b7c536-b1f6-4dd1-a05e-51baaf45d5bd	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 09:46:04.261378+00	
00000000-0000-0000-0000-000000000000	5e241a2e-c358-4f8c-8a7c-6326d8dff7cc	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 09:46:04.262573+00	
00000000-0000-0000-0000-000000000000	8f2c876a-f51a-483e-b474-97b132344b76	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 10:44:20.102376+00	
00000000-0000-0000-0000-000000000000	15991d9e-fd01-48e4-83aa-9ac507d8292f	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 10:44:20.103961+00	
00000000-0000-0000-0000-000000000000	a5ae499d-49f1-4a49-b4cb-3cc213b813ca	{"action":"token_refreshed","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 21:04:24.302115+00	
00000000-0000-0000-0000-000000000000	f2296423-687d-412a-9557-0977ddc78c3f	{"action":"token_revoked","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-09 21:04:24.30369+00	
00000000-0000-0000-0000-000000000000	252ddac1-25b2-4037-8abb-0f341b302d59	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:38:48.232671+00	
00000000-0000-0000-0000-000000000000	6f7104fc-3557-4f72-869c-ecd23d5cdf0d	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:41:53.950453+00	
00000000-0000-0000-0000-000000000000	57950238-68a1-43d9-9f9c-d13d0aa6c6ff	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:45:34.43614+00	
00000000-0000-0000-0000-000000000000	3a410fe0-2d43-421e-86bd-dd30c91fa1f2	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:48:36.085691+00	
00000000-0000-0000-0000-000000000000	e73b46bc-eb9b-4d67-96c8-fc2d4b638f76	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:49:52.544789+00	
00000000-0000-0000-0000-000000000000	0f751d26-c233-4704-85a2-6e31702c6e1b	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:53:38.112848+00	
00000000-0000-0000-0000-000000000000	635cdd6e-8d4e-47d1-984d-9c0666904375	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:55:41.861971+00	
00000000-0000-0000-0000-000000000000	823b9265-3783-4f90-a02e-0b1c3d030201	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 00:56:09.053257+00	
00000000-0000-0000-0000-000000000000	a0e15883-e0a5-44c2-ad50-85b052f53ac1	{"action":"user_repeated_signup","actor_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","actor_name":"Peter Avenant","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 01:02:16.839463+00	
00000000-0000-0000-0000-000000000000	7de63d3e-19a5-450e-864e-ae03329ab631	{"action":"user_deleted","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"user_email":"avenants@gmail.com","user_id":"1543578f-d8e1-41d0-a1fa-5c3617f9c06e","user_phone":""}}	2025-10-14 01:03:51.447122+00	
00000000-0000-0000-0000-000000000000	e3631cf9-cd57-408f-bb42-52d0cc4cf2b9	{"action":"user_confirmation_requested","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-14 01:04:12.451579+00	
00000000-0000-0000-0000-000000000000	f4dce8e4-17d0-4c96-8153-aed2140b8cea	{"action":"user_signedup","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"team","traits":{"provider":"email"}}	2025-10-14 01:05:17.783391+00	
00000000-0000-0000-0000-000000000000	d441b215-c4f8-4bac-9eec-dae2ac9bdc85	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 02:10:53.188528+00	
00000000-0000-0000-0000-000000000000	5595afb2-0e0a-40e9-aa7b-2499177f1cd3	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 02:10:53.1896+00	
00000000-0000-0000-0000-000000000000	e2961b2e-2f48-4b8a-ba24-01cb1305a3ae	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 03:13:16.266058+00	
00000000-0000-0000-0000-000000000000	23a6e7d3-b88f-4423-a126-a511ec8efa27	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 03:13:16.267081+00	
00000000-0000-0000-0000-000000000000	85594482-738a-4b36-9ba2-5298cfd31136	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 04:36:41.889943+00	
00000000-0000-0000-0000-000000000000	afef8737-7c59-469e-90be-4c86b63e7b05	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 04:36:41.891481+00	
00000000-0000-0000-0000-000000000000	c5de789b-7c38-4ede-86ee-0fa6bc34270b	{"action":"login","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-14 05:06:31.200944+00	
00000000-0000-0000-0000-000000000000	13a9f106-3ca5-466f-848c-3f9499149a11	{"action":"login","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-14 05:12:13.395431+00	
00000000-0000-0000-0000-000000000000	0016f100-6c95-4e51-8ca8-abedcc8eafc4	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 06:09:53.580419+00	
00000000-0000-0000-0000-000000000000	593332da-9edc-4f1d-8bbe-4a82d33ba58a	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 06:09:53.581482+00	
00000000-0000-0000-0000-000000000000	6734880b-65f5-4646-b596-bc024b2a1cd4	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 06:20:30.496722+00	
00000000-0000-0000-0000-000000000000	be6d6882-d72d-4d25-b302-7bcee15989ae	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 06:20:30.498165+00	
00000000-0000-0000-0000-000000000000	245a0391-1bc8-4988-9435-e3bdb45aea9e	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 07:18:38.795433+00	
00000000-0000-0000-0000-000000000000	48b2c99a-5be7-406b-b449-8519ed602f1c	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 07:18:38.796557+00	
00000000-0000-0000-0000-000000000000	9fa3adfb-27f8-4dc9-9b72-6fe8818d3975	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 08:37:23.812371+00	
00000000-0000-0000-0000-000000000000	314cbcd5-cb69-4de9-a3e8-e1c558d404ba	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 08:37:23.813663+00	
00000000-0000-0000-0000-000000000000	6ffc083c-85f6-4eda-8966-c07386b8419b	{"action":"login","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-14 08:54:35.835697+00	
00000000-0000-0000-0000-000000000000	1bb4470f-3f6a-4ccc-875d-0eb16f20ebed	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 09:54:17.712553+00	
00000000-0000-0000-0000-000000000000	2a3b312c-0595-4ff9-ace5-072b2b221d8c	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 09:54:17.714187+00	
00000000-0000-0000-0000-000000000000	3d7e4d6f-0378-41c6-bfac-572235b11e8f	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 19:46:18.865006+00	
00000000-0000-0000-0000-000000000000	bc905440-59f0-40b5-acce-70d00ca39052	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 19:46:18.866572+00	
00000000-0000-0000-0000-000000000000	96abbd91-0357-4cbd-825d-a0b4df4a67b7	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 19:56:23.321405+00	
00000000-0000-0000-0000-000000000000	0ec31cdc-5e95-40fd-8ec6-99d822911318	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 19:56:23.322698+00	
00000000-0000-0000-0000-000000000000	5843553f-e7a5-4f91-939e-f0843535a7ae	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 20:44:33.194308+00	
00000000-0000-0000-0000-000000000000	c2c6667d-2a66-4f86-ac9f-1ead74f3a644	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 20:44:33.195654+00	
00000000-0000-0000-0000-000000000000	85fbd0df-4bb4-43b2-8506-6aea9eced581	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 22:03:43.754301+00	
00000000-0000-0000-0000-000000000000	a960d8ef-7310-4d94-b210-154acc446941	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 22:03:43.755461+00	
00000000-0000-0000-0000-000000000000	a82bb666-8fdf-4697-a4c8-b6f89432d54b	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 23:01:45.525556+00	
00000000-0000-0000-0000-000000000000	d7d089c1-a08f-4551-b294-e1301ba3f979	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-14 23:01:45.527205+00	
00000000-0000-0000-0000-000000000000	84f5fef6-e073-4898-b5b1-0b07bb8ce254	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 00:00:09.778702+00	
00000000-0000-0000-0000-000000000000	af1f0d2e-d156-4d36-b0dc-f7fc58b29357	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 00:00:09.780234+00	
00000000-0000-0000-0000-000000000000	7293cdcf-a0cd-4c5a-8cc0-4c207a670254	{"action":"login","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-15 03:42:16.676484+00	
00000000-0000-0000-0000-000000000000	508883a1-2c57-41e8-b0e1-f1eea0e3eb93	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 04:40:46.586505+00	
00000000-0000-0000-0000-000000000000	1696940b-57b7-4119-a346-b500378b45f0	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 04:40:46.587561+00	
00000000-0000-0000-0000-000000000000	dc6c9843-32ca-4abd-88ac-1e13aa32e852	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 05:38:57.490353+00	
00000000-0000-0000-0000-000000000000	540dc232-1143-4e5d-aa7c-6a01ac3aa4d0	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 05:38:57.491427+00	
00000000-0000-0000-0000-000000000000	54378977-973a-4ca0-bf58-8dd9217725fa	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 06:37:27.522805+00	
00000000-0000-0000-0000-000000000000	87d9115a-4ddf-4e65-b440-e1a62045d448	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 06:37:27.524315+00	
00000000-0000-0000-0000-000000000000	057c2c3e-0434-4233-9c6e-637389dfbaa3	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 07:51:47.140088+00	
00000000-0000-0000-0000-000000000000	1a02b64a-5738-4dda-b26c-e5ca81a83c0f	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 07:51:47.141858+00	
00000000-0000-0000-0000-000000000000	bcdac092-aa9b-4e8d-9ae7-ed7cd1902b9d	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 08:50:37.228594+00	
00000000-0000-0000-0000-000000000000	6bea4dad-9d07-4af1-84f3-d4de89d1a71b	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 08:50:37.230227+00	
00000000-0000-0000-0000-000000000000	776ceac5-4dcf-4faa-a0df-90f36cc4206b	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 20:54:18.660045+00	
00000000-0000-0000-0000-000000000000	235efdc2-6e9f-4ee2-bde9-3286dc6ad022	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 20:54:18.661222+00	
00000000-0000-0000-0000-000000000000	d72a485c-641d-43b3-889b-faf3c8928324	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 21:52:31.563558+00	
00000000-0000-0000-0000-000000000000	4741f5c1-e63f-485b-9bf6-663fc66c04ee	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 21:52:31.565043+00	
00000000-0000-0000-0000-000000000000	4fdbcadf-57b5-4e15-b2e1-7ddec691712d	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 22:51:29.581421+00	
00000000-0000-0000-0000-000000000000	ad17e778-a802-45a0-b7db-e82763168cc7	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 22:51:29.582635+00	
00000000-0000-0000-0000-000000000000	a397f57e-e904-4b99-87e9-6d262b031c13	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 23:49:59.638668+00	
00000000-0000-0000-0000-000000000000	b0386878-4d43-4fdf-8d33-3d647ebe5ade	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-15 23:49:59.63979+00	
00000000-0000-0000-0000-000000000000	0c09b43b-1eb0-4a43-9938-a418c03aeccb	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 00:48:29.556922+00	
00000000-0000-0000-0000-000000000000	118de746-dd51-43f5-90f2-6c9f709aeb9e	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 00:48:29.558424+00	
00000000-0000-0000-0000-000000000000	8755635b-a86a-42e1-9032-1aec4434082d	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 01:47:00.584436+00	
00000000-0000-0000-0000-000000000000	694c6667-a75b-49fd-8b44-8d2f2905c3fb	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 01:47:00.587276+00	
00000000-0000-0000-0000-000000000000	535e7c92-b5fe-4502-814e-f9e90f3dc647	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 02:45:15.46082+00	
00000000-0000-0000-0000-000000000000	bfc1c3d8-8676-4a82-aa50-95dadc94c8cd	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 02:45:15.462328+00	
00000000-0000-0000-0000-000000000000	ebbf8ffa-b37e-4c73-80ae-4ae9317e980d	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 04:19:15.184093+00	
00000000-0000-0000-0000-000000000000	dff9a410-85c7-4926-88ce-0af25a6c1e0b	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 04:19:15.185194+00	
00000000-0000-0000-0000-000000000000	04675be8-64a9-458d-bdfd-9e61dbef1897	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 05:17:26.525791+00	
00000000-0000-0000-0000-000000000000	c745b271-860b-419d-80a1-fe81c64da61e	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 05:17:26.526873+00	
00000000-0000-0000-0000-000000000000	532046b9-5787-4857-87c6-b01d4a54869d	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 06:15:56.562197+00	
00000000-0000-0000-0000-000000000000	c5476599-c414-4e86-ae4c-128715678d5f	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 06:15:56.563555+00	
00000000-0000-0000-0000-000000000000	db8fe306-769b-47a8-b8c1-33cf92e15834	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 07:21:36.337982+00	
00000000-0000-0000-0000-000000000000	2324626f-9bf8-4c16-a9d4-cf380f8acf71	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 07:21:36.339085+00	
00000000-0000-0000-0000-000000000000	d0621e99-10f7-422f-86de-95a3d6244b41	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 08:24:17.102134+00	
00000000-0000-0000-0000-000000000000	61d70c4e-6c60-40cb-bb0a-a5e639b1c337	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 08:24:17.103767+00	
00000000-0000-0000-0000-000000000000	7917bab6-18b1-4644-8927-b6a24645476f	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 20:04:39.88543+00	
00000000-0000-0000-0000-000000000000	dafc2541-6e32-4a84-bfc3-519ab7efbe56	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 20:04:39.886675+00	
00000000-0000-0000-0000-000000000000	49731856-6625-4210-866d-52da1c36ed06	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 21:06:57.799595+00	
00000000-0000-0000-0000-000000000000	d9dd662c-d554-4aa9-bd35-93ebf3799a35	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 21:06:57.800665+00	
00000000-0000-0000-0000-000000000000	4492f7b2-54ea-41a6-9bc6-af602dd23ea6	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 23:43:14.530852+00	
00000000-0000-0000-0000-000000000000	c97e8e3f-87aa-4ce5-b0a4-d4255adccf9b	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 23:43:14.532398+00	
00000000-0000-0000-0000-000000000000	1dc52642-4e16-4644-9225-d7395c792a89	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 23:54:31.113484+00	
00000000-0000-0000-0000-000000000000	02c14b3c-8975-42ec-b451-c4b7f46e9592	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-16 23:54:31.115295+00	
00000000-0000-0000-0000-000000000000	25d16caf-37d6-4efc-9feb-2e952ded4bc3	{"action":"login","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-17 00:44:15.77855+00	
00000000-0000-0000-0000-000000000000	e1d5b1b4-4fe5-478e-8acd-913f35be0dcb	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 01:54:03.981655+00	
00000000-0000-0000-0000-000000000000	17d0dce4-155c-4999-8839-d3dec437ec02	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 01:54:03.983158+00	
00000000-0000-0000-0000-000000000000	c6e85c15-9261-4dda-a4a0-af3621116428	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 02:55:20.986349+00	
00000000-0000-0000-0000-000000000000	b633eab0-c3e8-4574-acb8-fec82b164147	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 02:55:20.98751+00	
00000000-0000-0000-0000-000000000000	657f521e-05ae-4005-88d0-8d7430b1a387	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 03:49:15.498638+00	
00000000-0000-0000-0000-000000000000	b8505f1e-0d20-4245-97e0-8a094411b403	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 03:49:15.499669+00	
00000000-0000-0000-0000-000000000000	2cf842fc-1fa8-45fa-9fbd-86eebced6863	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 04:54:46.306241+00	
00000000-0000-0000-0000-000000000000	e1026d14-9b4d-405a-9b85-d73511b493b1	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 04:54:46.30758+00	
00000000-0000-0000-0000-000000000000	57030cf5-988f-479f-812c-6b2eac0cb8ec	{"action":"token_refreshed","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 07:38:34.635999+00	
00000000-0000-0000-0000-000000000000	b3df4345-7f90-4442-aeaa-df68c9b8463a	{"action":"token_revoked","actor_id":"24aac2e1-33f5-466e-afd6-3143f25bf496","actor_name":"Bob Maluga","actor_username":"avenants@gmail.com","actor_via_sso":false,"log_type":"token"}	2025-10-17 07:38:34.637073+00	
\.


--
-- Data for Name: flow_state; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin;
\.


--
-- Data for Name: identities; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin;
24aac2e1-33f5-466e-afd6-3143f25bf496	24aac2e1-33f5-466e-afd6-3143f25bf496	{"sub": "24aac2e1-33f5-466e-afd6-3143f25bf496", "email": "avenants@gmail.com", "full_name": "Bob Maluga", "email_verified": true, "phone_verified": false}	email	2025-10-14 01:04:12.448034+00	2025-10-14 01:04:12.448104+00	2025-10-14 01:04:12.448104+00	a365d793-544c-48ea-90e5-42c0e103d4c9
\.


--
-- Data for Name: instances; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: mfa_amr_claims; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin;
06d3523e-4c72-4a22-ad28-45c840425f8f	2025-10-14 01:05:17.793278+00	2025-10-14 01:05:17.793278+00	otp	7177c456-02ca-4f35-82ea-beed9a6482cf
b00eb48a-5e64-43da-b2ed-14e0ede09134	2025-10-14 05:06:31.206415+00	2025-10-14 05:06:31.206415+00	password	a9dfb195-f9bc-45d9-9086-4cd68f1188e7
7572a3cc-4d18-49af-827d-852e8beb58f3	2025-10-14 05:12:13.400137+00	2025-10-14 05:12:13.400137+00	password	1db8fbb6-0f35-4274-91f3-c035febc3413
2c659c7a-238f-4ce3-9fef-cab401575e2e	2025-10-14 08:54:35.840694+00	2025-10-14 08:54:35.840694+00	password	4ca39396-a155-47f1-b02e-7942975379ce
7f85c8f0-13d9-42b6-812a-a5debd0a7a98	2025-10-15 03:42:16.681317+00	2025-10-15 03:42:16.681317+00	password	40fb5eec-b2e8-4ec1-acbb-518f86ae0301
173e71a6-57d7-42f5-b516-6010bddb8049	2025-10-17 00:44:15.784363+00	2025-10-17 00:44:15.784363+00	password	043b4d2f-3253-4057-91c8-e5cd6b9a3091
\.


--
-- Data for Name: mfa_challenges; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin;
\.


--
-- Data for Name: mfa_factors; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin;
\.


--
-- Data for Name: oauth_authorizations; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.oauth_authorizations (id, authorization_id, client_id, user_id, redirect_uri, scope, state, resource, code_challenge, code_challenge_method, response_type, status, authorization_code, created_at, expires_at, approved_at) FROM stdin;
\.


--
-- Data for Name: oauth_clients; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.oauth_clients (id, client_secret_hash, registration_type, redirect_uris, grant_types, client_name, client_uri, logo_uri, created_at, updated_at, deleted_at, client_type) FROM stdin;
\.


--
-- Data for Name: oauth_consents; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.oauth_consents (id, user_id, client_id, scopes, granted_at, revoked_at) FROM stdin;
\.


--
-- Data for Name: one_time_tokens; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: refresh_tokens; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin;
00000000-0000-0000-0000-000000000000	43	fjz2konjzkdj	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 20:54:18.662721+00	2025-10-15 21:52:31.565726+00	2t43jwyw2lbz	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	44	k65ea35y42d6	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 21:52:31.566504+00	2025-10-15 22:51:29.583194+00	fjz2konjzkdj	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	45	yff64gr5cpmn	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 22:51:29.583951+00	2025-10-15 23:49:59.640375+00	k65ea35y42d6	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	46	xhmvyuccxjgm	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 23:49:59.641122+00	2025-10-16 00:48:29.559071+00	yff64gr5cpmn	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	47	o6bo7oparmme	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 00:48:29.559887+00	2025-10-16 01:47:00.588264+00	xhmvyuccxjgm	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	48	u5deh2hir7zi	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 01:47:00.589816+00	2025-10-16 02:45:15.463024+00	o6bo7oparmme	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	49	ixadcsxp7qss	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 02:45:15.463868+00	2025-10-16 04:19:15.185835+00	u5deh2hir7zi	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	50	cybjptph2s6f	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 04:19:15.186644+00	2025-10-16 05:17:26.527546+00	ixadcsxp7qss	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	51	sczsuitabykp	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 05:17:26.528361+00	2025-10-16 06:15:56.564193+00	cybjptph2s6f	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	52	p26yog3nz3ys	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 06:15:56.564968+00	2025-10-16 07:21:36.339812+00	sczsuitabykp	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	53	pnbaos5togyx	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 07:21:36.340633+00	2025-10-16 08:24:17.104893+00	p26yog3nz3ys	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	54	c66qirgfge7j	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 08:24:17.105707+00	2025-10-16 20:04:39.887281+00	pnbaos5togyx	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	55	hugkzcwqn2te	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 20:04:39.888025+00	2025-10-16 21:06:57.801288+00	c66qirgfge7j	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	56	l4ppf7eccryo	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 21:06:57.802032+00	2025-10-16 23:43:14.533138+00	hugkzcwqn2te	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	25	b4tgpjnr3kn2	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 06:09:53.583095+00	2025-10-16 23:54:31.116025+00	v6dxpx6awid5	b00eb48a-5e64-43da-b2ed-14e0ede09134
00000000-0000-0000-0000-000000000000	58	gnnbabz3wgng	24aac2e1-33f5-466e-afd6-3143f25bf496	f	2025-10-16 23:54:31.116985+00	2025-10-16 23:54:31.116985+00	b4tgpjnr3kn2	b00eb48a-5e64-43da-b2ed-14e0ede09134
00000000-0000-0000-0000-000000000000	59	dccnmhrwpq64	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-17 00:44:15.782476+00	2025-10-17 01:54:03.983827+00	\N	173e71a6-57d7-42f5-b516-6010bddb8049
00000000-0000-0000-0000-000000000000	19	ngb2yrnlybzh	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 01:05:17.791209+00	2025-10-14 02:10:53.190244+00	\N	06d3523e-4c72-4a22-ad28-45c840425f8f
00000000-0000-0000-0000-000000000000	20	itdvwg5734va	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 02:10:53.1911+00	2025-10-14 03:13:16.267815+00	ngb2yrnlybzh	06d3523e-4c72-4a22-ad28-45c840425f8f
00000000-0000-0000-0000-000000000000	60	f3omfx7ottv4	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-17 01:54:03.984587+00	2025-10-17 02:55:20.988229+00	dccnmhrwpq64	173e71a6-57d7-42f5-b516-6010bddb8049
00000000-0000-0000-0000-000000000000	21	batwxuxp44uq	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 03:13:16.268583+00	2025-10-14 04:36:41.892138+00	itdvwg5734va	06d3523e-4c72-4a22-ad28-45c840425f8f
00000000-0000-0000-0000-000000000000	22	pb7y57czffu3	24aac2e1-33f5-466e-afd6-3143f25bf496	f	2025-10-14 04:36:41.892991+00	2025-10-14 04:36:41.892991+00	batwxuxp44uq	06d3523e-4c72-4a22-ad28-45c840425f8f
00000000-0000-0000-0000-000000000000	61	cr7ojstev6r7	24aac2e1-33f5-466e-afd6-3143f25bf496	f	2025-10-17 02:55:20.989057+00	2025-10-17 02:55:20.989057+00	f3omfx7ottv4	173e71a6-57d7-42f5-b516-6010bddb8049
00000000-0000-0000-0000-000000000000	57	e3ww43bffg4e	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-16 23:43:14.533945+00	2025-10-17 03:49:15.500341+00	l4ppf7eccryo	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	23	v6dxpx6awid5	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 05:06:31.204234+00	2025-10-14 06:09:53.582232+00	\N	b00eb48a-5e64-43da-b2ed-14e0ede09134
00000000-0000-0000-0000-000000000000	24	vhyyqctf47tc	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 05:12:13.398097+00	2025-10-14 06:20:30.49886+00	\N	7572a3cc-4d18-49af-827d-852e8beb58f3
00000000-0000-0000-0000-000000000000	26	q2qcan3pcks3	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 06:20:30.499617+00	2025-10-14 07:18:38.797245+00	vhyyqctf47tc	7572a3cc-4d18-49af-827d-852e8beb58f3
00000000-0000-0000-0000-000000000000	62	ixvkmn2ewimc	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-17 03:49:15.501106+00	2025-10-17 04:54:46.308258+00	e3ww43bffg4e	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	27	mdgmbqxrp6f7	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 07:18:38.798056+00	2025-10-14 08:37:23.814434+00	q2qcan3pcks3	7572a3cc-4d18-49af-827d-852e8beb58f3
00000000-0000-0000-0000-000000000000	63	wnqysplpvnsr	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-17 04:54:46.30899+00	2025-10-17 07:38:34.637688+00	ixvkmn2ewimc	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	29	5xqktbzwz26s	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 08:54:35.838328+00	2025-10-14 09:54:17.714912+00	\N	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	64	476yae66rzvs	24aac2e1-33f5-466e-afd6-3143f25bf496	f	2025-10-17 07:38:34.638517+00	2025-10-17 07:38:34.638517+00	wnqysplpvnsr	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	30	mqeqm23hue4d	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 09:54:17.715715+00	2025-10-14 19:46:18.867241+00	5xqktbzwz26s	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	28	flxlr2i366o7	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 08:37:23.815278+00	2025-10-14 19:56:23.323308+00	mdgmbqxrp6f7	7572a3cc-4d18-49af-827d-852e8beb58f3
00000000-0000-0000-0000-000000000000	32	4btrnek75yz2	24aac2e1-33f5-466e-afd6-3143f25bf496	f	2025-10-14 19:56:23.324063+00	2025-10-14 19:56:23.324063+00	flxlr2i366o7	7572a3cc-4d18-49af-827d-852e8beb58f3
00000000-0000-0000-0000-000000000000	31	7sosqg2rm7xg	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 19:46:18.868042+00	2025-10-14 20:44:33.196301+00	mqeqm23hue4d	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	33	chdph7bvbhjo	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 20:44:33.197071+00	2025-10-14 22:03:43.756143+00	7sosqg2rm7xg	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	34	vsccee77bzt5	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 22:03:43.75692+00	2025-10-14 23:01:45.52788+00	chdph7bvbhjo	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	35	reqci6xqhe2z	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-14 23:01:45.528725+00	2025-10-15 00:00:09.780859+00	vsccee77bzt5	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	36	bb7cucpkqh5r	24aac2e1-33f5-466e-afd6-3143f25bf496	f	2025-10-15 00:00:09.781641+00	2025-10-15 00:00:09.781641+00	reqci6xqhe2z	2c659c7a-238f-4ce3-9fef-cab401575e2e
00000000-0000-0000-0000-000000000000	37	vyudihlxqptc	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 03:42:16.67919+00	2025-10-15 04:40:46.588147+00	\N	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	38	d4njg5i2q5v7	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 04:40:46.588918+00	2025-10-15 05:38:57.492119+00	vyudihlxqptc	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	39	lz2m5vqrfoqf	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 05:38:57.492904+00	2025-10-15 06:37:27.524967+00	d4njg5i2q5v7	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	40	v6sjyipcbn4j	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 06:37:27.525925+00	2025-10-15 07:51:47.142503+00	lz2m5vqrfoqf	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	41	etq6ywpmrhc2	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 07:51:47.143312+00	2025-10-15 08:50:37.231004+00	v6sjyipcbn4j	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
00000000-0000-0000-0000-000000000000	42	2t43jwyw2lbz	24aac2e1-33f5-466e-afd6-3143f25bf496	t	2025-10-15 08:50:37.231995+00	2025-10-15 20:54:18.661902+00	etq6ywpmrhc2	7f85c8f0-13d9-42b6-812a-a5debd0a7a98
\.


--
-- Data for Name: saml_providers; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin;
\.


--
-- Data for Name: saml_relay_states; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin;
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.schema_migrations (version) FROM stdin;
20171026211738
20171026211808
20171026211834
20180103212743
20180108183307
20180119214651
20180125194653
00
20210710035447
20210722035447
20210730183235
20210909172000
20210927181326
20211122151130
20211124214934
20211202183645
20220114185221
20220114185340
20220224000811
20220323170000
20220429102000
20220531120530
20220614074223
20220811173540
20221003041349
20221003041400
20221011041400
20221020193600
20221021073300
20221021082433
20221027105023
20221114143122
20221114143410
20221125140132
20221208132122
20221215195500
20221215195800
20221215195900
20230116124310
20230116124412
20230131181311
20230322519590
20230402418590
20230411005111
20230508135423
20230523124323
20230818113222
20230914180801
20231027141322
20231114161723
20231117164230
20240115144230
20240214120130
20240306115329
20240314092811
20240427152123
20240612123726
20240729123726
20240802193726
20240806073726
20241009103726
20250717082212
20250731150234
20250804100000
20250901200500
20250903112500
20250904133000
\.


--
-- Data for Name: sessions; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.sessions (id, user_id, created_at, updated_at, factor_id, aal, not_after, refreshed_at, user_agent, ip, tag, oauth_client_id) FROM stdin;
2c659c7a-238f-4ce3-9fef-cab401575e2e	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-14 08:54:35.83686+00	2025-10-15 00:00:09.784501+00	\N	aal1	\N	2025-10-15 00:00:09.78441	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	115.70.197.126	\N	\N
06d3523e-4c72-4a22-ad28-45c840425f8f	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-14 01:05:17.789572+00	2025-10-14 04:36:41.89831+00	\N	aal1	\N	2025-10-14 04:36:41.898223	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	115.70.197.126	\N	\N
7572a3cc-4d18-49af-827d-852e8beb58f3	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-14 05:12:13.396634+00	2025-10-14 19:56:23.326825+00	\N	aal1	\N	2025-10-14 19:56:23.326744	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	115.70.197.126	\N	\N
b00eb48a-5e64-43da-b2ed-14e0ede09134	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-14 05:06:31.202824+00	2025-10-16 23:54:31.1203+00	\N	aal1	\N	2025-10-16 23:54:31.12021	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	115.70.197.126	\N	\N
173e71a6-57d7-42f5-b516-6010bddb8049	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-17 00:44:15.781059+00	2025-10-17 02:55:20.993226+00	\N	aal1	\N	2025-10-17 02:55:20.993128	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	115.70.197.126	\N	\N
7f85c8f0-13d9-42b6-812a-a5debd0a7a98	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-15 03:42:16.677697+00	2025-10-17 07:38:34.64165+00	\N	aal1	\N	2025-10-17 07:38:34.641572	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	115.70.197.126	\N	\N
\.


--
-- Data for Name: sso_domains; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: sso_providers; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.sso_providers (id, resource_id, created_at, updated_at, disabled) FROM stdin;
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin;
00000000-0000-0000-0000-000000000000	24aac2e1-33f5-466e-afd6-3143f25bf496	authenticated	authenticated	avenants@gmail.com	$2a$10$bLG0Uu1HshGDiyxruOdyKO/mB85FEHvvBPNIbXupwwXzqJ0HFSx/a	2025-10-14 01:05:17.784385+00	\N		2025-10-14 01:04:12.452308+00		\N			\N	2025-10-17 00:44:15.780925+00	{"provider": "email", "providers": ["email"]}	{"sub": "24aac2e1-33f5-466e-afd6-3143f25bf496", "email": "avenants@gmail.com", "full_name": "Bob Maluga", "email_verified": true, "phone_verified": false}	\N	2025-10-14 01:04:12.440392+00	2025-10-17 07:38:34.639844+00	\N	\N			\N		0	\N		\N	f	\N	f
\.


--
-- Data for Name: account_users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.account_users (id, account_id, user_id, role, joined_at, invited_by, invitation_accepted_at, is_active, deactivated_at, deactivated_by, deactivation_reason, role_changed_at, role_changed_by, previous_role, created_at, created_by, updated_at, updated_by) FROM stdin;
af71f661-234b-4b4b-a1c3-4ab6e5ea7dfb	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 01:25:44.420957	\N	\N	t	\N	\N	\N	\N	\N	\N	2025-10-17 03:31:48.093151	\N	2025-10-17 03:31:48.093151	\N
\.


--
-- Data for Name: accounts; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.accounts (id, name, slug, account_type, current_plan_id, subscription_tier, subscription_status, subscription_start_date, subscription_end_date, trial_end_date, usage_reset_date, billing_email, billing_address, stripe_customer_id, max_users, max_projects, max_datasets, max_monthly_ai_requests, max_storage_mb, current_user_count, current_project_count, current_dataset_count, current_monthly_ai_requests, current_storage_mb, is_verified, allow_trial, has_used_trial, created_at, updated_at, created_by, updated_by, deleted_at, deleted_by) FROM stdin;
e681aa33-c844-4e4e-b974-c9ad6c3fe4db	avenants@gmail.com's Account	\N	individual	ee2d550b-0644-4da3-9559-446bc0eb97ff	free	trialing	\N	\N	2025-10-28 01:28:28.892	\N	\N	\N	\N	1	5	100	100	1000	2	3	3	0	0	f	t	f	2025-10-14 01:25:44.329828	2025-10-17 01:02:14.663887	\N	\N	\N	\N
\.


--
-- Data for Name: api_tokens; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.api_tokens (id, account_id, user_id, name, description, token_hash, prefix, scopes, last_used_at, usage_count, last_used_ip, last_used_user_agent, expires_at, is_active, revoked_at, revoked_by, revoke_reason, created_at, created_by, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: audit_logs; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.audit_logs (id, dataset_id, workspace_id, change_type, entity_type, entity_id, field_name, old_value, new_value, changed_by, changed_at, committed_in_sha) FROM stdin;
\.


--
-- Data for Name: columns; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.columns (id, dataset_id, fqn, name, data_type, description, business_name, is_primary_key, is_foreign_key, is_nullable, default_value, reference_column_id, reference_type, reference_description, transformation_logic, ai_confidence_score, "position", created_at, updated_at, ai_suggestions, last_ai_enhancement, custom_metadata, created_by, updated_by, deleted_at, deleted_by) FROM stdin;
\.


--
-- Data for Name: configurations; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.configurations (id, workspace_id, name, type, config_json, is_active, created_by, created_at, updated_at, updated_by, deleted_at, deleted_by) FROM stdin;
\.


--
-- Data for Name: connection_metadata_cache; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.connection_metadata_cache (id, connection_id, metadata_type, metadata, cached_at, expires_at, is_stale, created_at, updated_at, created_by, updated_by) FROM stdin;
\.


--
-- Data for Name: connections; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.connections (id, account_id, name, description, connection_type, configuration, is_active, last_tested_at, test_status, test_error_message, import_settings, last_import_at, owner_id, visibility, is_locked, created_by, created_at, updated_at, catalog, updated_by, deleted_at, deleted_by) FROM stdin;
b01b223e-77ff-4a6a-abdb-7d53977ed806	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	AWLT_FF_SRC	\N	FileSystem	{"type": "local", "supported_formats": ["csv", "json", "parquet"]}	t	\N	untested	\N	{}	\N	\N	private	f	\N	2025-10-17 00:18:04.071915	2025-10-17 00:18:17.03806	\N	\N	\N	\N
087e82d2-d5fa-4e60-a460-e8d97efa49b0	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	AWLT_SRC	\N	MSSQL	{"cdc": {"enabled": false, "tracking_tables": []}, "port": 1433, "server": ".", "advanced": {"command_timeout": 300, "application_name": "Uroq_MetadataManager", "connection_timeout": 30, "additional_properties": ""}, "database": "AdventureWorksLT2012", "encryption": {"mode": "Mandatory", "trust_server_certificate": true}, "authentication": {"type": "windows_auth", "password": "", "username": ""}}	t	2025-10-16 02:48:10.823	success	\N	{}	\N	\N	private	f	\N	2025-10-14 08:57:47.114788	2025-10-16 08:50:00.760045	\N	\N	\N	\N
\.


--
-- Data for Name: datasets; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.datasets (id, account_id, name, medallion_layer, description, metadata, ai_confidence_score, owner_id, visibility, is_locked, source_control_file_path, source_control_commit_sha, has_uncommitted_changes, last_synced_at, sync_status, sync_error_message, created_by, created_at, updated_at, dataset_type, connection_id, schema, fully_qualified_name, updated_by, deleted_at, deleted_by) FROM stdin;
da670a46-1cdc-4024-8fc1-4539d86a78e1	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	Address	\N	\N	\N	\N	\N	private	f	\N	\N	t	\N	pending	\N	\N	2025-10-17 01:02:13.866	2025-10-17 01:02:13.866	Table	087e82d2-d5fa-4e60-a460-e8d97efa49b0	SalesLT	SalesLT.Address	\N	\N	\N
773fdbe8-49a5-4109-87cb-5d8f753051d8	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	Customer	\N	\N	\N	\N	\N	private	f	\N	\N	t	\N	pending	\N	\N	2025-10-17 01:02:14.135	2025-10-17 01:02:14.135	Table	087e82d2-d5fa-4e60-a460-e8d97efa49b0	SalesLT	SalesLT.Customer	\N	\N	\N
ceb0502c-aef9-4cc6-b5d5-1fcaa7743309	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	CustomerAddress	\N	\N	\N	\N	\N	private	f	\N	\N	t	\N	pending	\N	\N	2025-10-17 01:02:14.387	2025-10-17 01:02:14.387	Table	087e82d2-d5fa-4e60-a460-e8d97efa49b0	SalesLT	SalesLT.CustomerAddress	\N	\N	\N
\.


--
-- Data for Name: diagram_datasets; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.diagram_datasets (id, diagram_id, dataset_id, location, is_expanded, is_highlighted, z_index, created_by, created_at, notes, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: diagrams; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.diagrams (id, account_id, workspace_id, name, description, diagram_type, view_mode, viewport, node_positions, node_expansions, edge_routes, filters, layout_type, layout_direction, auto_layout, owner_id, visibility, is_template, tags, metadata, version, last_modified_by, created_at, updated_at, created_by, updated_by) FROM stdin;
abfdf2d4-d691-4ed3-bf97-aa7cc4eaa40c	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	3bdaa15b-a289-46a2-ad65-8af76e0de8e2	Demo Diagram	\N	dataset	relationships	{"x": 0, "y": 0, "zoom": 1}	{}	{}	{}	{"hasLineage": false, "syncStatus": [], "searchQuery": "", "datasetTypes": [], "aiConfidenceMin": 0, "medallionLayers": [], "hasRelationships": false}	hierarchical	LR	f	\N	private	f	\N	{}	2	\N	2025-10-17 02:47:28.607083	2025-10-17 02:58:50.90695	\N	\N
\.


--
-- Data for Name: environments; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.environments (id, account_id, project_id, workspace_id, name, description, target_platform, target_catalog, target_schema, platform_url, platform_config, auto_deploy, created_at, updated_at, created_by, updated_by, deleted_at, deleted_by) FROM stdin;
\.


--
-- Data for Name: invitations; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.invitations (id, account_id, email, role, invited_by, expires_at, accepted_at, created_at, token, invited_by_name, invited_by_email, status, accepted_by, message, metadata, created_by, updated_at, updated_by, deleted_at, deleted_by) FROM stdin;
\.


--
-- Data for Name: lineage; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.lineage (id, workspace_id, downstream_dataset_id, downstream_column_id, upstream_dataset_id, upstream_column_id, mapping_type, transformation_expression, lineage_type, created_at, created_by, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: macros; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.macros (id, name, description, code_fragment, language, parameters, usage_example, is_public, created_by, created_at, updated_at, updated_by, deleted_at, deleted_by) FROM stdin;
\.


--
-- Data for Name: payments; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.payments (id, account_id, subscription_id, stripe_payment_intent_id, stripe_charge_id, stripe_invoice_id, amount, currency, status, payment_method, last4, brand, failure_code, failure_message, refund_amount, refund_reason, refunded_at, processed_at, created_at, created_by, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: project_users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.project_users (id, project_id, user_id, role, joined_at) FROM stdin;
5fef5a83-ed2c-4f46-8112-8ce331b2fcd7	2fbc7082-73e6-4699-9b3b-33f428d816b9	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
bd49ac61-37d6-418b-987c-2d84741f5ec7	90134e90-8b2a-4a60-80ea-e7c7069c6a20	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
5ab75cd6-50d7-417c-a883-3076b9167609	6047403c-a46e-4f4c-adae-166bf6d39def	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
\.


--
-- Data for Name: projects; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.projects (id, account_id, name, description, project_type, configuration, owner_id, visibility, is_locked, created_at, updated_at, source_control_provider, source_control_repo_url, source_control_connection_status, source_control_last_synced_at, source_control_default_branch, source_control_access_token_encrypted, source_control_refresh_token_encrypted, source_control_token_expires_at, source_control_username, created_by, updated_by, deleted_at, deleted_by) FROM stdin;
90134e90-8b2a-4a60-80ea-e7c7069c6a20	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	Sample Data Vault Project	Enterprise data warehouse using Data Vault 2.0 methodology	DataVault	{"quality_rules": {"min_confidence_score": 85, "require_descriptions": true, "require_business_names": true}, "default_schema": "raw_vault", "default_catalog": "analytics", "naming_conventions": {"case_style": "snake_case", "prefix_enabled": true, "suffix_enabled": false}, "data_vault_preferences": {"hash_algorithm": "SHA-256", "include_load_date": true, "hub_naming_pattern": "HUB_{entity_name}", "link_naming_pattern": "LNK_{entity1}_{entity2}", "include_record_source": true, "business_vault_enabled": true, "multi_active_satellites": true, "satellite_naming_pattern": "SAT_{hub}_{descriptor}"}, "medallion_layers_enabled": true}	24aac2e1-33f5-466e-afd6-3143f25bf496	public	f	2025-10-14 02:09:07.657398	2025-10-14 02:09:07.657398	\N	\N	not_connected	\N	main	\N	\N	\N	\N	\N	\N	\N	\N
6047403c-a46e-4f4c-adae-166bf6d39def	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	Sample Dimensional Project	Star schema dimensional model for business intelligence	Dimensional	{"quality_rules": {"min_confidence_score": 80, "require_descriptions": true, "require_business_names": true}, "default_schema": "reporting", "default_catalog": "analytics", "naming_conventions": {"case_style": "snake_case", "prefix_enabled": true, "suffix_enabled": false}, "dimensional_preferences": {"default_scd_type": 2, "fact_naming_pattern": "FCT_{entity_name}", "conformed_dimensions": true, "surrogate_key_strategy": "hash", "dimension_naming_pattern": "DIM_{entity_name}"}, "medallion_layers_enabled": false}	24aac2e1-33f5-466e-afd6-3143f25bf496	public	f	2025-10-14 02:09:07.657398	2025-10-14 02:09:07.657398	\N	\N	not_connected	\N	main	\N	\N	\N	\N	\N	\N	\N	\N
2fbc7082-73e6-4699-9b3b-33f428d816b9	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	Sample Standard Project	A standard project for general data modeling and management	Standard	{"quality_rules": {"min_confidence_score": 70, "require_descriptions": true, "require_business_names": false}, "default_schema": "default", "default_catalog": "main", "naming_conventions": {"case_style": "snake_case", "prefix_enabled": false, "suffix_enabled": false}, "medallion_layers_enabled": true}	24aac2e1-33f5-466e-afd6-3143f25bf496	public	t	2025-10-14 02:09:07.657398	2025-10-17 02:06:34.796267	github	https://github.com/avenantp/uroq-demo.git	connected	2025-10-14 07:33:08.671614+00	main	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	\N	\N	avenantp	\N	\N	\N	\N
\.


--
-- Data for Name: source_control_commits; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.source_control_commits (id, account_id, project_id, workspace_id, commit_sha, commit_message, author, committed_at, source_control_provider, files_changed, created_at, created_by, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: subscription_plans; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.subscription_plans (id, name, slug, tier, display_name, description, price_monthly, price_yearly, currency, stripe_price_id_monthly, stripe_price_id_yearly, max_users, max_projects, max_datasets, max_monthly_ai_requests, max_storage_mb, max_workspaces_per_project, max_connections, features, has_git_sync, has_ai_assistance, has_data_vault_accelerator, has_priority_support, has_sso, has_audit_logs, has_api_access, has_white_labeling, trial_days, is_active, is_public, is_recommended, sort_order, created_at, updated_at, created_by, updated_by) FROM stdin;
ee2d550b-0644-4da3-9559-446bc0eb97ff	Free	free	free	Free Plan	Perfect for individuals getting started	0.00	0.00	usd	\N	\N	1	5	100	100	1000	1	1	[]	t	f	f	f	f	f	f	f	0	t	t	f	1	2025-10-13 22:29:00.317757	2025-10-13 22:29:00.317757	\N	\N
26478e3b-2b26-44fd-96fa-b49f3422dbe3	Pro	pro	pro	Professional Plan	Advanced features for growing teams	29.00	290.00	usd	\N	\N	10	50	1000	1000	10000	5	10	["advanced_ai", "priority_support", "api_access"]	t	t	f	f	f	f	f	f	14	t	t	t	2	2025-10-13 22:29:00.317757	2025-10-13 22:29:00.317757	\N	\N
36b73d27-c9c6-44a0-9c57-ee925c0af54b	Enterprise	enterprise	enterprise	Enterprise Plan	Unlimited resources for large organizations	\N	\N	usd	\N	\N	-1	-1	-1	-1	-1	-1	-1	["advanced_ai", "priority_support", "sso", "audit_logs", "api_access", "white_labeling"]	t	t	f	f	f	f	f	f	30	t	t	f	3	2025-10-13 22:29:00.317757	2025-10-13 22:29:00.317757	\N	\N
\.


--
-- Data for Name: subscriptions; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.subscriptions (id, account_id, plan_id, stripe_subscription_id, stripe_customer_id, stripe_price_id, status, start_date, end_date, current_period_start, current_period_end, trial_start, trial_end, canceled_at, ended_at, billing_cycle, cancel_at_period_end, auto_renew, metadata, created_at, updated_at, created_by, updated_by) FROM stdin;
\.


--
-- Data for Name: template_fragments; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.template_fragments (id, template_id, name, injection_point_name, jinja_content, created_by, created_at, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: templates; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.templates (id, name, template_type, description, jinja_content, is_system, parent_template_id, injection_points, variables, created_by, created_at, updated_at, updated_by, deleted_at, deleted_by) FROM stdin;
\.


--
-- Data for Name: usage_events; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.usage_events (id, account_id, user_id, event_type, event_category, quantity, unit, resource_type, resource_id, metadata, created_at, created_by, updated_at, updated_by) FROM stdin;
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, email, full_name, avatar_url, is_active, last_login_at, preferences, created_at, updated_at, notification_settings, last_seen_at, is_email_verified, email_verification_token, email_verification_sent_at, password_reset_token, password_reset_expires, password_changed_at, failed_login_attempts, last_failed_login_at, account_locked_until, timezone, locale, onboarding_completed, onboarding_step, onboarding_completed_at, created_by, updated_by, deleted_at, deleted_by) FROM stdin;
24aac2e1-33f5-466e-afd6-3143f25bf496	avenants@gmail.com	Bob Maluga	\N	t	\N	{}	2025-10-14 01:04:12.439367	2025-10-14 01:04:12.439367	{"team_updates": true, "usage_alerts": true, "billing_alerts": true, "product_updates": false, "security_alerts": true, "marketing_emails": false, "invitation_alerts": true, "email_notifications": true}	\N	f	\N	\N	\N	\N	\N	0	\N	\N	UTC	en-US	f	\N	\N	\N	\N	\N	\N
\.


--
-- Data for Name: workspace_datasets; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.workspace_datasets (id, workspace_id, dataset_id, canvas_position, created_at, created_by, updated_at, updated_by) FROM stdin;
6921c760-81ea-4604-ba0c-5d3f0c3c3750	3bdaa15b-a289-46a2-ad65-8af76e0de8e2	da670a46-1cdc-4024-8fc1-4539d86a78e1	\N	2025-10-17 02:46:55.919183	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-17 03:31:48.093151	\N
80abec68-3fc8-420b-a911-d7eec7704266	3bdaa15b-a289-46a2-ad65-8af76e0de8e2	773fdbe8-49a5-4109-87cb-5d8f753051d8	\N	2025-10-17 02:46:56.04387	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-17 03:31:48.093151	\N
dd76a7c0-223b-491e-b915-afab25c4553f	3bdaa15b-a289-46a2-ad65-8af76e0de8e2	ceb0502c-aef9-4cc6-b5d5-1fcaa7743309	\N	2025-10-17 02:46:56.176521	24aac2e1-33f5-466e-afd6-3143f25bf496	2025-10-17 03:31:48.093151	\N
\.


--
-- Data for Name: workspace_users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.workspace_users (id, workspace_id, user_id, role, joined_at) FROM stdin;
98d6bcc1-dc5b-4a4c-84cf-ee473f52e4af	49bd1f7e-1ff3-4996-9c50-ebeb45754752	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 01:28:29.302797
0f254107-f640-4c0e-9b59-a8467a600652	3bdaa15b-a289-46a2-ad65-8af76e0de8e2	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
39a03768-9901-4a6a-8b52-ecaf173b5da0	667750bb-b8e5-45f5-b07e-f1d83235580f	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
7cda5786-75e9-4a9a-b617-470556474c72	3ccaf0f0-642f-430b-95c4-fe3ce6e3271e	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
4641fd6e-c26f-405e-b21c-10e5f8834244	1bd3a414-3ffd-4e45-881c-facb105d4124	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
a14f6ae7-ebc4-40e3-a87a-dddc10e77d7e	22bee49f-ceec-4f86-bd37-1a31a3eba5e4	24aac2e1-33f5-466e-afd6-3143f25bf496	owner	2025-10-14 02:09:07.657398
\.


--
-- Data for Name: workspaces; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.workspaces (id, account_id, project_id, name, description, source_control_branch, source_control_commit_sha, source_control_connection_status, last_synced_at, is_synced, owner_id, visibility, is_locked, settings, created_at, updated_at, created_by, updated_by, deleted_at, deleted_by) FROM stdin;
d7900434-691f-4595-8677-6f2e38877b6d	\N	\N	Test	\N	\N	\N	\N	\N	f	\N	private	f	{}	2025-10-14 01:27:41.927817	2025-10-14 01:27:41.927817	\N	\N	\N	\N
49bd1f7e-1ff3-4996-9c50-ebeb45754752	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	\N	My Workspace	\N	\N	\N	\N	\N	f	\N	private	f	{}	2025-10-14 01:28:29.232801	2025-10-14 01:28:29.232801	\N	\N	\N	\N
667750bb-b8e5-45f5-b07e-f1d83235580f	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	2fbc7082-73e6-4699-9b3b-33f428d816b9	Staging	Pre-production environment for final testing	\N	\N	disconnected	\N	f	24aac2e1-33f5-466e-afd6-3143f25bf496	public	f	{"canvas_settings": {"grid_size": 15, "default_zoom": 0.8, "grid_enabled": true, "show_minimap": false, "snap_to_grid": true}, "auto_sync_enabled": true, "sync_interval_minutes": 30, "default_medallion_layer": "Silver", "conflict_resolution_strategy": "manual"}	2025-10-14 02:09:07.657398	2025-10-14 02:09:07.657398	\N	\N	\N	\N
3ccaf0f0-642f-430b-95c4-fe3ce6e3271e	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	2fbc7082-73e6-4699-9b3b-33f428d816b9	Production	Production environment - handle with care	\N	\N	disconnected	\N	f	24aac2e1-33f5-466e-afd6-3143f25bf496	locked	t	{"canvas_settings": {"grid_size": 20, "default_zoom": 0.75, "grid_enabled": true, "show_minimap": false, "snap_to_grid": true}, "auto_sync_enabled": true, "sync_interval_minutes": 60, "default_medallion_layer": "Gold", "conflict_resolution_strategy": "manual"}	2025-10-14 02:09:07.657398	2025-10-14 02:09:07.657398	\N	\N	\N	\N
1bd3a414-3ffd-4e45-881c-facb105d4124	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	90134e90-8b2a-4a60-80ea-e7c7069c6a20	Development	Data Vault development workspace	\N	\N	disconnected	\N	f	24aac2e1-33f5-466e-afd6-3143f25bf496	public	f	{"canvas_settings": {"grid_size": 15, "default_zoom": 1.0, "grid_enabled": true, "show_minimap": true, "snap_to_grid": true}, "auto_sync_enabled": false, "sync_interval_minutes": 15, "conflict_resolution_strategy": "manual"}	2025-10-14 02:09:07.657398	2025-10-14 02:09:07.657398	\N	\N	\N	\N
22bee49f-ceec-4f86-bd37-1a31a3eba5e4	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	6047403c-a46e-4f4c-adae-166bf6d39def	Development	Dimensional model development workspace	\N	\N	disconnected	\N	f	24aac2e1-33f5-466e-afd6-3143f25bf496	public	f	{"canvas_settings": {"grid_size": 15, "default_zoom": 1.0, "grid_enabled": true, "show_minimap": true, "snap_to_grid": true}, "auto_sync_enabled": false, "sync_interval_minutes": 15, "conflict_resolution_strategy": "manual"}	2025-10-14 02:09:07.657398	2025-10-14 02:09:07.657398	\N	\N	\N	\N
3bdaa15b-a289-46a2-ad65-8af76e0de8e2	e681aa33-c844-4e4e-b974-c9ad6c3fe4db	2fbc7082-73e6-4699-9b3b-33f428d816b9	Development	Development environment for testing and experimentation	dev	\N	disconnected	\N	f	24aac2e1-33f5-466e-afd6-3143f25bf496	public	f	{"canvas_settings": {"grid_size": 15, "default_zoom": 1.0, "grid_enabled": true, "show_minimap": true, "snap_to_grid": true}, "auto_sync_enabled": false, "sync_interval_minutes": 15, "default_medallion_layer": "Bronze", "conflict_resolution_strategy": "manual"}	2025-10-14 02:09:07.657398	2025-10-14 07:56:20.848734	\N	\N	\N	\N
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: realtime; Owner: supabase_admin
--

COPY realtime.schema_migrations (version, inserted_at) FROM stdin;
20211116024918	2025-10-06 23:50:07
20211116045059	2025-10-06 23:50:08
20211116050929	2025-10-06 23:50:09
20211116051442	2025-10-06 23:50:10
20211116212300	2025-10-06 23:50:12
20211116213355	2025-10-06 23:50:12
20211116213934	2025-10-06 23:50:13
20211116214523	2025-10-06 23:50:15
20211122062447	2025-10-06 23:50:16
20211124070109	2025-10-06 23:50:17
20211202204204	2025-10-06 23:50:17
20211202204605	2025-10-06 23:50:18
20211210212804	2025-10-06 23:50:21
20211228014915	2025-10-06 23:50:22
20220107221237	2025-10-06 23:50:23
20220228202821	2025-10-06 23:50:24
20220312004840	2025-10-06 23:50:25
20220603231003	2025-10-06 23:50:27
20220603232444	2025-10-06 23:50:28
20220615214548	2025-10-06 23:50:29
20220712093339	2025-10-06 23:50:30
20220908172859	2025-10-06 23:50:31
20220916233421	2025-10-06 23:50:32
20230119133233	2025-10-06 23:50:32
20230128025114	2025-10-06 23:50:34
20230128025212	2025-10-06 23:50:35
20230227211149	2025-10-06 23:50:36
20230228184745	2025-10-06 23:50:37
20230308225145	2025-10-06 23:50:37
20230328144023	2025-10-06 23:50:38
20231018144023	2025-10-06 23:50:40
20231204144023	2025-10-06 23:50:41
20231204144024	2025-10-06 23:50:42
20231204144025	2025-10-06 23:50:43
20240108234812	2025-10-06 23:50:44
20240109165339	2025-10-06 23:50:45
20240227174441	2025-10-06 23:50:46
20240311171622	2025-10-06 23:50:48
20240321100241	2025-10-06 23:50:50
20240401105812	2025-10-06 23:50:53
20240418121054	2025-10-06 23:50:54
20240523004032	2025-10-06 23:50:58
20240618124746	2025-10-06 23:50:59
20240801235015	2025-10-06 23:51:00
20240805133720	2025-10-06 23:51:01
20240827160934	2025-10-06 23:51:02
20240919163303	2025-10-06 23:51:03
20240919163305	2025-10-06 23:51:04
20241019105805	2025-10-06 23:51:05
20241030150047	2025-10-06 23:51:08
20241108114728	2025-10-06 23:51:10
20241121104152	2025-10-06 23:51:10
20241130184212	2025-10-06 23:51:12
20241220035512	2025-10-06 23:51:13
20241220123912	2025-10-06 23:51:13
20241224161212	2025-10-06 23:51:14
20250107150512	2025-10-06 23:51:15
20250110162412	2025-10-06 23:51:16
20250123174212	2025-10-06 23:51:17
20250128220012	2025-10-06 23:51:18
20250506224012	2025-10-06 23:51:19
20250523164012	2025-10-06 23:51:20
20250714121412	2025-10-06 23:51:21
20250905041441	2025-10-06 23:51:22
\.


--
-- Data for Name: subscription; Type: TABLE DATA; Schema: realtime; Owner: supabase_admin
--

COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin;
\.


--
-- Data for Name: buckets; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id, type) FROM stdin;
\.


--
-- Data for Name: buckets_analytics; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.buckets_analytics (id, type, format, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: migrations; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.migrations (id, name, hash, executed_at) FROM stdin;
0	create-migrations-table	e18db593bcde2aca2a408c4d1100f6abba2195df	2025-10-06 23:50:06.434118
1	initialmigration	6ab16121fbaa08bbd11b712d05f358f9b555d777	2025-10-06 23:50:06.437763
2	storage-schema	5c7968fd083fcea04050c1b7f6253c9771b99011	2025-10-06 23:50:06.440528
3	pathtoken-column	2cb1b0004b817b29d5b0a971af16bafeede4b70d	2025-10-06 23:50:06.452103
4	add-migrations-rls	427c5b63fe1c5937495d9c635c263ee7a5905058	2025-10-06 23:50:06.461209
5	add-size-functions	79e081a1455b63666c1294a440f8ad4b1e6a7f84	2025-10-06 23:50:06.464796
6	change-column-name-in-get-size	f93f62afdf6613ee5e7e815b30d02dc990201044	2025-10-06 23:50:06.470398
7	add-rls-to-buckets	e7e7f86adbc51049f341dfe8d30256c1abca17aa	2025-10-06 23:50:06.474864
8	add-public-to-buckets	fd670db39ed65f9d08b01db09d6202503ca2bab3	2025-10-06 23:50:06.478079
9	fix-search-function	3a0af29f42e35a4d101c259ed955b67e1bee6825	2025-10-06 23:50:06.483709
10	search-files-search-function	68dc14822daad0ffac3746a502234f486182ef6e	2025-10-06 23:50:06.487287
11	add-trigger-to-auto-update-updated_at-column	7425bdb14366d1739fa8a18c83100636d74dcaa2	2025-10-06 23:50:06.493458
12	add-automatic-avif-detection-flag	8e92e1266eb29518b6a4c5313ab8f29dd0d08df9	2025-10-06 23:50:06.499568
13	add-bucket-custom-limits	cce962054138135cd9a8c4bcd531598684b25e7d	2025-10-06 23:50:06.504409
14	use-bytes-for-max-size	941c41b346f9802b411f06f30e972ad4744dad27	2025-10-06 23:50:06.509095
15	add-can-insert-object-function	934146bc38ead475f4ef4b555c524ee5d66799e5	2025-10-06 23:50:06.541311
16	add-version	76debf38d3fd07dcfc747ca49096457d95b1221b	2025-10-06 23:50:06.545871
17	drop-owner-foreign-key	f1cbb288f1b7a4c1eb8c38504b80ae2a0153d101	2025-10-06 23:50:06.550856
18	add_owner_id_column_deprecate_owner	e7a511b379110b08e2f214be852c35414749fe66	2025-10-06 23:50:06.554737
19	alter-default-value-objects-id	02e5e22a78626187e00d173dc45f58fa66a4f043	2025-10-06 23:50:06.561064
20	list-objects-with-delimiter	cd694ae708e51ba82bf012bba00caf4f3b6393b7	2025-10-06 23:50:06.564562
21	s3-multipart-uploads	8c804d4a566c40cd1e4cc5b3725a664a9303657f	2025-10-06 23:50:06.572094
22	s3-multipart-uploads-big-ints	9737dc258d2397953c9953d9b86920b8be0cdb73	2025-10-06 23:50:06.596066
23	optimize-search-function	9d7e604cddc4b56a5422dc68c9313f4a1b6f132c	2025-10-06 23:50:06.607336
24	operation-function	8312e37c2bf9e76bbe841aa5fda889206d2bf8aa	2025-10-06 23:50:06.610939
25	custom-metadata	d974c6057c3db1c1f847afa0e291e6165693b990	2025-10-06 23:50:06.615397
26	objects-prefixes	ef3f7871121cdc47a65308e6702519e853422ae2	2025-10-06 23:50:06.618356
27	search-v2	33b8f2a7ae53105f028e13e9fcda9dc4f356b4a2	2025-10-06 23:50:06.627674
28	object-bucket-name-sorting	ba85ec41b62c6a30a3f136788227ee47f311c436	2025-10-06 23:50:06.637537
29	create-prefixes	a7b1a22c0dc3ab630e3055bfec7ce7d2045c5b7b	2025-10-06 23:50:06.641601
30	update-object-levels	6c6f6cc9430d570f26284a24cf7b210599032db7	2025-10-06 23:50:06.644872
31	objects-level-index	33f1fef7ec7fea08bb892222f4f0f5d79bab5eb8	2025-10-06 23:50:06.650886
32	backward-compatible-index-on-objects	2d51eeb437a96868b36fcdfb1ddefdf13bef1647	2025-10-06 23:50:06.666464
33	backward-compatible-index-on-prefixes	fe473390e1b8c407434c0e470655945b110507bf	2025-10-06 23:50:06.674633
34	optimize-search-function-v1	82b0e469a00e8ebce495e29bfa70a0797f7ebd2c	2025-10-06 23:50:06.67664
35	add-insert-trigger-prefixes	63bb9fd05deb3dc5e9fa66c83e82b152f0caf589	2025-10-06 23:50:06.681011
36	optimise-existing-functions	81cf92eb0c36612865a18016a38496c530443899	2025-10-06 23:50:06.683939
37	add-bucket-name-length-trigger	3944135b4e3e8b22d6d4cbb568fe3b0b51df15c1	2025-10-06 23:50:06.6895
38	iceberg-catalog-flag-on-buckets	19a8bd89d5dfa69af7f222a46c726b7c41e462c5	2025-10-06 23:50:06.693359
39	add-search-v2-sort-support	39cf7d1e6bf515f4b02e41237aba845a7b492853	2025-10-06 23:50:06.700417
40	fix-prefix-race-conditions-optimized	fd02297e1c67df25a9fc110bf8c8a9af7fb06d1f	2025-10-06 23:50:06.706711
41	add-object-level-update-trigger	44c22478bf01744b2129efc480cd2edc9a7d60e9	2025-10-06 23:50:06.720726
42	rollback-prefix-triggers	f2ab4f526ab7f979541082992593938c05ee4b47	2025-10-06 23:50:06.726438
43	fix-object-level	ab837ad8f1c7d00cc0b7310e989a23388ff29fc6	2025-10-06 23:50:06.737039
\.


--
-- Data for Name: objects; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.objects (id, bucket_id, name, owner, created_at, updated_at, last_accessed_at, metadata, version, owner_id, user_metadata, level) FROM stdin;
\.


--
-- Data for Name: prefixes; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.prefixes (bucket_id, name, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: s3_multipart_uploads; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.s3_multipart_uploads (id, in_progress_size, upload_signature, bucket_id, key, version, owner_id, created_at, user_metadata) FROM stdin;
\.


--
-- Data for Name: s3_multipart_uploads_parts; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.s3_multipart_uploads_parts (id, upload_id, size, part_number, bucket_id, key, etag, owner_id, version, created_at) FROM stdin;
\.


--
-- Data for Name: secrets; Type: TABLE DATA; Schema: vault; Owner: supabase_admin
--

COPY vault.secrets (id, name, description, secret, key_id, nonce, created_at, updated_at) FROM stdin;
\.


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE SET; Schema: auth; Owner: supabase_auth_admin
--

SELECT pg_catalog.setval('auth.refresh_tokens_id_seq', 64, true);


--
-- Name: subscription_id_seq; Type: SEQUENCE SET; Schema: realtime; Owner: supabase_admin
--

SELECT pg_catalog.setval('realtime.subscription_id_seq', 1, false);


--
-- Name: mfa_amr_claims amr_id_pk; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT amr_id_pk PRIMARY KEY (id);


--
-- Name: audit_log_entries audit_log_entries_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.audit_log_entries
    ADD CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id);


--
-- Name: flow_state flow_state_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.flow_state
    ADD CONSTRAINT flow_state_pkey PRIMARY KEY (id);


--
-- Name: identities identities_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_pkey PRIMARY KEY (id);


--
-- Name: identities identities_provider_id_provider_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider);


--
-- Name: instances instances_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.instances
    ADD CONSTRAINT instances_pkey PRIMARY KEY (id);


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_authentication_method_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method);


--
-- Name: mfa_challenges mfa_challenges_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id);


--
-- Name: mfa_factors mfa_factors_last_challenged_at_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at);


--
-- Name: mfa_factors mfa_factors_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_pkey PRIMARY KEY (id);


--
-- Name: oauth_authorizations oauth_authorizations_authorization_code_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_authorization_code_key UNIQUE (authorization_code);


--
-- Name: oauth_authorizations oauth_authorizations_authorization_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_authorization_id_key UNIQUE (authorization_id);


--
-- Name: oauth_authorizations oauth_authorizations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_pkey PRIMARY KEY (id);


--
-- Name: oauth_clients oauth_clients_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_clients
    ADD CONSTRAINT oauth_clients_pkey PRIMARY KEY (id);


--
-- Name: oauth_consents oauth_consents_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_pkey PRIMARY KEY (id);


--
-- Name: oauth_consents oauth_consents_user_client_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_user_client_unique UNIQUE (user_id, client_id);


--
-- Name: one_time_tokens one_time_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_token_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_token_unique UNIQUE (token);


--
-- Name: saml_providers saml_providers_entity_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id);


--
-- Name: saml_providers saml_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_pkey PRIMARY KEY (id);


--
-- Name: saml_relay_states saml_relay_states_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: sso_domains sso_domains_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_pkey PRIMARY KEY (id);


--
-- Name: sso_providers sso_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_providers
    ADD CONSTRAINT sso_providers_pkey PRIMARY KEY (id);


--
-- Name: users users_phone_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_phone_key UNIQUE (phone);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: account_users account_users_account_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_account_id_user_id_key UNIQUE (account_id, user_id);


--
-- Name: account_users account_users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_pkey PRIMARY KEY (id);


--
-- Name: accounts accounts_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_name_key UNIQUE (name);


--
-- Name: accounts accounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_pkey PRIMARY KEY (id);


--
-- Name: accounts accounts_slug_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_slug_key UNIQUE (slug);


--
-- Name: accounts accounts_stripe_customer_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_stripe_customer_id_key UNIQUE (stripe_customer_id);


--
-- Name: api_tokens api_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_pkey PRIMARY KEY (id);


--
-- Name: api_tokens api_tokens_token_hash_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_token_hash_key UNIQUE (token_hash);


--
-- Name: audit_logs audit_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_pkey PRIMARY KEY (id);


--
-- Name: columns columns_dataset_id_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_dataset_id_name_key UNIQUE (dataset_id, name);


--
-- Name: columns columns_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_pkey PRIMARY KEY (id);


--
-- Name: configurations configurations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configurations
    ADD CONSTRAINT configurations_pkey PRIMARY KEY (id);


--
-- Name: connection_metadata_cache connection_metadata_cache_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connection_metadata_cache
    ADD CONSTRAINT connection_metadata_cache_pkey PRIMARY KEY (id);


--
-- Name: connections connections_account_id_name_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_account_id_name_unique UNIQUE (account_id, name);


--
-- Name: connections connections_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_pkey PRIMARY KEY (id);


--
-- Name: datasets datasets_account_fqn_unique; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_account_fqn_unique UNIQUE (account_id, fully_qualified_name);


--
-- Name: datasets datasets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_pkey PRIMARY KEY (id);


--
-- Name: diagram_datasets diagram_datasets_diagram_id_dataset_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagram_datasets
    ADD CONSTRAINT diagram_datasets_diagram_id_dataset_id_key UNIQUE (diagram_id, dataset_id);


--
-- Name: diagram_datasets diagram_datasets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagram_datasets
    ADD CONSTRAINT diagram_datasets_pkey PRIMARY KEY (id);


--
-- Name: diagrams diagrams_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_pkey PRIMARY KEY (id);


--
-- Name: diagrams diagrams_workspace_id_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_workspace_id_name_key UNIQUE (workspace_id, name);


--
-- Name: environments environments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_pkey PRIMARY KEY (id);


--
-- Name: environments environments_project_id_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_project_id_name_key UNIQUE (project_id, name);


--
-- Name: invitations invitations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_pkey PRIMARY KEY (id);


--
-- Name: invitations invitations_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_token_key UNIQUE (token);


--
-- Name: lineage lineage_downstream_column_id_upstream_column_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_downstream_column_id_upstream_column_id_key UNIQUE (downstream_column_id, upstream_column_id);


--
-- Name: lineage lineage_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_pkey PRIMARY KEY (id);


--
-- Name: macros macros_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.macros
    ADD CONSTRAINT macros_name_key UNIQUE (name);


--
-- Name: macros macros_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.macros
    ADD CONSTRAINT macros_pkey PRIMARY KEY (id);


--
-- Name: payments payments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_pkey PRIMARY KEY (id);


--
-- Name: payments payments_stripe_payment_intent_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_stripe_payment_intent_id_key UNIQUE (stripe_payment_intent_id);


--
-- Name: project_users project_users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.project_users
    ADD CONSTRAINT project_users_pkey PRIMARY KEY (id);


--
-- Name: project_users project_users_project_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.project_users
    ADD CONSTRAINT project_users_project_id_user_id_key UNIQUE (project_id, user_id);


--
-- Name: projects projects_account_id_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_account_id_name_key UNIQUE (account_id, name);


--
-- Name: projects projects_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: source_control_commits source_control_commits_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.source_control_commits
    ADD CONSTRAINT source_control_commits_pkey PRIMARY KEY (id);


--
-- Name: subscription_plans subscription_plans_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscription_plans
    ADD CONSTRAINT subscription_plans_name_key UNIQUE (name);


--
-- Name: subscription_plans subscription_plans_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscription_plans
    ADD CONSTRAINT subscription_plans_pkey PRIMARY KEY (id);


--
-- Name: subscription_plans subscription_plans_slug_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscription_plans
    ADD CONSTRAINT subscription_plans_slug_key UNIQUE (slug);


--
-- Name: subscriptions subscriptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_pkey PRIMARY KEY (id);


--
-- Name: subscriptions subscriptions_stripe_subscription_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_stripe_subscription_id_key UNIQUE (stripe_subscription_id);


--
-- Name: template_fragments template_fragments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.template_fragments
    ADD CONSTRAINT template_fragments_pkey PRIMARY KEY (id);


--
-- Name: template_fragments template_fragments_template_id_injection_point_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.template_fragments
    ADD CONSTRAINT template_fragments_template_id_injection_point_name_key UNIQUE (template_id, injection_point_name);


--
-- Name: templates templates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.templates
    ADD CONSTRAINT templates_pkey PRIMARY KEY (id);


--
-- Name: usage_events usage_events_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_events
    ADD CONSTRAINT usage_events_pkey PRIMARY KEY (id);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: workspace_datasets workspace_datasets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_datasets
    ADD CONSTRAINT workspace_datasets_pkey PRIMARY KEY (id);


--
-- Name: workspace_datasets workspace_datasets_workspace_id_dataset_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_datasets
    ADD CONSTRAINT workspace_datasets_workspace_id_dataset_id_key UNIQUE (workspace_id, dataset_id);


--
-- Name: workspace_users workspace_users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_users
    ADD CONSTRAINT workspace_users_pkey PRIMARY KEY (id);


--
-- Name: workspace_users workspace_users_workspace_id_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_users
    ADD CONSTRAINT workspace_users_workspace_id_user_id_key UNIQUE (workspace_id, user_id);


--
-- Name: workspaces workspaces_account_id_project_id_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_account_id_project_id_name_key UNIQUE (account_id, project_id, name);


--
-- Name: workspaces workspaces_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_pkey PRIMARY KEY (id);


--
-- Name: messages messages_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE ONLY realtime.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: subscription pk_subscription; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.subscription
    ADD CONSTRAINT pk_subscription PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: buckets_analytics buckets_analytics_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets_analytics
    ADD CONSTRAINT buckets_analytics_pkey PRIMARY KEY (id);


--
-- Name: buckets buckets_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets
    ADD CONSTRAINT buckets_pkey PRIMARY KEY (id);


--
-- Name: migrations migrations_name_key; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_name_key UNIQUE (name);


--
-- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (id);


--
-- Name: objects objects_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT objects_pkey PRIMARY KEY (id);


--
-- Name: prefixes prefixes_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.prefixes
    ADD CONSTRAINT prefixes_pkey PRIMARY KEY (bucket_id, level, name);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id);


--
-- Name: audit_logs_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);


--
-- Name: confirmation_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_current_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_new_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]*$'::text);


--
-- Name: factor_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at);


--
-- Name: flow_state_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC);


--
-- Name: identities_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops);


--
-- Name: INDEX identities_email_idx; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.identities_email_idx IS 'Auth: Ensures indexed queries on the email column';


--
-- Name: identities_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id);


--
-- Name: idx_auth_code; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code);


--
-- Name: idx_user_id_auth_method; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method);


--
-- Name: mfa_challenge_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC);


--
-- Name: mfa_factors_user_friendly_name_unique; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text);


--
-- Name: mfa_factors_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id);


--
-- Name: oauth_auth_pending_exp_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_auth_pending_exp_idx ON auth.oauth_authorizations USING btree (expires_at) WHERE (status = 'pending'::auth.oauth_authorization_status);


--
-- Name: oauth_clients_deleted_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_clients_deleted_at_idx ON auth.oauth_clients USING btree (deleted_at);


--
-- Name: oauth_consents_active_client_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_active_client_idx ON auth.oauth_consents USING btree (client_id) WHERE (revoked_at IS NULL);


--
-- Name: oauth_consents_active_user_client_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_active_user_client_idx ON auth.oauth_consents USING btree (user_id, client_id) WHERE (revoked_at IS NULL);


--
-- Name: oauth_consents_user_order_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_user_order_idx ON auth.oauth_consents USING btree (user_id, granted_at DESC);


--
-- Name: one_time_tokens_relates_to_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to);


--
-- Name: one_time_tokens_token_hash_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash);


--
-- Name: one_time_tokens_user_id_token_type_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type);


--
-- Name: reauthentication_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: recovery_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: refresh_tokens_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id);


--
-- Name: refresh_tokens_instance_id_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id);


--
-- Name: refresh_tokens_parent_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent);


--
-- Name: refresh_tokens_session_id_revoked_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked);


--
-- Name: refresh_tokens_updated_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC);


--
-- Name: saml_providers_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id);


--
-- Name: saml_relay_states_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC);


--
-- Name: saml_relay_states_for_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email);


--
-- Name: saml_relay_states_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id);


--
-- Name: sessions_not_after_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC);


--
-- Name: sessions_oauth_client_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_oauth_client_id_idx ON auth.sessions USING btree (oauth_client_id);


--
-- Name: sessions_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id);


--
-- Name: sso_domains_domain_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain));


--
-- Name: sso_domains_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id);


--
-- Name: sso_providers_resource_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id));


--
-- Name: sso_providers_resource_id_pattern_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_providers_resource_id_pattern_idx ON auth.sso_providers USING btree (resource_id text_pattern_ops);


--
-- Name: unique_phone_factor_per_user; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone);


--
-- Name: user_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at);


--
-- Name: users_email_partial_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false);


--
-- Name: INDEX users_email_partial_key; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.users_email_partial_key IS 'Auth: A partial unique index that applies only when is_sso_user is false';


--
-- Name: users_instance_id_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text));


--
-- Name: users_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id);


--
-- Name: users_is_anonymous_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous);


--
-- Name: idx_account_users_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_account ON public.account_users USING btree (account_id);


--
-- Name: idx_account_users_account_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_account_active ON public.account_users USING btree (account_id, is_active) WHERE (is_active = true);


--
-- Name: idx_account_users_deactivated; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_deactivated ON public.account_users USING btree (deactivated_at) WHERE (deactivated_at IS NOT NULL);


--
-- Name: idx_account_users_invited_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_invited_by ON public.account_users USING btree (invited_by);


--
-- Name: idx_account_users_is_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_is_active ON public.account_users USING btree (is_active);


--
-- Name: idx_account_users_role; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_role ON public.account_users USING btree (account_id, role);


--
-- Name: idx_account_users_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_user ON public.account_users USING btree (user_id);


--
-- Name: idx_account_users_user_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_account_users_user_active ON public.account_users USING btree (user_id, is_active) WHERE (is_active = true);


--
-- Name: idx_accounts_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_active ON public.accounts USING btree (id, account_type) WHERE (deleted_at IS NULL);


--
-- Name: idx_accounts_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_deleted ON public.accounts USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_accounts_is_verified; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_is_verified ON public.accounts USING btree (is_verified) WHERE (is_verified = false);


--
-- Name: idx_accounts_slug; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_slug ON public.accounts USING btree (slug);


--
-- Name: idx_accounts_subscription; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_subscription ON public.accounts USING btree (subscription_status);


--
-- Name: idx_accounts_trial_end; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_trial_end ON public.accounts USING btree (trial_end_date) WHERE (trial_end_date IS NOT NULL);


--
-- Name: idx_accounts_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_accounts_type ON public.accounts USING btree (account_type);


--
-- Name: idx_api_tokens_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_account ON public.api_tokens USING btree (account_id);


--
-- Name: idx_api_tokens_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_active ON public.api_tokens USING btree (account_id, user_id, is_active) WHERE (is_active = true);


--
-- Name: idx_api_tokens_expires; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_expires ON public.api_tokens USING btree (expires_at) WHERE ((expires_at IS NOT NULL) AND (is_active = true));


--
-- Name: idx_api_tokens_hash; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_hash ON public.api_tokens USING btree (token_hash);


--
-- Name: idx_api_tokens_last_used; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_last_used ON public.api_tokens USING btree (last_used_at DESC);


--
-- Name: idx_api_tokens_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_user ON public.api_tokens USING btree (user_id);


--
-- Name: idx_api_tokens_user_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_api_tokens_user_active ON public.api_tokens USING btree (user_id, is_active, created_at DESC) WHERE (is_active = true);


--
-- Name: idx_audit_logs_dataset; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_dataset ON public.audit_logs USING btree (dataset_id);


--
-- Name: idx_audit_logs_entity; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_entity ON public.audit_logs USING btree (entity_type, entity_id);


--
-- Name: idx_audit_logs_uncommitted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_uncommitted ON public.audit_logs USING btree (committed_in_sha) WHERE (committed_in_sha IS NULL);


--
-- Name: idx_audit_logs_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_audit_logs_workspace ON public.audit_logs USING btree (workspace_id);


--
-- Name: idx_columns_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_columns_active ON public.columns USING btree (dataset_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_columns_dataset; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_columns_dataset ON public.columns USING btree (dataset_id);


--
-- Name: idx_columns_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_columns_deleted ON public.columns USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_columns_fqn; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_columns_fqn ON public.columns USING btree (fqn);


--
-- Name: idx_columns_reference; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_columns_reference ON public.columns USING btree (reference_column_id);


--
-- Name: idx_configurations_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_configurations_active ON public.configurations USING btree (id) WHERE (deleted_at IS NULL);


--
-- Name: idx_configurations_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_configurations_deleted ON public.configurations USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_connection_metadata_connection; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connection_metadata_connection ON public.connection_metadata_cache USING btree (connection_id);


--
-- Name: idx_connection_metadata_stale; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connection_metadata_stale ON public.connection_metadata_cache USING btree (is_stale) WHERE (is_stale = true);


--
-- Name: idx_connection_metadata_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connection_metadata_type ON public.connection_metadata_cache USING btree (metadata_type);


--
-- Name: idx_connections_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connections_account ON public.connections USING btree (account_id);


--
-- Name: idx_connections_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connections_active ON public.connections USING btree (account_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_connections_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connections_deleted ON public.connections USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_connections_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connections_owner ON public.connections USING btree (owner_id);


--
-- Name: idx_connections_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connections_status ON public.connections USING btree (is_active);


--
-- Name: idx_connections_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_connections_type ON public.connections USING btree (connection_type);


--
-- Name: idx_datasets_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_account ON public.datasets USING btree (account_id);


--
-- Name: idx_datasets_account_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_account_id ON public.datasets USING btree (account_id);


--
-- Name: idx_datasets_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_active ON public.datasets USING btree (account_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_datasets_connection; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_connection ON public.datasets USING btree (connection_id);


--
-- Name: idx_datasets_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_deleted ON public.datasets USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_datasets_fully_qualified_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_fully_qualified_name ON public.datasets USING btree (fully_qualified_name);


--
-- Name: idx_datasets_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_owner ON public.datasets USING btree (owner_id);


--
-- Name: idx_datasets_owner_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_owner_id ON public.datasets USING btree (owner_id);


--
-- Name: idx_datasets_schema; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_schema ON public.datasets USING btree (schema);


--
-- Name: idx_datasets_sync_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_sync_status ON public.datasets USING btree (sync_status);


--
-- Name: idx_datasets_uncommitted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_uncommitted ON public.datasets USING btree (has_uncommitted_changes) WHERE (has_uncommitted_changes = true);


--
-- Name: idx_datasets_visibility; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_datasets_visibility ON public.datasets USING btree (visibility);


--
-- Name: idx_diagram_datasets_added_by; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagram_datasets_added_by ON public.diagram_datasets USING btree (created_by);


--
-- Name: idx_diagram_datasets_dataset; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagram_datasets_dataset ON public.diagram_datasets USING btree (dataset_id);


--
-- Name: idx_diagram_datasets_diagram; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagram_datasets_diagram ON public.diagram_datasets USING btree (diagram_id);


--
-- Name: idx_diagrams_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagrams_account ON public.diagrams USING btree (account_id);


--
-- Name: idx_diagrams_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagrams_owner ON public.diagrams USING btree (owner_id);


--
-- Name: idx_diagrams_template; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagrams_template ON public.diagrams USING btree (is_template) WHERE (is_template = true);


--
-- Name: idx_diagrams_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagrams_type ON public.diagrams USING btree (diagram_type);


--
-- Name: idx_diagrams_visibility; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagrams_visibility ON public.diagrams USING btree (visibility);


--
-- Name: idx_diagrams_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_diagrams_workspace ON public.diagrams USING btree (workspace_id);


--
-- Name: idx_environments_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_environments_account ON public.environments USING btree (account_id);


--
-- Name: idx_environments_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_environments_active ON public.environments USING btree (account_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_environments_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_environments_deleted ON public.environments USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_environments_project; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_environments_project ON public.environments USING btree (project_id);


--
-- Name: idx_environments_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_environments_workspace ON public.environments USING btree (workspace_id);


--
-- Name: idx_invitations_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_account ON public.invitations USING btree (account_id);


--
-- Name: idx_invitations_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_active ON public.invitations USING btree (account_id, status, expires_at) WHERE ((status)::text = 'pending'::text);


--
-- Name: idx_invitations_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_deleted ON public.invitations USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_invitations_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_email ON public.invitations USING btree (email);


--
-- Name: idx_invitations_expires; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_expires ON public.invitations USING btree (expires_at);


--
-- Name: idx_invitations_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_status ON public.invitations USING btree (status);


--
-- Name: idx_invitations_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_invitations_token ON public.invitations USING btree (token);


--
-- Name: idx_lineage_downstream_column; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_lineage_downstream_column ON public.lineage USING btree (downstream_column_id);


--
-- Name: idx_lineage_downstream_dataset; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_lineage_downstream_dataset ON public.lineage USING btree (downstream_dataset_id);


--
-- Name: idx_lineage_upstream_column; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_lineage_upstream_column ON public.lineage USING btree (upstream_column_id);


--
-- Name: idx_lineage_upstream_dataset; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_lineage_upstream_dataset ON public.lineage USING btree (upstream_dataset_id);


--
-- Name: idx_lineage_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_lineage_workspace ON public.lineage USING btree (workspace_id);


--
-- Name: idx_macros_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_macros_active ON public.macros USING btree (id) WHERE (deleted_at IS NULL);


--
-- Name: idx_macros_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_macros_deleted ON public.macros USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_payments_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_account ON public.payments USING btree (account_id);


--
-- Name: idx_payments_account_processed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_account_processed ON public.payments USING btree (account_id, processed_at DESC);


--
-- Name: idx_payments_account_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_account_status ON public.payments USING btree (account_id, status);


--
-- Name: idx_payments_processed; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_processed ON public.payments USING btree (processed_at DESC);


--
-- Name: idx_payments_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_status ON public.payments USING btree (status);


--
-- Name: idx_payments_stripe_invoice; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_stripe_invoice ON public.payments USING btree (stripe_invoice_id);


--
-- Name: idx_payments_stripe_payment_intent; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_stripe_payment_intent ON public.payments USING btree (stripe_payment_intent_id);


--
-- Name: idx_payments_subscription; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_payments_subscription ON public.payments USING btree (subscription_id);


--
-- Name: idx_project_users_project; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_project_users_project ON public.project_users USING btree (project_id);


--
-- Name: idx_project_users_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_project_users_user ON public.project_users USING btree (user_id);


--
-- Name: idx_projects_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_account ON public.projects USING btree (account_id);


--
-- Name: idx_projects_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_active ON public.projects USING btree (account_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_projects_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_deleted ON public.projects USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_projects_has_credentials; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_has_credentials ON public.projects USING btree (id) WHERE (source_control_access_token_encrypted IS NOT NULL);


--
-- Name: idx_projects_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_owner ON public.projects USING btree (owner_id);


--
-- Name: idx_projects_source_control_provider; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_source_control_provider ON public.projects USING btree (source_control_provider);


--
-- Name: idx_projects_source_control_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_source_control_status ON public.projects USING btree (source_control_connection_status);


--
-- Name: idx_projects_token_expires_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_token_expires_at ON public.projects USING btree (source_control_token_expires_at) WHERE (source_control_token_expires_at IS NOT NULL);


--
-- Name: idx_projects_visibility; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_visibility ON public.projects USING btree (visibility);


--
-- Name: idx_source_control_commits_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_source_control_commits_account ON public.source_control_commits USING btree (account_id);


--
-- Name: idx_source_control_commits_committed_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_source_control_commits_committed_at ON public.source_control_commits USING btree (committed_at);


--
-- Name: idx_source_control_commits_project; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_source_control_commits_project ON public.source_control_commits USING btree (project_id);


--
-- Name: idx_source_control_commits_sha; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_source_control_commits_sha ON public.source_control_commits USING btree (commit_sha);


--
-- Name: idx_source_control_commits_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_source_control_commits_workspace ON public.source_control_commits USING btree (workspace_id);


--
-- Name: idx_subscription_plans_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscription_plans_active ON public.subscription_plans USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_subscription_plans_public; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscription_plans_public ON public.subscription_plans USING btree (is_public) WHERE (is_public = true);


--
-- Name: idx_subscription_plans_tier; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscription_plans_tier ON public.subscription_plans USING btree (tier);


--
-- Name: idx_subscriptions_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_account ON public.subscriptions USING btree (account_id);


--
-- Name: idx_subscriptions_account_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_account_status ON public.subscriptions USING btree (account_id, status);


--
-- Name: idx_subscriptions_period_end; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_period_end ON public.subscriptions USING btree (current_period_end);


--
-- Name: idx_subscriptions_plan; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_plan ON public.subscriptions USING btree (plan_id);


--
-- Name: idx_subscriptions_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_status ON public.subscriptions USING btree (status);


--
-- Name: idx_subscriptions_stripe; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_stripe ON public.subscriptions USING btree (stripe_subscription_id);


--
-- Name: idx_subscriptions_trial_end; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_subscriptions_trial_end ON public.subscriptions USING btree (trial_end) WHERE (trial_end IS NOT NULL);


--
-- Name: idx_templates_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_templates_active ON public.templates USING btree (id) WHERE (deleted_at IS NULL);


--
-- Name: idx_templates_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_templates_deleted ON public.templates USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_usage_events_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_account ON public.usage_events USING btree (account_id);


--
-- Name: idx_usage_events_account_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_account_created ON public.usage_events USING btree (account_id, created_at DESC);


--
-- Name: idx_usage_events_account_type_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_account_type_created ON public.usage_events USING btree (account_id, event_type, created_at DESC);


--
-- Name: idx_usage_events_ai_requests; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_ai_requests ON public.usage_events USING btree (account_id, created_at DESC) WHERE ((event_type)::text = 'ai_request'::text);


--
-- Name: idx_usage_events_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_category ON public.usage_events USING btree (event_category);


--
-- Name: idx_usage_events_created; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_created ON public.usage_events USING btree (created_at DESC);


--
-- Name: idx_usage_events_resource; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_resource ON public.usage_events USING btree (resource_type, resource_id);


--
-- Name: idx_usage_events_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_type ON public.usage_events USING btree (event_type);


--
-- Name: idx_usage_events_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_usage_events_user ON public.usage_events USING btree (user_id);


--
-- Name: idx_users_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_active ON public.users USING btree (email) WHERE (deleted_at IS NULL);


--
-- Name: idx_users_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_deleted ON public.users USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_users_email; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_email ON public.users USING btree (email);


--
-- Name: idx_users_email_verification_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_email_verification_token ON public.users USING btree (email_verification_token) WHERE (email_verification_token IS NOT NULL);


--
-- Name: idx_users_email_verified; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_email_verified ON public.users USING btree (is_email_verified) WHERE (is_email_verified = false);


--
-- Name: idx_users_last_seen_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_last_seen_at ON public.users USING btree (last_seen_at DESC NULLS LAST);


--
-- Name: idx_users_locked_accounts; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_locked_accounts ON public.users USING btree (account_locked_until) WHERE (account_locked_until IS NOT NULL);


--
-- Name: idx_users_password_reset_token; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_users_password_reset_token ON public.users USING btree (password_reset_token) WHERE (password_reset_token IS NOT NULL);


--
-- Name: idx_workspace_datasets_dataset; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspace_datasets_dataset ON public.workspace_datasets USING btree (dataset_id);


--
-- Name: idx_workspace_datasets_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspace_datasets_workspace ON public.workspace_datasets USING btree (workspace_id);


--
-- Name: idx_workspace_users_user; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspace_users_user ON public.workspace_users USING btree (user_id);


--
-- Name: idx_workspace_users_workspace; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspace_users_workspace ON public.workspace_users USING btree (workspace_id);


--
-- Name: idx_workspaces_account; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspaces_account ON public.workspaces USING btree (account_id);


--
-- Name: idx_workspaces_active; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspaces_active ON public.workspaces USING btree (account_id) WHERE (deleted_at IS NULL);


--
-- Name: idx_workspaces_deleted; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspaces_deleted ON public.workspaces USING btree (deleted_at) WHERE (deleted_at IS NOT NULL);


--
-- Name: idx_workspaces_owner; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspaces_owner ON public.workspaces USING btree (owner_id);


--
-- Name: idx_workspaces_project; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_workspaces_project ON public.workspaces USING btree (project_id);


--
-- Name: ix_realtime_subscription_entity; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity);


--
-- Name: messages_inserted_at_topic_index; Type: INDEX; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE INDEX messages_inserted_at_topic_index ON ONLY realtime.messages USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: subscription_subscription_id_entity_filters_key; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_key ON realtime.subscription USING btree (subscription_id, entity, filters);


--
-- Name: bname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name);


--
-- Name: bucketid_objname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name);


--
-- Name: idx_multipart_uploads_list; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at);


--
-- Name: idx_name_bucket_level_unique; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX idx_name_bucket_level_unique ON storage.objects USING btree (name COLLATE "C", bucket_id, level);


--
-- Name: idx_objects_bucket_id_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C");


--
-- Name: idx_objects_lower_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_lower_name ON storage.objects USING btree ((path_tokens[level]), lower(name) text_pattern_ops, bucket_id, level);


--
-- Name: idx_prefixes_lower_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_prefixes_lower_name ON storage.prefixes USING btree (bucket_id, level, ((string_to_array(name, '/'::text))[level]), lower(name) text_pattern_ops);


--
-- Name: name_prefix_search; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops);


--
-- Name: objects_bucket_id_level_idx; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX objects_bucket_id_level_idx ON storage.objects USING btree (bucket_id, level, name COLLATE "C");


--
-- Name: users on_auth_user_created; Type: TRIGGER; Schema: auth; Owner: supabase_auth_admin
--

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


--
-- Name: datasets datasets_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER datasets_updated_at BEFORE UPDATE ON public.datasets FOR EACH ROW EXECUTE FUNCTION public.update_datasets_updated_at();


--
-- Name: projects project_owner_to_users; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER project_owner_to_users AFTER INSERT ON public.projects FOR EACH ROW EXECUTE FUNCTION public.add_project_owner_to_project_users();


--
-- Name: TRIGGER project_owner_to_users ON projects; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TRIGGER project_owner_to_users ON public.projects IS 'Add project owner to project_users table automatically';


--
-- Name: projects projects_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: TRIGGER projects_updated_at ON projects; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TRIGGER projects_updated_at ON public.projects IS 'Automatically update updated_at when project is modified';


--
-- Name: account_users trg_account_users_count; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_account_users_count AFTER INSERT OR DELETE OR UPDATE ON public.account_users FOR EACH ROW EXECUTE FUNCTION public.update_account_user_count();


--
-- Name: datasets trg_datasets_count; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_datasets_count AFTER INSERT OR DELETE OR UPDATE ON public.datasets FOR EACH ROW EXECUTE FUNCTION public.update_account_dataset_count();


--
-- Name: projects trg_projects_count; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_projects_count AFTER INSERT OR DELETE OR UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_account_project_count();


--
-- Name: account_users trigger_account_users_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_account_users_updated_at BEFORE UPDATE ON public.account_users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: accounts trigger_accounts_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_accounts_updated_at BEFORE UPDATE ON public.accounts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: columns trigger_columns_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_columns_updated_at BEFORE UPDATE ON public.columns FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: connections trigger_connections_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_connections_updated_at BEFORE UPDATE ON public.connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: datasets trigger_datasets_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_datasets_updated_at BEFORE UPDATE ON public.datasets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: diagram_datasets trigger_diagram_datasets_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_diagram_datasets_updated_at BEFORE UPDATE ON public.diagram_datasets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: diagrams trigger_diagrams_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_diagrams_updated_at BEFORE UPDATE ON public.diagrams FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: projects trigger_projects_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: datasets trigger_set_dataset_owner; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_set_dataset_owner BEFORE INSERT ON public.datasets FOR EACH ROW EXECUTE FUNCTION public.set_dataset_owner();


--
-- Name: account_users trigger_update_account_user_count; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_account_user_count AFTER INSERT OR DELETE OR UPDATE ON public.account_users FOR EACH ROW EXECUTE FUNCTION public.update_account_user_count();


--
-- Name: datasets trigger_update_dataset_fqn; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_dataset_fqn BEFORE INSERT OR UPDATE OF connection_id, schema, name ON public.datasets FOR EACH ROW EXECUTE FUNCTION public.update_dataset_fqn();


--
-- Name: users trigger_users_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: workspace_datasets trigger_workspace_datasets_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_workspace_datasets_updated_at BEFORE UPDATE ON public.workspace_datasets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: workspaces trigger_workspaces_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_workspaces_updated_at BEFORE UPDATE ON public.workspaces FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: accounts update_accounts_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_accounts_updated_at BEFORE UPDATE ON public.accounts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: columns update_columns_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_columns_updated_at BEFORE UPDATE ON public.columns FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: configurations update_configurations_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_configurations_updated_at BEFORE UPDATE ON public.configurations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: connection_metadata_cache update_connection_metadata_cache_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_connection_metadata_cache_updated_at BEFORE UPDATE ON public.connection_metadata_cache FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: connections update_connections_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_connections_updated_at BEFORE UPDATE ON public.connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: environments update_environments_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_environments_updated_at BEFORE UPDATE ON public.environments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: macros update_macros_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_macros_updated_at BEFORE UPDATE ON public.macros FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: projects update_projects_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: subscriptions update_subscriptions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: template_fragments update_template_fragments_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_template_fragments_updated_at BEFORE UPDATE ON public.template_fragments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: templates update_templates_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON public.templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: users update_users_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: workspaces update_workspaces_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_workspaces_updated_at BEFORE UPDATE ON public.workspaces FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: usage_events usage_event_counter_update_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER usage_event_counter_update_trigger AFTER INSERT ON public.usage_events FOR EACH ROW EXECUTE FUNCTION public.update_account_counters_on_usage_event();


--
-- Name: workspaces workspace_owner_to_users; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER workspace_owner_to_users AFTER INSERT ON public.workspaces FOR EACH ROW EXECUTE FUNCTION public.add_workspace_owner_to_workspace_users();


--
-- Name: TRIGGER workspace_owner_to_users ON workspaces; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TRIGGER workspace_owner_to_users ON public.workspaces IS 'Add workspace owner to workspace_users table automatically';


--
-- Name: workspaces workspaces_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER workspaces_updated_at BEFORE UPDATE ON public.workspaces FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: TRIGGER workspaces_updated_at ON workspaces; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TRIGGER workspaces_updated_at ON public.workspaces IS 'Automatically update updated_at when workspace is modified';


--
-- Name: subscription tr_check_filters; Type: TRIGGER; Schema: realtime; Owner: supabase_admin
--

CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();


--
-- Name: buckets enforce_bucket_name_length_trigger; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER enforce_bucket_name_length_trigger BEFORE INSERT OR UPDATE OF name ON storage.buckets FOR EACH ROW EXECUTE FUNCTION storage.enforce_bucket_name_length();


--
-- Name: objects objects_delete_delete_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


--
-- Name: objects objects_insert_create_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();


--
-- Name: objects objects_update_create_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();


--
-- Name: prefixes prefixes_create_hierarchy; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();


--
-- Name: prefixes prefixes_delete_hierarchy; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


--
-- Name: objects update_objects_updated_at; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();


--
-- Name: identities identities_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: mfa_challenges mfa_challenges_auth_factor_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE;


--
-- Name: mfa_factors mfa_factors_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: oauth_authorizations oauth_authorizations_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: oauth_authorizations oauth_authorizations_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: oauth_consents oauth_consents_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: oauth_consents oauth_consents_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: one_time_tokens one_time_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: refresh_tokens refresh_tokens_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: saml_providers saml_providers_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_flow_state_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_oauth_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_oauth_client_id_fkey FOREIGN KEY (oauth_client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: sso_domains sso_domains_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: account_users account_users_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: account_users account_users_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: account_users account_users_deactivated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_deactivated_by_fkey FOREIGN KEY (deactivated_by) REFERENCES public.users(id);


--
-- Name: account_users account_users_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES public.users(id);


--
-- Name: account_users account_users_role_changed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_role_changed_by_fkey FOREIGN KEY (role_changed_by) REFERENCES public.users(id);


--
-- Name: account_users account_users_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: account_users account_users_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.account_users
    ADD CONSTRAINT account_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: accounts accounts_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: accounts accounts_current_plan_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_current_plan_id_fkey FOREIGN KEY (current_plan_id) REFERENCES public.subscription_plans(id) ON DELETE SET NULL;


--
-- Name: accounts accounts_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: accounts accounts_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.accounts
    ADD CONSTRAINT accounts_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: api_tokens api_tokens_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: api_tokens api_tokens_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: api_tokens api_tokens_revoked_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_revoked_by_fkey FOREIGN KEY (revoked_by) REFERENCES public.users(id);


--
-- Name: api_tokens api_tokens_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: api_tokens api_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: audit_logs audit_logs_changed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_changed_by_fkey FOREIGN KEY (changed_by) REFERENCES public.users(id);


--
-- Name: audit_logs audit_logs_dataset_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_dataset_id_fkey FOREIGN KEY (dataset_id) REFERENCES public.datasets(id) ON DELETE CASCADE;


--
-- Name: audit_logs audit_logs_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id);


--
-- Name: columns columns_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: columns columns_dataset_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_dataset_id_fkey FOREIGN KEY (dataset_id) REFERENCES public.datasets(id) ON DELETE CASCADE;


--
-- Name: columns columns_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: columns columns_reference_column_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_reference_column_id_fkey FOREIGN KEY (reference_column_id) REFERENCES public.columns(id) ON DELETE SET NULL;


--
-- Name: columns columns_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.columns
    ADD CONSTRAINT columns_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: configurations configurations_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configurations
    ADD CONSTRAINT configurations_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configurations configurations_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configurations
    ADD CONSTRAINT configurations_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: configurations configurations_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configurations
    ADD CONSTRAINT configurations_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: configurations configurations_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configurations
    ADD CONSTRAINT configurations_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id);


--
-- Name: connection_metadata_cache connection_metadata_cache_connection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connection_metadata_cache
    ADD CONSTRAINT connection_metadata_cache_connection_id_fkey FOREIGN KEY (connection_id) REFERENCES public.connections(id) ON DELETE CASCADE;


--
-- Name: connection_metadata_cache connection_metadata_cache_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connection_metadata_cache
    ADD CONSTRAINT connection_metadata_cache_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: connection_metadata_cache connection_metadata_cache_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connection_metadata_cache
    ADD CONSTRAINT connection_metadata_cache_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: connections connections_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: connections connections_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: connections connections_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: connections connections_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.users(id);


--
-- Name: connections connections_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.connections
    ADD CONSTRAINT connections_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: datasets datasets_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: datasets datasets_connection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_connection_id_fkey FOREIGN KEY (connection_id) REFERENCES public.connections(id) ON DELETE SET NULL;


--
-- Name: datasets datasets_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: datasets datasets_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: datasets datasets_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.users(id);


--
-- Name: datasets datasets_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.datasets
    ADD CONSTRAINT datasets_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: diagram_datasets diagram_datasets_added_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagram_datasets
    ADD CONSTRAINT diagram_datasets_added_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: diagram_datasets diagram_datasets_dataset_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagram_datasets
    ADD CONSTRAINT diagram_datasets_dataset_id_fkey FOREIGN KEY (dataset_id) REFERENCES public.datasets(id) ON DELETE CASCADE;


--
-- Name: diagram_datasets diagram_datasets_diagram_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagram_datasets
    ADD CONSTRAINT diagram_datasets_diagram_id_fkey FOREIGN KEY (diagram_id) REFERENCES public.diagrams(id) ON DELETE CASCADE;


--
-- Name: diagram_datasets diagram_datasets_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagram_datasets
    ADD CONSTRAINT diagram_datasets_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: diagrams diagrams_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: diagrams diagrams_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: diagrams diagrams_last_modified_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_last_modified_by_fkey FOREIGN KEY (last_modified_by) REFERENCES public.users(id);


--
-- Name: diagrams diagrams_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.users(id);


--
-- Name: diagrams diagrams_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: diagrams diagrams_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.diagrams
    ADD CONSTRAINT diagrams_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE;


--
-- Name: environments environments_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: environments environments_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: environments environments_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: environments environments_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- Name: environments environments_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: environments environments_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.environments
    ADD CONSTRAINT environments_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id);


--
-- Name: usage_events fk_usage_events_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_events
    ADD CONSTRAINT fk_usage_events_user FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: invitations invitations_accepted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_accepted_by_fkey FOREIGN KEY (accepted_by) REFERENCES public.users(id);


--
-- Name: invitations invitations_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: invitations invitations_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: invitations invitations_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: invitations invitations_invited_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_invited_by_fkey FOREIGN KEY (invited_by) REFERENCES public.users(id);


--
-- Name: invitations invitations_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invitations
    ADD CONSTRAINT invitations_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: lineage lineage_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: lineage lineage_downstream_column_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_downstream_column_id_fkey FOREIGN KEY (downstream_column_id) REFERENCES public.columns(id) ON DELETE CASCADE;


--
-- Name: lineage lineage_downstream_dataset_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_downstream_dataset_id_fkey FOREIGN KEY (downstream_dataset_id) REFERENCES public.datasets(id) ON DELETE CASCADE;


--
-- Name: lineage lineage_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: lineage lineage_upstream_column_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_upstream_column_id_fkey FOREIGN KEY (upstream_column_id) REFERENCES public.columns(id) ON DELETE CASCADE;


--
-- Name: lineage lineage_upstream_dataset_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_upstream_dataset_id_fkey FOREIGN KEY (upstream_dataset_id) REFERENCES public.datasets(id) ON DELETE CASCADE;


--
-- Name: lineage lineage_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lineage
    ADD CONSTRAINT lineage_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id);


--
-- Name: macros macros_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.macros
    ADD CONSTRAINT macros_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: macros macros_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.macros
    ADD CONSTRAINT macros_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: macros macros_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.macros
    ADD CONSTRAINT macros_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: payments payments_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: payments payments_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: payments payments_subscription_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_subscription_id_fkey FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE SET NULL;


--
-- Name: payments payments_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: project_users project_users_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.project_users
    ADD CONSTRAINT project_users_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: project_users project_users_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.project_users
    ADD CONSTRAINT project_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: projects projects_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: projects projects_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: projects projects_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: projects projects_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.users(id);


--
-- Name: projects projects_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: source_control_commits source_control_commits_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.source_control_commits
    ADD CONSTRAINT source_control_commits_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: source_control_commits source_control_commits_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.source_control_commits
    ADD CONSTRAINT source_control_commits_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: source_control_commits source_control_commits_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.source_control_commits
    ADD CONSTRAINT source_control_commits_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- Name: source_control_commits source_control_commits_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.source_control_commits
    ADD CONSTRAINT source_control_commits_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: source_control_commits source_control_commits_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.source_control_commits
    ADD CONSTRAINT source_control_commits_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id);


--
-- Name: subscription_plans subscription_plans_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscription_plans
    ADD CONSTRAINT subscription_plans_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: subscription_plans subscription_plans_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscription_plans
    ADD CONSTRAINT subscription_plans_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: subscriptions subscriptions_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: subscriptions subscriptions_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: subscriptions subscriptions_plan_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_plan_id_fkey FOREIGN KEY (plan_id) REFERENCES public.subscription_plans(id) ON DELETE RESTRICT;


--
-- Name: subscriptions subscriptions_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: template_fragments template_fragments_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.template_fragments
    ADD CONSTRAINT template_fragments_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: template_fragments template_fragments_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.template_fragments
    ADD CONSTRAINT template_fragments_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.templates(id);


--
-- Name: template_fragments template_fragments_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.template_fragments
    ADD CONSTRAINT template_fragments_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: templates templates_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.templates
    ADD CONSTRAINT templates_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: templates templates_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.templates
    ADD CONSTRAINT templates_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: templates templates_parent_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.templates
    ADD CONSTRAINT templates_parent_template_id_fkey FOREIGN KEY (parent_template_id) REFERENCES public.templates(id);


--
-- Name: templates templates_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.templates
    ADD CONSTRAINT templates_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: usage_events usage_events_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_events
    ADD CONSTRAINT usage_events_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: usage_events usage_events_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_events
    ADD CONSTRAINT usage_events_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: usage_events usage_events_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_events
    ADD CONSTRAINT usage_events_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: users users_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: users users_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: users users_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: workspace_datasets workspace_datasets_added_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_datasets
    ADD CONSTRAINT workspace_datasets_added_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: workspace_datasets workspace_datasets_dataset_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_datasets
    ADD CONSTRAINT workspace_datasets_dataset_id_fkey FOREIGN KEY (dataset_id) REFERENCES public.datasets(id) ON DELETE CASCADE;


--
-- Name: workspace_datasets workspace_datasets_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_datasets
    ADD CONSTRAINT workspace_datasets_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: workspace_datasets workspace_datasets_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_datasets
    ADD CONSTRAINT workspace_datasets_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE;


--
-- Name: workspace_users workspace_users_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_users
    ADD CONSTRAINT workspace_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: workspace_users workspace_users_workspace_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspace_users
    ADD CONSTRAINT workspace_users_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE;


--
-- Name: workspaces workspaces_account_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_account_id_fkey FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE CASCADE;


--
-- Name: workspaces workspaces_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: workspaces workspaces_deleted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_deleted_by_fkey FOREIGN KEY (deleted_by) REFERENCES public.users(id);


--
-- Name: workspaces workspaces_owner_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.users(id);


--
-- Name: workspaces workspaces_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: workspaces workspaces_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workspaces
    ADD CONSTRAINT workspaces_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: objects objects_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: prefixes prefixes_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.prefixes
    ADD CONSTRAINT "prefixes_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_upload_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE;


--
-- Name: audit_log_entries; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.audit_log_entries ENABLE ROW LEVEL SECURITY;

--
-- Name: flow_state; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.flow_state ENABLE ROW LEVEL SECURITY;

--
-- Name: identities; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.identities ENABLE ROW LEVEL SECURITY;

--
-- Name: instances; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.instances ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_amr_claims; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_challenges; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_challenges ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_factors; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_factors ENABLE ROW LEVEL SECURITY;

--
-- Name: one_time_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.one_time_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: refresh_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_relay_states; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_relay_states ENABLE ROW LEVEL SECURITY;

--
-- Name: schema_migrations; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.schema_migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: sessions; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_domains; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_domains ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

--
-- Name: account_users Admins can add account members; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can add account members" ON public.account_users FOR INSERT WITH CHECK (((account_id IN ( SELECT account_users_1.account_id
   FROM public.account_users account_users_1
  WHERE ((account_users_1.user_id = auth.uid()) AND ((account_users_1.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])) AND (account_users_1.is_active = true)))) AND (is_active = true)));


--
-- Name: invitations Admins can create invitations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can create invitations" ON public.invitations FOR INSERT WITH CHECK ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[]))))));


--
-- Name: invitations Admins can delete invitations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can delete invitations" ON public.invitations FOR DELETE USING ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[]))))));


--
-- Name: account_users Admins can update account members; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update account members" ON public.account_users FOR UPDATE USING (((account_id IN ( SELECT account_users_1.account_id
   FROM public.account_users account_users_1
  WHERE ((account_users_1.user_id = auth.uid()) AND ((account_users_1.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])) AND (account_users_1.is_active = true)))) OR (user_id = auth.uid()))) WITH CHECK (((account_id IN ( SELECT account_users_1.account_id
   FROM public.account_users account_users_1
  WHERE ((account_users_1.user_id = auth.uid()) AND ((account_users_1.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])) AND (account_users_1.is_active = true)))) OR (user_id = auth.uid())));


--
-- Name: invitations Admins can update invitations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update invitations" ON public.invitations FOR UPDATE USING (((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[]))))) OR (((status)::text = 'pending'::text) AND (expires_at > now())))) WITH CHECK (((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[]))))) OR (((status)::text = ANY ((ARRAY['pending'::character varying, 'accepted'::character varying])::text[])) AND (expires_at > now()))));


--
-- Name: account_users Prevent hard deletes on account members; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Prevent hard deletes on account members" ON public.account_users FOR DELETE USING (false);


--
-- Name: api_tokens Users can create tokens for accounts they belong to; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create tokens for accounts they belong to" ON public.api_tokens FOR INSERT WITH CHECK (((user_id = auth.uid()) AND (account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid())))));


--
-- Name: api_tokens Users can delete their own tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their own tokens" ON public.api_tokens FOR DELETE USING (((user_id = auth.uid()) OR (account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])))))));


--
-- Name: users Users can update their own profile; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own profile" ON public.users FOR UPDATE USING ((id = auth.uid())) WITH CHECK ((id = auth.uid()));


--
-- Name: api_tokens Users can update their own tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own tokens" ON public.api_tokens FOR UPDATE USING (((user_id = auth.uid()) OR (account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])))))));


--
-- Name: account_users Users can view account members; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view account members" ON public.account_users FOR SELECT USING ((account_id IN ( SELECT account_users_1.account_id
   FROM public.account_users account_users_1
  WHERE ((account_users_1.user_id = auth.uid()) AND (account_users_1.is_active = true)))));


--
-- Name: invitations Users can view invitations for their accounts; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view invitations for their accounts" ON public.invitations FOR SELECT USING ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid()))));


--
-- Name: users Users can view their own profile; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own profile" ON public.users FOR SELECT USING (((id = auth.uid()) OR (id IN ( SELECT au2.user_id
   FROM (public.account_users au1
     JOIN public.account_users au2 ON ((au1.account_id = au2.account_id)))
  WHERE (au1.user_id = auth.uid())))));


--
-- Name: api_tokens Users can view their own tokens; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own tokens" ON public.api_tokens FOR SELECT USING (((user_id = auth.uid()) OR (account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])))))));


--
-- Name: api_tokens; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.api_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: connection_metadata_cache; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.connection_metadata_cache ENABLE ROW LEVEL SECURITY;

--
-- Name: connection_metadata_cache connection_metadata_cache_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY connection_metadata_cache_policy ON public.connection_metadata_cache USING ((connection_id IN ( SELECT connections.id
   FROM public.connections
  WHERE (connections.account_id IN ( SELECT account_users.account_id
           FROM public.account_users
          WHERE (account_users.user_id = auth.uid()))))));


--
-- Name: connections; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.connections ENABLE ROW LEVEL SECURITY;

--
-- Name: connections connections_delete_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY connections_delete_policy ON public.connections FOR DELETE USING (((owner_id = auth.uid()) OR ((( SELECT account_users.role
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND (account_users.account_id = connections.account_id))))::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[]))));


--
-- Name: connections connections_insert_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY connections_insert_policy ON public.connections FOR INSERT WITH CHECK ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid()))));


--
-- Name: connections connections_isolation_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY connections_isolation_policy ON public.connections FOR SELECT USING ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid()))));


--
-- Name: connections connections_update_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY connections_update_policy ON public.connections FOR UPDATE USING (((owner_id = auth.uid()) OR ((( SELECT account_users.role
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND (account_users.account_id = connections.account_id))))::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[]))));


--
-- Name: diagram_datasets; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.diagram_datasets ENABLE ROW LEVEL SECURITY;

--
-- Name: diagram_datasets diagram_datasets_delete_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagram_datasets_delete_policy ON public.diagram_datasets FOR DELETE USING ((diagram_id IN ( SELECT diagrams.id
   FROM public.diagrams
  WHERE (diagrams.account_id IN ( SELECT account_users.account_id
           FROM public.account_users
          WHERE (account_users.user_id = auth.uid()))))));


--
-- Name: diagram_datasets diagram_datasets_insert_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagram_datasets_insert_policy ON public.diagram_datasets FOR INSERT WITH CHECK ((diagram_id IN ( SELECT diagrams.id
   FROM public.diagrams
  WHERE (diagrams.account_id IN ( SELECT account_users.account_id
           FROM public.account_users
          WHERE (account_users.user_id = auth.uid()))))));


--
-- Name: diagram_datasets diagram_datasets_select_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagram_datasets_select_policy ON public.diagram_datasets FOR SELECT USING ((diagram_id IN ( SELECT diagrams.id
   FROM public.diagrams
  WHERE ((diagrams.account_id IN ( SELECT account_users.account_id
           FROM public.account_users
          WHERE (account_users.user_id = auth.uid()))) OR ((diagrams.visibility)::text = 'public'::text)))));


--
-- Name: diagram_datasets diagram_datasets_update_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagram_datasets_update_policy ON public.diagram_datasets FOR UPDATE USING ((diagram_id IN ( SELECT diagrams.id
   FROM public.diagrams
  WHERE (diagrams.account_id IN ( SELECT account_users.account_id
           FROM public.account_users
          WHERE (account_users.user_id = auth.uid()))))));


--
-- Name: diagrams; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.diagrams ENABLE ROW LEVEL SECURITY;

--
-- Name: diagrams diagrams_delete_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagrams_delete_policy ON public.diagrams FOR DELETE USING (((owner_id = auth.uid()) OR (account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE ((account_users.user_id = auth.uid()) AND ((account_users.role)::text = ANY ((ARRAY['owner'::character varying, 'admin'::character varying])::text[])))))));


--
-- Name: diagrams diagrams_insert_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagrams_insert_policy ON public.diagrams FOR INSERT WITH CHECK ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid()))));


--
-- Name: diagrams diagrams_select_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagrams_select_policy ON public.diagrams FOR SELECT USING (((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid()))) OR ((visibility)::text = 'public'::text)));


--
-- Name: diagrams diagrams_update_policy; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY diagrams_update_policy ON public.diagrams FOR UPDATE USING ((account_id IN ( SELECT account_users.account_id
   FROM public.account_users
  WHERE (account_users.user_id = auth.uid()))));


--
-- Name: invitations; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.invitations ENABLE ROW LEVEL SECURITY;

--
-- Name: messages; Type: ROW SECURITY; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE realtime.messages ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets_analytics; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: migrations; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: objects; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

--
-- Name: prefixes; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.prefixes ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads_parts; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads_parts ENABLE ROW LEVEL SECURITY;

--
-- Name: supabase_realtime; Type: PUBLICATION; Schema: -; Owner: postgres
--

CREATE PUBLICATION supabase_realtime WITH (publish = 'insert, update, delete, truncate');


ALTER PUBLICATION supabase_realtime OWNER TO postgres;

--
-- Name: SCHEMA auth; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA auth TO anon;
GRANT USAGE ON SCHEMA auth TO authenticated;
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON SCHEMA auth TO supabase_auth_admin;
GRANT ALL ON SCHEMA auth TO dashboard_user;
GRANT USAGE ON SCHEMA auth TO postgres;


--
-- Name: SCHEMA extensions; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA extensions TO anon;
GRANT USAGE ON SCHEMA extensions TO authenticated;
GRANT USAGE ON SCHEMA extensions TO service_role;
GRANT ALL ON SCHEMA extensions TO dashboard_user;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT USAGE ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO service_role;


--
-- Name: SCHEMA realtime; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA realtime TO postgres;
GRANT USAGE ON SCHEMA realtime TO anon;
GRANT USAGE ON SCHEMA realtime TO authenticated;
GRANT USAGE ON SCHEMA realtime TO service_role;
GRANT ALL ON SCHEMA realtime TO supabase_realtime_admin;


--
-- Name: SCHEMA storage; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA storage TO postgres WITH GRANT OPTION;
GRANT USAGE ON SCHEMA storage TO anon;
GRANT USAGE ON SCHEMA storage TO authenticated;
GRANT USAGE ON SCHEMA storage TO service_role;
GRANT ALL ON SCHEMA storage TO supabase_storage_admin;
GRANT ALL ON SCHEMA storage TO dashboard_user;


--
-- Name: SCHEMA vault; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA vault TO postgres WITH GRANT OPTION;
GRANT USAGE ON SCHEMA vault TO service_role;


--
-- Name: FUNCTION email(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.email() TO dashboard_user;


--
-- Name: FUNCTION jwt(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.jwt() TO postgres;
GRANT ALL ON FUNCTION auth.jwt() TO dashboard_user;


--
-- Name: FUNCTION role(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.role() TO dashboard_user;


--
-- Name: FUNCTION uid(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.uid() TO dashboard_user;


--
-- Name: FUNCTION armor(bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.armor(bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO dashboard_user;


--
-- Name: FUNCTION armor(bytea, text[], text[]); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.armor(bytea, text[], text[]) FROM postgres;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO dashboard_user;


--
-- Name: FUNCTION crypt(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.crypt(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO dashboard_user;


--
-- Name: FUNCTION dearmor(text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.dearmor(text) FROM postgres;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO dashboard_user;


--
-- Name: FUNCTION decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION decrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION digest(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.digest(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION digest(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.digest(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO dashboard_user;


--
-- Name: FUNCTION encrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION encrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION gen_random_bytes(integer); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_random_bytes(integer) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO dashboard_user;


--
-- Name: FUNCTION gen_random_uuid(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_random_uuid() FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO dashboard_user;


--
-- Name: FUNCTION gen_salt(text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_salt(text) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO dashboard_user;


--
-- Name: FUNCTION gen_salt(text, integer); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_salt(text, integer) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO dashboard_user;


--
-- Name: FUNCTION grant_pg_cron_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION extensions.grant_pg_cron_access() FROM supabase_admin;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO supabase_admin WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO dashboard_user;


--
-- Name: FUNCTION grant_pg_graphql_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.grant_pg_graphql_access() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION grant_pg_net_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION extensions.grant_pg_net_access() FROM supabase_admin;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO supabase_admin WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO dashboard_user;


--
-- Name: FUNCTION hmac(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.hmac(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION hmac(text, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.hmac(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) TO dashboard_user;


--
-- Name: FUNCTION pgp_armor_headers(text, OUT key text, OUT value text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO dashboard_user;


--
-- Name: FUNCTION pgp_key_id(bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_key_id(bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgrst_ddl_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_ddl_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgrst_drop_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_drop_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION set_graphql_placeholder(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.set_graphql_placeholder() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v1(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v1() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v1mc(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v1mc() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v3(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v4(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v4() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v5(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO dashboard_user;


--
-- Name: FUNCTION uuid_nil(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_nil() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_dns(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_dns() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_oid(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_oid() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_url(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_url() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_x500(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_x500() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO dashboard_user;


--
-- Name: FUNCTION graphql("operationName" text, query text, variables jsonb, extensions jsonb); Type: ACL; Schema: graphql_public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO postgres;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO anon;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO authenticated;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO service_role;


--
-- Name: FUNCTION get_auth(p_usename text); Type: ACL; Schema: pgbouncer; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION pgbouncer.get_auth(p_usename text) FROM PUBLIC;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO pgbouncer;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO postgres;


--
-- Name: FUNCTION add_company_owner(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_company_owner() TO anon;
GRANT ALL ON FUNCTION public.add_company_owner() TO authenticated;
GRANT ALL ON FUNCTION public.add_company_owner() TO service_role;


--
-- Name: FUNCTION add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.add_dataset_to_diagram(p_diagram_id uuid, p_dataset_id uuid, p_location jsonb, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION add_project_owner_to_project_users(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_project_owner_to_project_users() TO anon;
GRANT ALL ON FUNCTION public.add_project_owner_to_project_users() TO authenticated;
GRANT ALL ON FUNCTION public.add_project_owner_to_project_users() TO service_role;


--
-- Name: FUNCTION add_user_to_account(p_account_id uuid, p_user_id uuid, p_role character varying, p_invited_by uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_user_to_account(p_account_id uuid, p_user_id uuid, p_role character varying, p_invited_by uuid) TO anon;
GRANT ALL ON FUNCTION public.add_user_to_account(p_account_id uuid, p_user_id uuid, p_role character varying, p_invited_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.add_user_to_account(p_account_id uuid, p_user_id uuid, p_role character varying, p_invited_by uuid) TO service_role;


--
-- Name: FUNCTION add_workspace_owner_to_workspace_users(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.add_workspace_owner_to_workspace_users() TO anon;
GRANT ALL ON FUNCTION public.add_workspace_owner_to_workspace_users() TO authenticated;
GRANT ALL ON FUNCTION public.add_workspace_owner_to_workspace_users() TO service_role;


--
-- Name: FUNCTION archive_old_usage_events(p_days_to_keep integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.archive_old_usage_events(p_days_to_keep integer) TO anon;
GRANT ALL ON FUNCTION public.archive_old_usage_events(p_days_to_keep integer) TO authenticated;
GRANT ALL ON FUNCTION public.archive_old_usage_events(p_days_to_keep integer) TO service_role;


--
-- Name: FUNCTION auto_expire_invitations(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_expire_invitations() TO anon;
GRANT ALL ON FUNCTION public.auto_expire_invitations() TO authenticated;
GRANT ALL ON FUNCTION public.auto_expire_invitations() TO service_role;


--
-- Name: FUNCTION auto_increment_composition_version(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_increment_composition_version() TO anon;
GRANT ALL ON FUNCTION public.auto_increment_composition_version() TO authenticated;
GRANT ALL ON FUNCTION public.auto_increment_composition_version() TO service_role;


--
-- Name: FUNCTION auto_increment_model_version(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.auto_increment_model_version() TO anon;
GRANT ALL ON FUNCTION public.auto_increment_model_version() TO authenticated;
GRANT ALL ON FUNCTION public.auto_increment_model_version() TO service_role;


--
-- Name: FUNCTION calculate_account_usage(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_account_usage(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.calculate_account_usage(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_account_usage(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION can_edit_template_composition(composition_uuid uuid, user_uuid uuid, dev_mode_enabled boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.can_edit_template_composition(composition_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) TO anon;
GRANT ALL ON FUNCTION public.can_edit_template_composition(composition_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) TO authenticated;
GRANT ALL ON FUNCTION public.can_edit_template_composition(composition_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) TO service_role;


--
-- Name: FUNCTION can_edit_template_fragment(fragment_uuid uuid, user_uuid uuid, dev_mode_enabled boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.can_edit_template_fragment(fragment_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) TO anon;
GRANT ALL ON FUNCTION public.can_edit_template_fragment(fragment_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) TO authenticated;
GRANT ALL ON FUNCTION public.can_edit_template_fragment(fragment_uuid uuid, user_uuid uuid, dev_mode_enabled boolean) TO service_role;


--
-- Name: FUNCTION change_account_user_role(p_account_id uuid, p_user_id uuid, p_new_role character varying, p_changed_by uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.change_account_user_role(p_account_id uuid, p_user_id uuid, p_new_role character varying, p_changed_by uuid) TO anon;
GRANT ALL ON FUNCTION public.change_account_user_role(p_account_id uuid, p_user_id uuid, p_new_role character varying, p_changed_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.change_account_user_role(p_account_id uuid, p_user_id uuid, p_new_role character varying, p_changed_by uuid) TO service_role;


--
-- Name: FUNCTION check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer) TO anon;
GRANT ALL ON FUNCTION public.check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer) TO authenticated;
GRANT ALL ON FUNCTION public.check_resource_limit(p_account_id uuid, p_resource_type character varying, p_increment integer) TO service_role;


--
-- Name: FUNCTION cleanup_expired_api_tokens(p_days_old integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_expired_api_tokens(p_days_old integer) TO anon;
GRANT ALL ON FUNCTION public.cleanup_expired_api_tokens(p_days_old integer) TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_expired_api_tokens(p_days_old integer) TO service_role;


--
-- Name: FUNCTION cleanup_expired_invitations(p_days_old integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_expired_invitations(p_days_old integer) TO anon;
GRANT ALL ON FUNCTION public.cleanup_expired_invitations(p_days_old integer) TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_expired_invitations(p_days_old integer) TO service_role;


--
-- Name: FUNCTION cleanup_soft_deleted_records(p_table_name text, p_days_old integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_soft_deleted_records(p_table_name text, p_days_old integer) TO anon;
GRANT ALL ON FUNCTION public.cleanup_soft_deleted_records(p_table_name text, p_days_old integer) TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_soft_deleted_records(p_table_name text, p_days_old integer) TO service_role;


--
-- Name: FUNCTION complete_password_reset(p_token character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.complete_password_reset(p_token character varying) TO anon;
GRANT ALL ON FUNCTION public.complete_password_reset(p_token character varying) TO authenticated;
GRANT ALL ON FUNCTION public.complete_password_reset(p_token character varying) TO service_role;


--
-- Name: FUNCTION connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text) TO anon;
GRANT ALL ON FUNCTION public.connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text) TO authenticated;
GRANT ALL ON FUNCTION public.connect_project_source_control(p_project_id uuid, p_provider character varying, p_repo_url text, p_default_branch text) TO service_role;


--
-- Name: FUNCTION count_ai_requests_current_period(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.count_ai_requests_current_period(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.count_ai_requests_current_period(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.count_ai_requests_current_period(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION create_workspace_with_owner(p_name text, p_description text, p_github_repo_url text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_workspace_with_owner(p_name text, p_description text, p_github_repo_url text) TO anon;
GRANT ALL ON FUNCTION public.create_workspace_with_owner(p_name text, p_description text, p_github_repo_url text) TO authenticated;
GRANT ALL ON FUNCTION public.create_workspace_with_owner(p_name text, p_description text, p_github_repo_url text) TO service_role;


--
-- Name: FUNCTION deactivate_account_user(p_account_id uuid, p_user_id uuid, p_deactivated_by uuid, p_reason text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.deactivate_account_user(p_account_id uuid, p_user_id uuid, p_deactivated_by uuid, p_reason text) TO anon;
GRANT ALL ON FUNCTION public.deactivate_account_user(p_account_id uuid, p_user_id uuid, p_deactivated_by uuid, p_reason text) TO authenticated;
GRANT ALL ON FUNCTION public.deactivate_account_user(p_account_id uuid, p_user_id uuid, p_deactivated_by uuid, p_reason text) TO service_role;


--
-- Name: FUNCTION decrement_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.decrement_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) TO anon;
GRANT ALL ON FUNCTION public.decrement_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) TO authenticated;
GRANT ALL ON FUNCTION public.decrement_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) TO service_role;


--
-- Name: FUNCTION disconnect_project_source_control(p_project_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.disconnect_project_source_control(p_project_id uuid) TO anon;
GRANT ALL ON FUNCTION public.disconnect_project_source_control(p_project_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.disconnect_project_source_control(p_project_id uuid) TO service_role;


--
-- Name: FUNCTION generate_api_token(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_api_token() TO anon;
GRANT ALL ON FUNCTION public.generate_api_token() TO authenticated;
GRANT ALL ON FUNCTION public.generate_api_token() TO service_role;


--
-- Name: FUNCTION generate_api_token_prefix(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_api_token_prefix() TO anon;
GRANT ALL ON FUNCTION public.generate_api_token_prefix() TO authenticated;
GRANT ALL ON FUNCTION public.generate_api_token_prefix() TO service_role;


--
-- Name: FUNCTION generate_email_verification_token(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_email_verification_token() TO anon;
GRANT ALL ON FUNCTION public.generate_email_verification_token() TO authenticated;
GRANT ALL ON FUNCTION public.generate_email_verification_token() TO service_role;


--
-- Name: FUNCTION generate_invitation_token(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_invitation_token() TO anon;
GRANT ALL ON FUNCTION public.generate_invitation_token() TO authenticated;
GRANT ALL ON FUNCTION public.generate_invitation_token() TO service_role;


--
-- Name: FUNCTION generate_password_reset_token(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_password_reset_token() TO anon;
GRANT ALL ON FUNCTION public.generate_password_reset_token() TO authenticated;
GRANT ALL ON FUNCTION public.generate_password_reset_token() TO service_role;


--
-- Name: FUNCTION get_account_members(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_account_members(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_account_members(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_account_members(p_account_id uuid) TO service_role;


--
-- Name: TABLE subscriptions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.subscriptions TO anon;
GRANT ALL ON TABLE public.subscriptions TO authenticated;
GRANT ALL ON TABLE public.subscriptions TO service_role;


--
-- Name: FUNCTION get_active_subscription(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_active_subscription(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_active_subscription(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_active_subscription(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION get_dataset_fqn(p_connection_id uuid, p_schema character varying, p_name character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_dataset_fqn(p_connection_id uuid, p_schema character varying, p_name character varying) TO anon;
GRANT ALL ON FUNCTION public.get_dataset_fqn(p_connection_id uuid, p_schema character varying, p_name character varying) TO authenticated;
GRANT ALL ON FUNCTION public.get_dataset_fqn(p_connection_id uuid, p_schema character varying, p_name character varying) TO service_role;


--
-- Name: FUNCTION get_diagram_datasets(p_diagram_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_diagram_datasets(p_diagram_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_diagram_datasets(p_diagram_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_diagram_datasets(p_diagram_id uuid) TO service_role;


--
-- Name: FUNCTION get_pending_invitations(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_pending_invitations(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_pending_invitations(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_pending_invitations(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION get_project_source_control_stats(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_project_source_control_stats(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_project_source_control_stats(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_project_source_control_stats(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION get_project_source_control_status(p_project_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_project_source_control_status(p_project_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_project_source_control_status(p_project_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_project_source_control_status(p_project_id uuid) TO service_role;


--
-- Name: FUNCTION get_project_user_role(p_project_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_project_user_role(p_project_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_project_user_role(p_project_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_project_user_role(p_project_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_usage_summary(p_account_id uuid, p_start_date timestamp without time zone, p_end_date timestamp without time zone); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_usage_summary(p_account_id uuid, p_start_date timestamp without time zone, p_end_date timestamp without time zone) TO anon;
GRANT ALL ON FUNCTION public.get_usage_summary(p_account_id uuid, p_start_date timestamp without time zone, p_end_date timestamp without time zone) TO authenticated;
GRANT ALL ON FUNCTION public.get_usage_summary(p_account_id uuid, p_start_date timestamp without time zone, p_end_date timestamp without time zone) TO service_role;


--
-- Name: FUNCTION get_user_api_tokens(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_api_tokens(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_api_tokens(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_api_tokens(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_projects(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_projects(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_projects(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_projects(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_workspace_role(workspace_uuid uuid, user_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_workspace_role(workspace_uuid uuid, user_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_workspace_role(workspace_uuid uuid, user_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_workspace_role(workspace_uuid uuid, user_uuid uuid) TO service_role;


--
-- Name: FUNCTION get_user_workspaces(p_user_id uuid, p_project_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_workspaces(p_user_id uuid, p_project_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_workspaces(p_user_id uuid, p_project_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_workspaces(p_user_id uuid, p_project_id uuid) TO service_role;


--
-- Name: FUNCTION get_workspace_available_branches(p_workspace_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_workspace_available_branches(p_workspace_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_workspace_available_branches(p_workspace_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_workspace_available_branches(p_workspace_id uuid) TO service_role;


--
-- Name: FUNCTION get_workspace_user_role(p_workspace_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_workspace_user_role(p_workspace_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_workspace_user_role(p_workspace_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_workspace_user_role(p_workspace_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION handle_new_user(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.handle_new_user() TO anon;
GRANT ALL ON FUNCTION public.handle_new_user() TO authenticated;
GRANT ALL ON FUNCTION public.handle_new_user() TO service_role;


--
-- Name: FUNCTION has_project_access(p_project_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.has_project_access(p_project_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.has_project_access(p_project_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.has_project_access(p_project_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION has_project_credentials(p_project_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.has_project_credentials(p_project_id uuid) TO anon;
GRANT ALL ON FUNCTION public.has_project_credentials(p_project_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.has_project_credentials(p_project_id uuid) TO service_role;


--
-- Name: FUNCTION has_workspace_access(p_workspace_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.has_workspace_access(p_workspace_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.has_workspace_access(p_workspace_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.has_workspace_access(p_workspace_id uuid, p_user_id uuid) TO service_role;


--
-- Name: FUNCTION hash_api_token(p_token character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.hash_api_token(p_token character varying) TO anon;
GRANT ALL ON FUNCTION public.hash_api_token(p_token character varying) TO authenticated;
GRANT ALL ON FUNCTION public.hash_api_token(p_token character varying) TO service_role;


--
-- Name: FUNCTION increment_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.increment_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) TO anon;
GRANT ALL ON FUNCTION public.increment_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) TO authenticated;
GRANT ALL ON FUNCTION public.increment_usage_counter(p_account_id uuid, p_resource_type character varying, p_amount integer) TO service_role;


--
-- Name: FUNCTION is_subscription_active(p_subscription_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_subscription_active(p_subscription_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_subscription_active(p_subscription_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_subscription_active(p_subscription_id uuid) TO service_role;


--
-- Name: FUNCTION is_trial_active(p_subscription_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_trial_active(p_subscription_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_trial_active(p_subscription_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_trial_active(p_subscription_id uuid) TO service_role;


--
-- Name: FUNCTION is_workspace_member(workspace_uuid uuid, user_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_workspace_member(workspace_uuid uuid, user_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.is_workspace_member(workspace_uuid uuid, user_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_workspace_member(workspace_uuid uuid, user_uuid uuid) TO service_role;


--
-- Name: FUNCTION log_audit_event(p_user_id uuid, p_workspace_id uuid, p_action text, p_entity_type text, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.log_audit_event(p_user_id uuid, p_workspace_id uuid, p_action text, p_entity_type text, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text) TO anon;
GRANT ALL ON FUNCTION public.log_audit_event(p_user_id uuid, p_workspace_id uuid, p_action text, p_entity_type text, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text) TO authenticated;
GRANT ALL ON FUNCTION public.log_audit_event(p_user_id uuid, p_workspace_id uuid, p_action text, p_entity_type text, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text) TO service_role;


--
-- Name: FUNCTION permanent_delete(p_table_name text, p_record_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.permanent_delete(p_table_name text, p_record_id uuid) TO anon;
GRANT ALL ON FUNCTION public.permanent_delete(p_table_name text, p_record_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.permanent_delete(p_table_name text, p_record_id uuid) TO service_role;


--
-- Name: FUNCTION remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid) TO anon;
GRANT ALL ON FUNCTION public.remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.remove_dataset_from_diagram(p_diagram_id uuid, p_dataset_id uuid) TO service_role;


--
-- Name: FUNCTION request_email_verification(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.request_email_verification(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.request_email_verification(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.request_email_verification(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION request_password_reset(p_email character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.request_password_reset(p_email character varying) TO anon;
GRANT ALL ON FUNCTION public.request_password_reset(p_email character varying) TO authenticated;
GRANT ALL ON FUNCTION public.request_password_reset(p_email character varying) TO service_role;


--
-- Name: FUNCTION reset_failed_login_attempts(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reset_failed_login_attempts(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.reset_failed_login_attempts(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.reset_failed_login_attempts(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION reset_monthly_usage(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reset_monthly_usage(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.reset_monthly_usage(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.reset_monthly_usage(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION restore_deleted(p_table_name text, p_record_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.restore_deleted(p_table_name text, p_record_id uuid) TO anon;
GRANT ALL ON FUNCTION public.restore_deleted(p_table_name text, p_record_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.restore_deleted(p_table_name text, p_record_id uuid) TO service_role;


--
-- Name: FUNCTION revoke_api_token(p_token_id uuid, p_revoked_by uuid, p_reason text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.revoke_api_token(p_token_id uuid, p_revoked_by uuid, p_reason text) TO anon;
GRANT ALL ON FUNCTION public.revoke_api_token(p_token_id uuid, p_revoked_by uuid, p_reason text) TO authenticated;
GRANT ALL ON FUNCTION public.revoke_api_token(p_token_id uuid, p_revoked_by uuid, p_reason text) TO service_role;


--
-- Name: FUNCTION set_dataset_owner(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.set_dataset_owner() TO anon;
GRANT ALL ON FUNCTION public.set_dataset_owner() TO authenticated;
GRANT ALL ON FUNCTION public.set_dataset_owner() TO service_role;


--
-- Name: FUNCTION soft_delete(p_table_name text, p_record_id uuid, p_deleted_by uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.soft_delete(p_table_name text, p_record_id uuid, p_deleted_by uuid) TO anon;
GRANT ALL ON FUNCTION public.soft_delete(p_table_name text, p_record_id uuid, p_deleted_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.soft_delete(p_table_name text, p_record_id uuid, p_deleted_by uuid) TO service_role;


--
-- Name: FUNCTION soft_delete_account(p_account_id uuid, p_deleted_by uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.soft_delete_account(p_account_id uuid, p_deleted_by uuid) TO anon;
GRANT ALL ON FUNCTION public.soft_delete_account(p_account_id uuid, p_deleted_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.soft_delete_account(p_account_id uuid, p_deleted_by uuid) TO service_role;


--
-- Name: FUNCTION soft_delete_dataset(p_dataset_id uuid, p_deleted_by uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.soft_delete_dataset(p_dataset_id uuid, p_deleted_by uuid) TO anon;
GRANT ALL ON FUNCTION public.soft_delete_dataset(p_dataset_id uuid, p_deleted_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.soft_delete_dataset(p_dataset_id uuid, p_deleted_by uuid) TO service_role;


--
-- Name: FUNCTION soft_delete_project(p_project_id uuid, p_deleted_by uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.soft_delete_project(p_project_id uuid, p_deleted_by uuid) TO anon;
GRANT ALL ON FUNCTION public.soft_delete_project(p_project_id uuid, p_deleted_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.soft_delete_project(p_project_id uuid, p_deleted_by uuid) TO service_role;


--
-- Name: FUNCTION sync_usage_counters(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.sync_usage_counters(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.sync_usage_counters(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.sync_usage_counters(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION test_usage_calculations(p_account_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.test_usage_calculations(p_account_id uuid) TO anon;
GRANT ALL ON FUNCTION public.test_usage_calculations(p_account_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.test_usage_calculations(p_account_id uuid) TO service_role;


--
-- Name: FUNCTION token_has_scope(p_token_scopes jsonb, p_required_scope character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.token_has_scope(p_token_scopes jsonb, p_required_scope character varying) TO anon;
GRANT ALL ON FUNCTION public.token_has_scope(p_token_scopes jsonb, p_required_scope character varying) TO authenticated;
GRANT ALL ON FUNCTION public.token_has_scope(p_token_scopes jsonb, p_required_scope character varying) TO service_role;


--
-- Name: FUNCTION track_failed_login(p_email character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.track_failed_login(p_email character varying) TO anon;
GRANT ALL ON FUNCTION public.track_failed_login(p_email character varying) TO authenticated;
GRANT ALL ON FUNCTION public.track_failed_login(p_email character varying) TO service_role;


--
-- Name: FUNCTION track_usage_event(p_account_id uuid, p_user_id uuid, p_event_type character varying, p_event_category character varying, p_quantity integer, p_unit character varying, p_resource_type character varying, p_resource_id uuid, p_metadata jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.track_usage_event(p_account_id uuid, p_user_id uuid, p_event_type character varying, p_event_category character varying, p_quantity integer, p_unit character varying, p_resource_type character varying, p_resource_id uuid, p_metadata jsonb) TO anon;
GRANT ALL ON FUNCTION public.track_usage_event(p_account_id uuid, p_user_id uuid, p_event_type character varying, p_event_category character varying, p_quantity integer, p_unit character varying, p_resource_type character varying, p_resource_id uuid, p_metadata jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.track_usage_event(p_account_id uuid, p_user_id uuid, p_event_type character varying, p_event_category character varying, p_quantity integer, p_unit character varying, p_resource_type character varying, p_resource_id uuid, p_metadata jsonb) TO service_role;


--
-- Name: FUNCTION transfer_account_ownership(p_account_id uuid, p_current_owner_id uuid, p_new_owner_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.transfer_account_ownership(p_account_id uuid, p_current_owner_id uuid, p_new_owner_id uuid) TO anon;
GRANT ALL ON FUNCTION public.transfer_account_ownership(p_account_id uuid, p_current_owner_id uuid, p_new_owner_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.transfer_account_ownership(p_account_id uuid, p_current_owner_id uuid, p_new_owner_id uuid) TO service_role;


--
-- Name: FUNCTION update_account_counters_on_usage_event(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_account_counters_on_usage_event() TO anon;
GRANT ALL ON FUNCTION public.update_account_counters_on_usage_event() TO authenticated;
GRANT ALL ON FUNCTION public.update_account_counters_on_usage_event() TO service_role;


--
-- Name: FUNCTION update_account_dataset_count(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_account_dataset_count() TO anon;
GRANT ALL ON FUNCTION public.update_account_dataset_count() TO authenticated;
GRANT ALL ON FUNCTION public.update_account_dataset_count() TO service_role;


--
-- Name: FUNCTION update_account_project_count(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_account_project_count() TO anon;
GRANT ALL ON FUNCTION public.update_account_project_count() TO authenticated;
GRANT ALL ON FUNCTION public.update_account_project_count() TO service_role;


--
-- Name: FUNCTION update_account_user_count(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_account_user_count() TO anon;
GRANT ALL ON FUNCTION public.update_account_user_count() TO authenticated;
GRANT ALL ON FUNCTION public.update_account_user_count() TO service_role;


--
-- Name: FUNCTION update_dataset_fqn(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_dataset_fqn() TO anon;
GRANT ALL ON FUNCTION public.update_dataset_fqn() TO authenticated;
GRANT ALL ON FUNCTION public.update_dataset_fqn() TO service_role;


--
-- Name: FUNCTION update_datasets_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_datasets_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_datasets_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_datasets_updated_at() TO service_role;


--
-- Name: FUNCTION update_diagram_states_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_diagram_states_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_diagram_states_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_diagram_states_updated_at() TO service_role;


--
-- Name: FUNCTION update_diagrams_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_diagrams_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_diagrams_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_diagrams_updated_at() TO service_role;


--
-- Name: FUNCTION update_last_seen(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_last_seen(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.update_last_seen(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.update_last_seen(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION update_notification_settings(p_user_id uuid, p_settings jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_notification_settings(p_user_id uuid, p_settings jsonb) TO anon;
GRANT ALL ON FUNCTION public.update_notification_settings(p_user_id uuid, p_settings jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.update_notification_settings(p_user_id uuid, p_settings jsonb) TO service_role;


--
-- Name: FUNCTION update_project_source_control_status(p_project_id uuid, p_status character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_project_source_control_status(p_project_id uuid, p_status character varying) TO anon;
GRANT ALL ON FUNCTION public.update_project_source_control_status(p_project_id uuid, p_status character varying) TO authenticated;
GRANT ALL ON FUNCTION public.update_project_source_control_status(p_project_id uuid, p_status character varying) TO service_role;


--
-- Name: FUNCTION update_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_updated_at() TO service_role;


--
-- Name: FUNCTION update_updated_at_column(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_updated_at_column() TO anon;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO authenticated;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO service_role;


--
-- Name: FUNCTION update_workspace_branch(p_workspace_id uuid, p_branch text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_workspace_branch(p_workspace_id uuid, p_branch text) TO anon;
GRANT ALL ON FUNCTION public.update_workspace_branch(p_workspace_id uuid, p_branch text) TO authenticated;
GRANT ALL ON FUNCTION public.update_workspace_branch(p_workspace_id uuid, p_branch text) TO service_role;


--
-- Name: FUNCTION validate_api_token(p_token character varying, p_ip_address character varying, p_user_agent text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.validate_api_token(p_token character varying, p_ip_address character varying, p_user_agent text) TO anon;
GRANT ALL ON FUNCTION public.validate_api_token(p_token character varying, p_ip_address character varying, p_user_agent text) TO authenticated;
GRANT ALL ON FUNCTION public.validate_api_token(p_token character varying, p_ip_address character varying, p_user_agent text) TO service_role;


--
-- Name: FUNCTION validate_password_reset_token(p_token character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.validate_password_reset_token(p_token character varying) TO anon;
GRANT ALL ON FUNCTION public.validate_password_reset_token(p_token character varying) TO authenticated;
GRANT ALL ON FUNCTION public.validate_password_reset_token(p_token character varying) TO service_role;


--
-- Name: FUNCTION validate_project_source_control_setup(p_project_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.validate_project_source_control_setup(p_project_id uuid) TO anon;
GRANT ALL ON FUNCTION public.validate_project_source_control_setup(p_project_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.validate_project_source_control_setup(p_project_id uuid) TO service_role;


--
-- Name: FUNCTION verify_email(p_token character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.verify_email(p_token character varying) TO anon;
GRANT ALL ON FUNCTION public.verify_email(p_token character varying) TO authenticated;
GRANT ALL ON FUNCTION public.verify_email(p_token character varying) TO service_role;


--
-- Name: FUNCTION apply_rls(wal jsonb, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO postgres;
GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO dashboard_user;


--
-- Name: FUNCTION build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO postgres;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO anon;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO service_role;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION "cast"(val text, type_ regtype); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO postgres;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO dashboard_user;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO anon;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO authenticated;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO service_role;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO supabase_realtime_admin;


--
-- Name: FUNCTION check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO postgres;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO anon;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO authenticated;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO service_role;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO supabase_realtime_admin;


--
-- Name: FUNCTION is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO postgres;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO anon;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO service_role;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION quote_wal2json(entity regclass); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO postgres;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO anon;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO authenticated;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO service_role;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO supabase_realtime_admin;


--
-- Name: FUNCTION send(payload jsonb, event text, topic text, private boolean); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO postgres;
GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO dashboard_user;


--
-- Name: FUNCTION subscription_check_filters(); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO postgres;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO dashboard_user;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO anon;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO authenticated;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO service_role;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO supabase_realtime_admin;


--
-- Name: FUNCTION to_regrole(role_name text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO postgres;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO anon;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO authenticated;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO service_role;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO supabase_realtime_admin;


--
-- Name: FUNCTION topic(); Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON FUNCTION realtime.topic() TO postgres;
GRANT ALL ON FUNCTION realtime.topic() TO dashboard_user;


--
-- Name: FUNCTION _crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO service_role;


--
-- Name: FUNCTION create_secret(new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO service_role;


--
-- Name: FUNCTION update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO service_role;


--
-- Name: TABLE audit_log_entries; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.audit_log_entries TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.audit_log_entries TO postgres;
GRANT SELECT ON TABLE auth.audit_log_entries TO postgres WITH GRANT OPTION;


--
-- Name: TABLE flow_state; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.flow_state TO postgres;
GRANT SELECT ON TABLE auth.flow_state TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.flow_state TO dashboard_user;


--
-- Name: TABLE identities; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.identities TO postgres;
GRANT SELECT ON TABLE auth.identities TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.identities TO dashboard_user;


--
-- Name: TABLE instances; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.instances TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.instances TO postgres;
GRANT SELECT ON TABLE auth.instances TO postgres WITH GRANT OPTION;


--
-- Name: TABLE mfa_amr_claims; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_amr_claims TO postgres;
GRANT SELECT ON TABLE auth.mfa_amr_claims TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_amr_claims TO dashboard_user;


--
-- Name: TABLE mfa_challenges; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_challenges TO postgres;
GRANT SELECT ON TABLE auth.mfa_challenges TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_challenges TO dashboard_user;


--
-- Name: TABLE mfa_factors; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_factors TO postgres;
GRANT SELECT ON TABLE auth.mfa_factors TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_factors TO dashboard_user;


--
-- Name: TABLE oauth_authorizations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_authorizations TO postgres;
GRANT ALL ON TABLE auth.oauth_authorizations TO dashboard_user;


--
-- Name: TABLE oauth_clients; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_clients TO postgres;
GRANT ALL ON TABLE auth.oauth_clients TO dashboard_user;


--
-- Name: TABLE oauth_consents; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_consents TO postgres;
GRANT ALL ON TABLE auth.oauth_consents TO dashboard_user;


--
-- Name: TABLE one_time_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.one_time_tokens TO postgres;
GRANT SELECT ON TABLE auth.one_time_tokens TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.one_time_tokens TO dashboard_user;


--
-- Name: TABLE refresh_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.refresh_tokens TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.refresh_tokens TO postgres;
GRANT SELECT ON TABLE auth.refresh_tokens TO postgres WITH GRANT OPTION;


--
-- Name: SEQUENCE refresh_tokens_id_seq; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO dashboard_user;
GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO postgres;


--
-- Name: TABLE saml_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.saml_providers TO postgres;
GRANT SELECT ON TABLE auth.saml_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_providers TO dashboard_user;


--
-- Name: TABLE saml_relay_states; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.saml_relay_states TO postgres;
GRANT SELECT ON TABLE auth.saml_relay_states TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_relay_states TO dashboard_user;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT SELECT ON TABLE auth.schema_migrations TO postgres WITH GRANT OPTION;


--
-- Name: TABLE sessions; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sessions TO postgres;
GRANT SELECT ON TABLE auth.sessions TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sessions TO dashboard_user;


--
-- Name: TABLE sso_domains; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sso_domains TO postgres;
GRANT SELECT ON TABLE auth.sso_domains TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_domains TO dashboard_user;


--
-- Name: TABLE sso_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sso_providers TO postgres;
GRANT SELECT ON TABLE auth.sso_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_providers TO dashboard_user;


--
-- Name: TABLE users; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.users TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.users TO postgres;
GRANT SELECT ON TABLE auth.users TO postgres WITH GRANT OPTION;


--
-- Name: TABLE pg_stat_statements; Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON TABLE extensions.pg_stat_statements FROM postgres;
GRANT ALL ON TABLE extensions.pg_stat_statements TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE extensions.pg_stat_statements TO dashboard_user;


--
-- Name: TABLE pg_stat_statements_info; Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON TABLE extensions.pg_stat_statements_info FROM postgres;
GRANT ALL ON TABLE extensions.pg_stat_statements_info TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE extensions.pg_stat_statements_info TO dashboard_user;


--
-- Name: TABLE account_users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.account_users TO anon;
GRANT ALL ON TABLE public.account_users TO authenticated;
GRANT ALL ON TABLE public.account_users TO service_role;


--
-- Name: TABLE accounts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.accounts TO anon;
GRANT ALL ON TABLE public.accounts TO authenticated;
GRANT ALL ON TABLE public.accounts TO service_role;


--
-- Name: TABLE users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.users TO anon;
GRANT ALL ON TABLE public.users TO authenticated;
GRANT ALL ON TABLE public.users TO service_role;


--
-- Name: TABLE account_user_role_changes; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.account_user_role_changes TO anon;
GRANT ALL ON TABLE public.account_user_role_changes TO authenticated;
GRANT ALL ON TABLE public.account_user_role_changes TO service_role;


--
-- Name: TABLE accounts_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.accounts_active TO anon;
GRANT ALL ON TABLE public.accounts_active TO authenticated;
GRANT ALL ON TABLE public.accounts_active TO service_role;


--
-- Name: TABLE api_tokens; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.api_tokens TO anon;
GRANT ALL ON TABLE public.api_tokens TO authenticated;
GRANT ALL ON TABLE public.api_tokens TO service_role;


--
-- Name: TABLE audit_logs; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.audit_logs TO anon;
GRANT ALL ON TABLE public.audit_logs TO authenticated;
GRANT ALL ON TABLE public.audit_logs TO service_role;


--
-- Name: TABLE columns; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.columns TO anon;
GRANT ALL ON TABLE public.columns TO authenticated;
GRANT ALL ON TABLE public.columns TO service_role;


--
-- Name: TABLE columns_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.columns_active TO anon;
GRANT ALL ON TABLE public.columns_active TO authenticated;
GRANT ALL ON TABLE public.columns_active TO service_role;


--
-- Name: TABLE configurations; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.configurations TO anon;
GRANT ALL ON TABLE public.configurations TO authenticated;
GRANT ALL ON TABLE public.configurations TO service_role;


--
-- Name: TABLE configurations_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.configurations_active TO anon;
GRANT ALL ON TABLE public.configurations_active TO authenticated;
GRANT ALL ON TABLE public.configurations_active TO service_role;


--
-- Name: TABLE connection_metadata_cache; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.connection_metadata_cache TO anon;
GRANT ALL ON TABLE public.connection_metadata_cache TO authenticated;
GRANT ALL ON TABLE public.connection_metadata_cache TO service_role;


--
-- Name: TABLE connections; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.connections TO anon;
GRANT ALL ON TABLE public.connections TO authenticated;
GRANT ALL ON TABLE public.connections TO service_role;


--
-- Name: TABLE connections_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.connections_active TO anon;
GRANT ALL ON TABLE public.connections_active TO authenticated;
GRANT ALL ON TABLE public.connections_active TO service_role;


--
-- Name: TABLE datasets; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.datasets TO anon;
GRANT ALL ON TABLE public.datasets TO authenticated;
GRANT ALL ON TABLE public.datasets TO service_role;


--
-- Name: TABLE datasets_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.datasets_active TO anon;
GRANT ALL ON TABLE public.datasets_active TO authenticated;
GRANT ALL ON TABLE public.datasets_active TO service_role;


--
-- Name: TABLE deactivated_account_memberships; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.deactivated_account_memberships TO anon;
GRANT ALL ON TABLE public.deactivated_account_memberships TO authenticated;
GRANT ALL ON TABLE public.deactivated_account_memberships TO service_role;


--
-- Name: TABLE diagram_datasets; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.diagram_datasets TO anon;
GRANT ALL ON TABLE public.diagram_datasets TO authenticated;
GRANT ALL ON TABLE public.diagram_datasets TO service_role;


--
-- Name: TABLE diagrams; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.diagrams TO anon;
GRANT ALL ON TABLE public.diagrams TO authenticated;
GRANT ALL ON TABLE public.diagrams TO service_role;


--
-- Name: TABLE diagram_summary; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.diagram_summary TO anon;
GRANT ALL ON TABLE public.diagram_summary TO authenticated;
GRANT ALL ON TABLE public.diagram_summary TO service_role;


--
-- Name: TABLE environments; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.environments TO anon;
GRANT ALL ON TABLE public.environments TO authenticated;
GRANT ALL ON TABLE public.environments TO service_role;


--
-- Name: TABLE environments_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.environments_active TO anon;
GRANT ALL ON TABLE public.environments_active TO authenticated;
GRANT ALL ON TABLE public.environments_active TO service_role;


--
-- Name: TABLE invitations; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.invitations TO anon;
GRANT ALL ON TABLE public.invitations TO authenticated;
GRANT ALL ON TABLE public.invitations TO service_role;


--
-- Name: TABLE expired_invitations; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.expired_invitations TO anon;
GRANT ALL ON TABLE public.expired_invitations TO authenticated;
GRANT ALL ON TABLE public.expired_invitations TO service_role;


--
-- Name: TABLE inactive_users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.inactive_users TO anon;
GRANT ALL ON TABLE public.inactive_users TO authenticated;
GRANT ALL ON TABLE public.inactive_users TO service_role;


--
-- Name: TABLE invitations_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.invitations_active TO anon;
GRANT ALL ON TABLE public.invitations_active TO authenticated;
GRANT ALL ON TABLE public.invitations_active TO service_role;


--
-- Name: TABLE lineage; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.lineage TO anon;
GRANT ALL ON TABLE public.lineage TO authenticated;
GRANT ALL ON TABLE public.lineage TO service_role;


--
-- Name: TABLE locked_user_accounts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.locked_user_accounts TO anon;
GRANT ALL ON TABLE public.locked_user_accounts TO authenticated;
GRANT ALL ON TABLE public.locked_user_accounts TO service_role;


--
-- Name: TABLE macros; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.macros TO anon;
GRANT ALL ON TABLE public.macros TO authenticated;
GRANT ALL ON TABLE public.macros TO service_role;


--
-- Name: TABLE macros_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.macros_active TO anon;
GRANT ALL ON TABLE public.macros_active TO authenticated;
GRANT ALL ON TABLE public.macros_active TO service_role;


--
-- Name: TABLE payments; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.payments TO anon;
GRANT ALL ON TABLE public.payments TO authenticated;
GRANT ALL ON TABLE public.payments TO service_role;


--
-- Name: TABLE project_users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.project_users TO anon;
GRANT ALL ON TABLE public.project_users TO authenticated;
GRANT ALL ON TABLE public.project_users TO service_role;


--
-- Name: TABLE projects; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.projects TO anon;
GRANT ALL ON TABLE public.projects TO authenticated;
GRANT ALL ON TABLE public.projects TO service_role;


--
-- Name: TABLE projects_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.projects_active TO anon;
GRANT ALL ON TABLE public.projects_active TO authenticated;
GRANT ALL ON TABLE public.projects_active TO service_role;


--
-- Name: TABLE source_control_commits; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.source_control_commits TO anon;
GRANT ALL ON TABLE public.source_control_commits TO authenticated;
GRANT ALL ON TABLE public.source_control_commits TO service_role;


--
-- Name: TABLE subscription_plans; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.subscription_plans TO anon;
GRANT ALL ON TABLE public.subscription_plans TO authenticated;
GRANT ALL ON TABLE public.subscription_plans TO service_role;


--
-- Name: TABLE template_fragments; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.template_fragments TO anon;
GRANT ALL ON TABLE public.template_fragments TO authenticated;
GRANT ALL ON TABLE public.template_fragments TO service_role;


--
-- Name: TABLE templates; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.templates TO anon;
GRANT ALL ON TABLE public.templates TO authenticated;
GRANT ALL ON TABLE public.templates TO service_role;


--
-- Name: TABLE templates_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.templates_active TO anon;
GRANT ALL ON TABLE public.templates_active TO authenticated;
GRANT ALL ON TABLE public.templates_active TO service_role;


--
-- Name: TABLE unverified_users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.unverified_users TO anon;
GRANT ALL ON TABLE public.unverified_users TO authenticated;
GRANT ALL ON TABLE public.unverified_users TO service_role;


--
-- Name: TABLE usage_events; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.usage_events TO anon;
GRANT ALL ON TABLE public.usage_events TO authenticated;
GRANT ALL ON TABLE public.usage_events TO service_role;


--
-- Name: TABLE users_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.users_active TO anon;
GRANT ALL ON TABLE public.users_active TO authenticated;
GRANT ALL ON TABLE public.users_active TO service_role;


--
-- Name: TABLE workspace_datasets; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.workspace_datasets TO anon;
GRANT ALL ON TABLE public.workspace_datasets TO authenticated;
GRANT ALL ON TABLE public.workspace_datasets TO service_role;


--
-- Name: TABLE workspace_users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.workspace_users TO anon;
GRANT ALL ON TABLE public.workspace_users TO authenticated;
GRANT ALL ON TABLE public.workspace_users TO service_role;


--
-- Name: TABLE workspaces; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.workspaces TO anon;
GRANT ALL ON TABLE public.workspaces TO authenticated;
GRANT ALL ON TABLE public.workspaces TO service_role;


--
-- Name: TABLE workspaces_active; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.workspaces_active TO anon;
GRANT ALL ON TABLE public.workspaces_active TO authenticated;
GRANT ALL ON TABLE public.workspaces_active TO service_role;


--
-- Name: TABLE messages; Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON TABLE realtime.messages TO postgres;
GRANT ALL ON TABLE realtime.messages TO dashboard_user;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO anon;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO authenticated;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO service_role;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.schema_migrations TO postgres;
GRANT ALL ON TABLE realtime.schema_migrations TO dashboard_user;
GRANT SELECT ON TABLE realtime.schema_migrations TO anon;
GRANT SELECT ON TABLE realtime.schema_migrations TO authenticated;
GRANT SELECT ON TABLE realtime.schema_migrations TO service_role;
GRANT ALL ON TABLE realtime.schema_migrations TO supabase_realtime_admin;


--
-- Name: TABLE subscription; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.subscription TO postgres;
GRANT ALL ON TABLE realtime.subscription TO dashboard_user;
GRANT SELECT ON TABLE realtime.subscription TO anon;
GRANT SELECT ON TABLE realtime.subscription TO authenticated;
GRANT SELECT ON TABLE realtime.subscription TO service_role;
GRANT ALL ON TABLE realtime.subscription TO supabase_realtime_admin;


--
-- Name: SEQUENCE subscription_id_seq; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO postgres;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO dashboard_user;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO anon;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO authenticated;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO service_role;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO supabase_realtime_admin;


--
-- Name: TABLE buckets; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.buckets TO anon;
GRANT ALL ON TABLE storage.buckets TO authenticated;
GRANT ALL ON TABLE storage.buckets TO service_role;
GRANT ALL ON TABLE storage.buckets TO postgres WITH GRANT OPTION;


--
-- Name: TABLE buckets_analytics; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.buckets_analytics TO service_role;
GRANT ALL ON TABLE storage.buckets_analytics TO authenticated;
GRANT ALL ON TABLE storage.buckets_analytics TO anon;


--
-- Name: TABLE objects; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.objects TO anon;
GRANT ALL ON TABLE storage.objects TO authenticated;
GRANT ALL ON TABLE storage.objects TO service_role;
GRANT ALL ON TABLE storage.objects TO postgres WITH GRANT OPTION;


--
-- Name: TABLE prefixes; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.prefixes TO service_role;
GRANT ALL ON TABLE storage.prefixes TO authenticated;
GRANT ALL ON TABLE storage.prefixes TO anon;


--
-- Name: TABLE s3_multipart_uploads; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO anon;


--
-- Name: TABLE s3_multipart_uploads_parts; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads_parts TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO anon;


--
-- Name: TABLE secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,REFERENCES,DELETE,TRUNCATE ON TABLE vault.secrets TO postgres WITH GRANT OPTION;
GRANT SELECT,DELETE ON TABLE vault.secrets TO service_role;


--
-- Name: TABLE decrypted_secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,REFERENCES,DELETE,TRUNCATE ON TABLE vault.decrypted_secrets TO postgres WITH GRANT OPTION;
GRANT SELECT,DELETE ON TABLE vault.decrypted_secrets TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON SEQUENCES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON FUNCTIONS TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON TABLES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO service_role;


--
-- Name: issue_graphql_placeholder; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop
         WHEN TAG IN ('DROP EXTENSION')
   EXECUTE FUNCTION extensions.set_graphql_placeholder();


ALTER EVENT TRIGGER issue_graphql_placeholder OWNER TO supabase_admin;

--
-- Name: issue_pg_cron_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_cron_access();


ALTER EVENT TRIGGER issue_pg_cron_access OWNER TO supabase_admin;

--
-- Name: issue_pg_graphql_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end
         WHEN TAG IN ('CREATE FUNCTION')
   EXECUTE FUNCTION extensions.grant_pg_graphql_access();


ALTER EVENT TRIGGER issue_pg_graphql_access OWNER TO supabase_admin;

--
-- Name: issue_pg_net_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_net_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_net_access();


ALTER EVENT TRIGGER issue_pg_net_access OWNER TO supabase_admin;

--
-- Name: pgrst_ddl_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_ddl_watch ON ddl_command_end
   EXECUTE FUNCTION extensions.pgrst_ddl_watch();


ALTER EVENT TRIGGER pgrst_ddl_watch OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_drop_watch ON sql_drop
   EXECUTE FUNCTION extensions.pgrst_drop_watch();


ALTER EVENT TRIGGER pgrst_drop_watch OWNER TO supabase_admin;

--
-- PostgreSQL database dump complete
--

\unrestrict 0h58bBZ4Qx3TGsKNQq4jhKouyYfLP0tHNuLR1DrPSIA2lZJ9Kfsfm4YjR8O6Hj0

--
-- PostgreSQL database cluster dump complete
--

